// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file injective/wasmx/v1/proposal.proto (package injective.wasmx.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";
import { StoreCodeProposal } from "../../../cosmwasm/wasm/v1/proposal_legacy_pb.js";

/**
 * @generated from enum injective.wasmx.v1.FundingMode
 */
export enum FundingMode {
  /**
   * @generated from enum value: Unspecified = 0;
   */
  Unspecified = 0,

  /**
   * @generated from enum value: SelfFunded = 1;
   */
  SelfFunded = 1,

  /**
   * @generated from enum value: GrantOnly = 2;
   */
  GrantOnly = 2,

  /**
   * @generated from enum value: Dual = 3;
   */
  Dual = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(FundingMode)
proto3.util.setEnumType(FundingMode, "injective.wasmx.v1.FundingMode", [
  { no: 0, name: "Unspecified" },
  { no: 1, name: "SelfFunded" },
  { no: 2, name: "GrantOnly" },
  { no: 3, name: "Dual" },
]);

/**
 * @generated from message injective.wasmx.v1.ContractRegistrationRequestProposal
 */
export class ContractRegistrationRequestProposal extends Message<ContractRegistrationRequestProposal> {
  /**
   * @generated from field: string title = 1;
   */
  title = "";

  /**
   * @generated from field: string description = 2;
   */
  description = "";

  /**
   * @generated from field: injective.wasmx.v1.ContractRegistrationRequest contract_registration_request = 3;
   */
  contractRegistrationRequest?: ContractRegistrationRequest;

  constructor(data?: PartialMessage<ContractRegistrationRequestProposal>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.wasmx.v1.ContractRegistrationRequestProposal";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "title", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "contract_registration_request", kind: "message", T: ContractRegistrationRequest },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ContractRegistrationRequestProposal {
    return new ContractRegistrationRequestProposal().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ContractRegistrationRequestProposal {
    return new ContractRegistrationRequestProposal().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ContractRegistrationRequestProposal {
    return new ContractRegistrationRequestProposal().fromJsonString(jsonString, options);
  }

  static equals(a: ContractRegistrationRequestProposal | PlainMessage<ContractRegistrationRequestProposal> | undefined, b: ContractRegistrationRequestProposal | PlainMessage<ContractRegistrationRequestProposal> | undefined): boolean {
    return proto3.util.equals(ContractRegistrationRequestProposal, a, b);
  }
}

/**
 * @generated from message injective.wasmx.v1.BatchContractRegistrationRequestProposal
 */
export class BatchContractRegistrationRequestProposal extends Message<BatchContractRegistrationRequestProposal> {
  /**
   * @generated from field: string title = 1;
   */
  title = "";

  /**
   * @generated from field: string description = 2;
   */
  description = "";

  /**
   * @generated from field: repeated injective.wasmx.v1.ContractRegistrationRequest contract_registration_requests = 3;
   */
  contractRegistrationRequests: ContractRegistrationRequest[] = [];

  constructor(data?: PartialMessage<BatchContractRegistrationRequestProposal>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.wasmx.v1.BatchContractRegistrationRequestProposal";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "title", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "contract_registration_requests", kind: "message", T: ContractRegistrationRequest, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BatchContractRegistrationRequestProposal {
    return new BatchContractRegistrationRequestProposal().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BatchContractRegistrationRequestProposal {
    return new BatchContractRegistrationRequestProposal().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BatchContractRegistrationRequestProposal {
    return new BatchContractRegistrationRequestProposal().fromJsonString(jsonString, options);
  }

  static equals(a: BatchContractRegistrationRequestProposal | PlainMessage<BatchContractRegistrationRequestProposal> | undefined, b: BatchContractRegistrationRequestProposal | PlainMessage<BatchContractRegistrationRequestProposal> | undefined): boolean {
    return proto3.util.equals(BatchContractRegistrationRequestProposal, a, b);
  }
}

/**
 * @generated from message injective.wasmx.v1.BatchContractDeregistrationProposal
 */
export class BatchContractDeregistrationProposal extends Message<BatchContractDeregistrationProposal> {
  /**
   * @generated from field: string title = 1;
   */
  title = "";

  /**
   * @generated from field: string description = 2;
   */
  description = "";

  /**
   * @generated from field: repeated string contracts = 3;
   */
  contracts: string[] = [];

  constructor(data?: PartialMessage<BatchContractDeregistrationProposal>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.wasmx.v1.BatchContractDeregistrationProposal";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "title", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "contracts", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BatchContractDeregistrationProposal {
    return new BatchContractDeregistrationProposal().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BatchContractDeregistrationProposal {
    return new BatchContractDeregistrationProposal().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BatchContractDeregistrationProposal {
    return new BatchContractDeregistrationProposal().fromJsonString(jsonString, options);
  }

  static equals(a: BatchContractDeregistrationProposal | PlainMessage<BatchContractDeregistrationProposal> | undefined, b: BatchContractDeregistrationProposal | PlainMessage<BatchContractDeregistrationProposal> | undefined): boolean {
    return proto3.util.equals(BatchContractDeregistrationProposal, a, b);
  }
}

/**
 * @generated from message injective.wasmx.v1.ContractRegistrationRequest
 */
export class ContractRegistrationRequest extends Message<ContractRegistrationRequest> {
  /**
   * Unique Identifier for contract instance to be registered.
   *
   * @generated from field: string contract_address = 1;
   */
  contractAddress = "";

  /**
   * Maximum gas to be used for the smart contract execution.
   *
   * @generated from field: uint64 gas_limit = 2;
   */
  gasLimit = protoInt64.zero;

  /**
   * gas price to be used for the smart contract execution.
   *
   * @generated from field: uint64 gas_price = 3;
   */
  gasPrice = protoInt64.zero;

  /**
   * @generated from field: bool should_pin_contract = 4;
   */
  shouldPinContract = false;

  /**
   * if true contract owner can update it, if false only current code_id will be
   * allowed to be executed
   *
   * @generated from field: bool is_migration_allowed = 5;
   */
  isMigrationAllowed = false;

  /**
   * code_id of the contract being registered - will be verified upon every
   * execution but only if is_migration_allowed is false
   *
   * @generated from field: uint64 code_id = 6;
   */
  codeId = protoInt64.zero;

  /**
   * Optional address of admin account (that will be allowed to pause or update
   * contract params)
   *
   * @generated from field: string admin_address = 7;
   */
  adminAddress = "";

  /**
   * Optional address of the contract that grants fees. Must be set if
   * funding_mode is other than SelfFunded
   *
   * @generated from field: string granter_address = 8;
   */
  granterAddress = "";

  /**
   * Specifies how the contract will fund its execution
   *
   * @generated from field: injective.wasmx.v1.FundingMode funding_mode = 9;
   */
  fundingMode = FundingMode.Unspecified;

  constructor(data?: PartialMessage<ContractRegistrationRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.wasmx.v1.ContractRegistrationRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "contract_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "gas_limit", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 3, name: "gas_price", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 4, name: "should_pin_contract", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "is_migration_allowed", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "code_id", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 7, name: "admin_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "granter_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "funding_mode", kind: "enum", T: proto3.getEnumType(FundingMode) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ContractRegistrationRequest {
    return new ContractRegistrationRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ContractRegistrationRequest {
    return new ContractRegistrationRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ContractRegistrationRequest {
    return new ContractRegistrationRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ContractRegistrationRequest | PlainMessage<ContractRegistrationRequest> | undefined, b: ContractRegistrationRequest | PlainMessage<ContractRegistrationRequest> | undefined): boolean {
    return proto3.util.equals(ContractRegistrationRequest, a, b);
  }
}

/**
 * @generated from message injective.wasmx.v1.BatchStoreCodeProposal
 */
export class BatchStoreCodeProposal extends Message<BatchStoreCodeProposal> {
  /**
   * @generated from field: string title = 1;
   */
  title = "";

  /**
   * @generated from field: string description = 2;
   */
  description = "";

  /**
   * @generated from field: repeated cosmwasm.wasm.v1.StoreCodeProposal proposals = 3;
   */
  proposals: StoreCodeProposal[] = [];

  constructor(data?: PartialMessage<BatchStoreCodeProposal>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.wasmx.v1.BatchStoreCodeProposal";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "title", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "proposals", kind: "message", T: StoreCodeProposal, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BatchStoreCodeProposal {
    return new BatchStoreCodeProposal().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BatchStoreCodeProposal {
    return new BatchStoreCodeProposal().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BatchStoreCodeProposal {
    return new BatchStoreCodeProposal().fromJsonString(jsonString, options);
  }

  static equals(a: BatchStoreCodeProposal | PlainMessage<BatchStoreCodeProposal> | undefined, b: BatchStoreCodeProposal | PlainMessage<BatchStoreCodeProposal> | undefined): boolean {
    return proto3.util.equals(BatchStoreCodeProposal, a, b);
  }
}

