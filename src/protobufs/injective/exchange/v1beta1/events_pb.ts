// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file injective/exchange/v1beta1/events.proto (package injective.exchange.v1beta1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";
import { AccountRewards, BinaryOptionsMarket, CampaignRewardPool, DepositUpdate, DerivativeLimitOrder, DerivativeMarket, DerivativeMarketOrder, DerivativeOrder, DerivativeTradeLog, ExecutionType, ExpiryFuturesMarketInfo, FeeDiscountSchedule, Level, MarketFeeMultiplier, PerpetualMarketFunding, PerpetualMarketInfo, SpotLimitOrder, SpotMarket, SubaccountPosition, TradeLog, TradingRewardCampaignInfo } from "./exchange_pb.js";
import { Coin } from "../../../cosmos/base/v1beta1/coin_pb.js";

/**
 * @generated from message injective.exchange.v1beta1.EventBatchSpotExecution
 */
export class EventBatchSpotExecution extends Message<EventBatchSpotExecution> {
  /**
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  /**
   * @generated from field: bool is_buy = 2;
   */
  isBuy = false;

  /**
   * @generated from field: injective.exchange.v1beta1.ExecutionType executionType = 3;
   */
  executionType = ExecutionType.UnspecifiedExecutionType;

  /**
   * @generated from field: repeated injective.exchange.v1beta1.TradeLog trades = 4;
   */
  trades: TradeLog[] = [];

  constructor(data?: PartialMessage<EventBatchSpotExecution>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.EventBatchSpotExecution";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "is_buy", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "executionType", kind: "enum", T: proto3.getEnumType(ExecutionType) },
    { no: 4, name: "trades", kind: "message", T: TradeLog, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventBatchSpotExecution {
    return new EventBatchSpotExecution().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventBatchSpotExecution {
    return new EventBatchSpotExecution().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventBatchSpotExecution {
    return new EventBatchSpotExecution().fromJsonString(jsonString, options);
  }

  static equals(a: EventBatchSpotExecution | PlainMessage<EventBatchSpotExecution> | undefined, b: EventBatchSpotExecution | PlainMessage<EventBatchSpotExecution> | undefined): boolean {
    return proto3.util.equals(EventBatchSpotExecution, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.EventBatchDerivativeExecution
 */
export class EventBatchDerivativeExecution extends Message<EventBatchDerivativeExecution> {
  /**
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  /**
   * @generated from field: bool is_buy = 2;
   */
  isBuy = false;

  /**
   * @generated from field: bool is_liquidation = 3;
   */
  isLiquidation = false;

  /**
   * nil for time expiry futures
   *
   * @generated from field: string cumulative_funding = 4;
   */
  cumulativeFunding = "";

  /**
   * @generated from field: injective.exchange.v1beta1.ExecutionType executionType = 5;
   */
  executionType = ExecutionType.UnspecifiedExecutionType;

  /**
   * @generated from field: repeated injective.exchange.v1beta1.DerivativeTradeLog trades = 6;
   */
  trades: DerivativeTradeLog[] = [];

  constructor(data?: PartialMessage<EventBatchDerivativeExecution>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.EventBatchDerivativeExecution";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "is_buy", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "is_liquidation", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "cumulative_funding", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "executionType", kind: "enum", T: proto3.getEnumType(ExecutionType) },
    { no: 6, name: "trades", kind: "message", T: DerivativeTradeLog, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventBatchDerivativeExecution {
    return new EventBatchDerivativeExecution().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventBatchDerivativeExecution {
    return new EventBatchDerivativeExecution().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventBatchDerivativeExecution {
    return new EventBatchDerivativeExecution().fromJsonString(jsonString, options);
  }

  static equals(a: EventBatchDerivativeExecution | PlainMessage<EventBatchDerivativeExecution> | undefined, b: EventBatchDerivativeExecution | PlainMessage<EventBatchDerivativeExecution> | undefined): boolean {
    return proto3.util.equals(EventBatchDerivativeExecution, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.EventLostFundsFromLiquidation
 */
export class EventLostFundsFromLiquidation extends Message<EventLostFundsFromLiquidation> {
  /**
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  /**
   * @generated from field: bytes subaccount_id = 2;
   */
  subaccountId = new Uint8Array(0);

  /**
   * @generated from field: string lost_funds_from_available_during_payout = 3;
   */
  lostFundsFromAvailableDuringPayout = "";

  /**
   * @generated from field: string lost_funds_from_order_cancels = 4;
   */
  lostFundsFromOrderCancels = "";

  constructor(data?: PartialMessage<EventLostFundsFromLiquidation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.EventLostFundsFromLiquidation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "subaccount_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "lost_funds_from_available_during_payout", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "lost_funds_from_order_cancels", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventLostFundsFromLiquidation {
    return new EventLostFundsFromLiquidation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventLostFundsFromLiquidation {
    return new EventLostFundsFromLiquidation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventLostFundsFromLiquidation {
    return new EventLostFundsFromLiquidation().fromJsonString(jsonString, options);
  }

  static equals(a: EventLostFundsFromLiquidation | PlainMessage<EventLostFundsFromLiquidation> | undefined, b: EventLostFundsFromLiquidation | PlainMessage<EventLostFundsFromLiquidation> | undefined): boolean {
    return proto3.util.equals(EventLostFundsFromLiquidation, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.EventBatchDerivativePosition
 */
export class EventBatchDerivativePosition extends Message<EventBatchDerivativePosition> {
  /**
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  /**
   * @generated from field: repeated injective.exchange.v1beta1.SubaccountPosition positions = 2;
   */
  positions: SubaccountPosition[] = [];

  constructor(data?: PartialMessage<EventBatchDerivativePosition>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.EventBatchDerivativePosition";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "positions", kind: "message", T: SubaccountPosition, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventBatchDerivativePosition {
    return new EventBatchDerivativePosition().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventBatchDerivativePosition {
    return new EventBatchDerivativePosition().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventBatchDerivativePosition {
    return new EventBatchDerivativePosition().fromJsonString(jsonString, options);
  }

  static equals(a: EventBatchDerivativePosition | PlainMessage<EventBatchDerivativePosition> | undefined, b: EventBatchDerivativePosition | PlainMessage<EventBatchDerivativePosition> | undefined): boolean {
    return proto3.util.equals(EventBatchDerivativePosition, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.EventDerivativeMarketPaused
 */
export class EventDerivativeMarketPaused extends Message<EventDerivativeMarketPaused> {
  /**
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  /**
   * @generated from field: string settle_price = 2;
   */
  settlePrice = "";

  /**
   * @generated from field: string total_missing_funds = 3;
   */
  totalMissingFunds = "";

  /**
   * @generated from field: string missing_funds_rate = 4;
   */
  missingFundsRate = "";

  constructor(data?: PartialMessage<EventDerivativeMarketPaused>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.EventDerivativeMarketPaused";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "settle_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "total_missing_funds", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "missing_funds_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventDerivativeMarketPaused {
    return new EventDerivativeMarketPaused().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventDerivativeMarketPaused {
    return new EventDerivativeMarketPaused().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventDerivativeMarketPaused {
    return new EventDerivativeMarketPaused().fromJsonString(jsonString, options);
  }

  static equals(a: EventDerivativeMarketPaused | PlainMessage<EventDerivativeMarketPaused> | undefined, b: EventDerivativeMarketPaused | PlainMessage<EventDerivativeMarketPaused> | undefined): boolean {
    return proto3.util.equals(EventDerivativeMarketPaused, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.EventMarketBeyondBankruptcy
 */
export class EventMarketBeyondBankruptcy extends Message<EventMarketBeyondBankruptcy> {
  /**
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  /**
   * @generated from field: string settle_price = 2;
   */
  settlePrice = "";

  /**
   * @generated from field: string missing_market_funds = 3;
   */
  missingMarketFunds = "";

  constructor(data?: PartialMessage<EventMarketBeyondBankruptcy>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.EventMarketBeyondBankruptcy";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "settle_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "missing_market_funds", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventMarketBeyondBankruptcy {
    return new EventMarketBeyondBankruptcy().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventMarketBeyondBankruptcy {
    return new EventMarketBeyondBankruptcy().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventMarketBeyondBankruptcy {
    return new EventMarketBeyondBankruptcy().fromJsonString(jsonString, options);
  }

  static equals(a: EventMarketBeyondBankruptcy | PlainMessage<EventMarketBeyondBankruptcy> | undefined, b: EventMarketBeyondBankruptcy | PlainMessage<EventMarketBeyondBankruptcy> | undefined): boolean {
    return proto3.util.equals(EventMarketBeyondBankruptcy, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.EventAllPositionsHaircut
 */
export class EventAllPositionsHaircut extends Message<EventAllPositionsHaircut> {
  /**
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  /**
   * @generated from field: string settle_price = 2;
   */
  settlePrice = "";

  /**
   * @generated from field: string missing_funds_rate = 3;
   */
  missingFundsRate = "";

  constructor(data?: PartialMessage<EventAllPositionsHaircut>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.EventAllPositionsHaircut";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "settle_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "missing_funds_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventAllPositionsHaircut {
    return new EventAllPositionsHaircut().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventAllPositionsHaircut {
    return new EventAllPositionsHaircut().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventAllPositionsHaircut {
    return new EventAllPositionsHaircut().fromJsonString(jsonString, options);
  }

  static equals(a: EventAllPositionsHaircut | PlainMessage<EventAllPositionsHaircut> | undefined, b: EventAllPositionsHaircut | PlainMessage<EventAllPositionsHaircut> | undefined): boolean {
    return proto3.util.equals(EventAllPositionsHaircut, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.EventBinaryOptionsMarketUpdate
 */
export class EventBinaryOptionsMarketUpdate extends Message<EventBinaryOptionsMarketUpdate> {
  /**
   * @generated from field: injective.exchange.v1beta1.BinaryOptionsMarket market = 1;
   */
  market?: BinaryOptionsMarket;

  constructor(data?: PartialMessage<EventBinaryOptionsMarketUpdate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.EventBinaryOptionsMarketUpdate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market", kind: "message", T: BinaryOptionsMarket },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventBinaryOptionsMarketUpdate {
    return new EventBinaryOptionsMarketUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventBinaryOptionsMarketUpdate {
    return new EventBinaryOptionsMarketUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventBinaryOptionsMarketUpdate {
    return new EventBinaryOptionsMarketUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: EventBinaryOptionsMarketUpdate | PlainMessage<EventBinaryOptionsMarketUpdate> | undefined, b: EventBinaryOptionsMarketUpdate | PlainMessage<EventBinaryOptionsMarketUpdate> | undefined): boolean {
    return proto3.util.equals(EventBinaryOptionsMarketUpdate, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.EventNewSpotOrders
 */
export class EventNewSpotOrders extends Message<EventNewSpotOrders> {
  /**
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  /**
   * @generated from field: repeated injective.exchange.v1beta1.SpotLimitOrder buy_orders = 2;
   */
  buyOrders: SpotLimitOrder[] = [];

  /**
   * @generated from field: repeated injective.exchange.v1beta1.SpotLimitOrder sell_orders = 3;
   */
  sellOrders: SpotLimitOrder[] = [];

  constructor(data?: PartialMessage<EventNewSpotOrders>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.EventNewSpotOrders";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "buy_orders", kind: "message", T: SpotLimitOrder, repeated: true },
    { no: 3, name: "sell_orders", kind: "message", T: SpotLimitOrder, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventNewSpotOrders {
    return new EventNewSpotOrders().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventNewSpotOrders {
    return new EventNewSpotOrders().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventNewSpotOrders {
    return new EventNewSpotOrders().fromJsonString(jsonString, options);
  }

  static equals(a: EventNewSpotOrders | PlainMessage<EventNewSpotOrders> | undefined, b: EventNewSpotOrders | PlainMessage<EventNewSpotOrders> | undefined): boolean {
    return proto3.util.equals(EventNewSpotOrders, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.EventNewDerivativeOrders
 */
export class EventNewDerivativeOrders extends Message<EventNewDerivativeOrders> {
  /**
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  /**
   * @generated from field: repeated injective.exchange.v1beta1.DerivativeLimitOrder buy_orders = 2;
   */
  buyOrders: DerivativeLimitOrder[] = [];

  /**
   * @generated from field: repeated injective.exchange.v1beta1.DerivativeLimitOrder sell_orders = 3;
   */
  sellOrders: DerivativeLimitOrder[] = [];

  constructor(data?: PartialMessage<EventNewDerivativeOrders>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.EventNewDerivativeOrders";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "buy_orders", kind: "message", T: DerivativeLimitOrder, repeated: true },
    { no: 3, name: "sell_orders", kind: "message", T: DerivativeLimitOrder, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventNewDerivativeOrders {
    return new EventNewDerivativeOrders().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventNewDerivativeOrders {
    return new EventNewDerivativeOrders().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventNewDerivativeOrders {
    return new EventNewDerivativeOrders().fromJsonString(jsonString, options);
  }

  static equals(a: EventNewDerivativeOrders | PlainMessage<EventNewDerivativeOrders> | undefined, b: EventNewDerivativeOrders | PlainMessage<EventNewDerivativeOrders> | undefined): boolean {
    return proto3.util.equals(EventNewDerivativeOrders, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.EventCancelSpotOrder
 */
export class EventCancelSpotOrder extends Message<EventCancelSpotOrder> {
  /**
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  /**
   * @generated from field: injective.exchange.v1beta1.SpotLimitOrder order = 2;
   */
  order?: SpotLimitOrder;

  constructor(data?: PartialMessage<EventCancelSpotOrder>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.EventCancelSpotOrder";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "order", kind: "message", T: SpotLimitOrder },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventCancelSpotOrder {
    return new EventCancelSpotOrder().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventCancelSpotOrder {
    return new EventCancelSpotOrder().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventCancelSpotOrder {
    return new EventCancelSpotOrder().fromJsonString(jsonString, options);
  }

  static equals(a: EventCancelSpotOrder | PlainMessage<EventCancelSpotOrder> | undefined, b: EventCancelSpotOrder | PlainMessage<EventCancelSpotOrder> | undefined): boolean {
    return proto3.util.equals(EventCancelSpotOrder, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.EventSpotMarketUpdate
 */
export class EventSpotMarketUpdate extends Message<EventSpotMarketUpdate> {
  /**
   * @generated from field: injective.exchange.v1beta1.SpotMarket market = 1;
   */
  market?: SpotMarket;

  constructor(data?: PartialMessage<EventSpotMarketUpdate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.EventSpotMarketUpdate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market", kind: "message", T: SpotMarket },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventSpotMarketUpdate {
    return new EventSpotMarketUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventSpotMarketUpdate {
    return new EventSpotMarketUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventSpotMarketUpdate {
    return new EventSpotMarketUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: EventSpotMarketUpdate | PlainMessage<EventSpotMarketUpdate> | undefined, b: EventSpotMarketUpdate | PlainMessage<EventSpotMarketUpdate> | undefined): boolean {
    return proto3.util.equals(EventSpotMarketUpdate, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.EventPerpetualMarketUpdate
 */
export class EventPerpetualMarketUpdate extends Message<EventPerpetualMarketUpdate> {
  /**
   * @generated from field: injective.exchange.v1beta1.DerivativeMarket market = 1;
   */
  market?: DerivativeMarket;

  /**
   * @generated from field: injective.exchange.v1beta1.PerpetualMarketInfo perpetual_market_info = 2;
   */
  perpetualMarketInfo?: PerpetualMarketInfo;

  /**
   * @generated from field: injective.exchange.v1beta1.PerpetualMarketFunding funding = 3;
   */
  funding?: PerpetualMarketFunding;

  constructor(data?: PartialMessage<EventPerpetualMarketUpdate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.EventPerpetualMarketUpdate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market", kind: "message", T: DerivativeMarket },
    { no: 2, name: "perpetual_market_info", kind: "message", T: PerpetualMarketInfo },
    { no: 3, name: "funding", kind: "message", T: PerpetualMarketFunding },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventPerpetualMarketUpdate {
    return new EventPerpetualMarketUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventPerpetualMarketUpdate {
    return new EventPerpetualMarketUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventPerpetualMarketUpdate {
    return new EventPerpetualMarketUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: EventPerpetualMarketUpdate | PlainMessage<EventPerpetualMarketUpdate> | undefined, b: EventPerpetualMarketUpdate | PlainMessage<EventPerpetualMarketUpdate> | undefined): boolean {
    return proto3.util.equals(EventPerpetualMarketUpdate, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.EventExpiryFuturesMarketUpdate
 */
export class EventExpiryFuturesMarketUpdate extends Message<EventExpiryFuturesMarketUpdate> {
  /**
   * @generated from field: injective.exchange.v1beta1.DerivativeMarket market = 1;
   */
  market?: DerivativeMarket;

  /**
   * @generated from field: injective.exchange.v1beta1.ExpiryFuturesMarketInfo expiry_futures_market_info = 3;
   */
  expiryFuturesMarketInfo?: ExpiryFuturesMarketInfo;

  constructor(data?: PartialMessage<EventExpiryFuturesMarketUpdate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.EventExpiryFuturesMarketUpdate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market", kind: "message", T: DerivativeMarket },
    { no: 3, name: "expiry_futures_market_info", kind: "message", T: ExpiryFuturesMarketInfo },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventExpiryFuturesMarketUpdate {
    return new EventExpiryFuturesMarketUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventExpiryFuturesMarketUpdate {
    return new EventExpiryFuturesMarketUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventExpiryFuturesMarketUpdate {
    return new EventExpiryFuturesMarketUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: EventExpiryFuturesMarketUpdate | PlainMessage<EventExpiryFuturesMarketUpdate> | undefined, b: EventExpiryFuturesMarketUpdate | PlainMessage<EventExpiryFuturesMarketUpdate> | undefined): boolean {
    return proto3.util.equals(EventExpiryFuturesMarketUpdate, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate
 */
export class EventPerpetualMarketFundingUpdate extends Message<EventPerpetualMarketFundingUpdate> {
  /**
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  /**
   * @generated from field: injective.exchange.v1beta1.PerpetualMarketFunding funding = 2;
   */
  funding?: PerpetualMarketFunding;

  /**
   * @generated from field: bool is_hourly_funding = 3;
   */
  isHourlyFunding = false;

  /**
   * @generated from field: string funding_rate = 4;
   */
  fundingRate = "";

  /**
   * @generated from field: string mark_price = 5;
   */
  markPrice = "";

  constructor(data?: PartialMessage<EventPerpetualMarketFundingUpdate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "funding", kind: "message", T: PerpetualMarketFunding },
    { no: 3, name: "is_hourly_funding", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "funding_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "mark_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventPerpetualMarketFundingUpdate {
    return new EventPerpetualMarketFundingUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventPerpetualMarketFundingUpdate {
    return new EventPerpetualMarketFundingUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventPerpetualMarketFundingUpdate {
    return new EventPerpetualMarketFundingUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: EventPerpetualMarketFundingUpdate | PlainMessage<EventPerpetualMarketFundingUpdate> | undefined, b: EventPerpetualMarketFundingUpdate | PlainMessage<EventPerpetualMarketFundingUpdate> | undefined): boolean {
    return proto3.util.equals(EventPerpetualMarketFundingUpdate, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.EventSubaccountDeposit
 */
export class EventSubaccountDeposit extends Message<EventSubaccountDeposit> {
  /**
   * @generated from field: string src_address = 1;
   */
  srcAddress = "";

  /**
   * @generated from field: bytes subaccount_id = 2;
   */
  subaccountId = new Uint8Array(0);

  /**
   * @generated from field: cosmos.base.v1beta1.Coin amount = 3;
   */
  amount?: Coin;

  constructor(data?: PartialMessage<EventSubaccountDeposit>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.EventSubaccountDeposit";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "src_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "subaccount_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "amount", kind: "message", T: Coin },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventSubaccountDeposit {
    return new EventSubaccountDeposit().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventSubaccountDeposit {
    return new EventSubaccountDeposit().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventSubaccountDeposit {
    return new EventSubaccountDeposit().fromJsonString(jsonString, options);
  }

  static equals(a: EventSubaccountDeposit | PlainMessage<EventSubaccountDeposit> | undefined, b: EventSubaccountDeposit | PlainMessage<EventSubaccountDeposit> | undefined): boolean {
    return proto3.util.equals(EventSubaccountDeposit, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.EventSubaccountWithdraw
 */
export class EventSubaccountWithdraw extends Message<EventSubaccountWithdraw> {
  /**
   * @generated from field: bytes subaccount_id = 1;
   */
  subaccountId = new Uint8Array(0);

  /**
   * @generated from field: string dst_address = 2;
   */
  dstAddress = "";

  /**
   * @generated from field: cosmos.base.v1beta1.Coin amount = 3;
   */
  amount?: Coin;

  constructor(data?: PartialMessage<EventSubaccountWithdraw>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.EventSubaccountWithdraw";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "subaccount_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "dst_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "amount", kind: "message", T: Coin },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventSubaccountWithdraw {
    return new EventSubaccountWithdraw().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventSubaccountWithdraw {
    return new EventSubaccountWithdraw().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventSubaccountWithdraw {
    return new EventSubaccountWithdraw().fromJsonString(jsonString, options);
  }

  static equals(a: EventSubaccountWithdraw | PlainMessage<EventSubaccountWithdraw> | undefined, b: EventSubaccountWithdraw | PlainMessage<EventSubaccountWithdraw> | undefined): boolean {
    return proto3.util.equals(EventSubaccountWithdraw, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.EventSubaccountBalanceTransfer
 */
export class EventSubaccountBalanceTransfer extends Message<EventSubaccountBalanceTransfer> {
  /**
   * @generated from field: string src_subaccount_id = 1;
   */
  srcSubaccountId = "";

  /**
   * @generated from field: string dst_subaccount_id = 2;
   */
  dstSubaccountId = "";

  /**
   * @generated from field: cosmos.base.v1beta1.Coin amount = 3;
   */
  amount?: Coin;

  constructor(data?: PartialMessage<EventSubaccountBalanceTransfer>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.EventSubaccountBalanceTransfer";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "src_subaccount_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "dst_subaccount_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "amount", kind: "message", T: Coin },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventSubaccountBalanceTransfer {
    return new EventSubaccountBalanceTransfer().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventSubaccountBalanceTransfer {
    return new EventSubaccountBalanceTransfer().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventSubaccountBalanceTransfer {
    return new EventSubaccountBalanceTransfer().fromJsonString(jsonString, options);
  }

  static equals(a: EventSubaccountBalanceTransfer | PlainMessage<EventSubaccountBalanceTransfer> | undefined, b: EventSubaccountBalanceTransfer | PlainMessage<EventSubaccountBalanceTransfer> | undefined): boolean {
    return proto3.util.equals(EventSubaccountBalanceTransfer, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.EventBatchDepositUpdate
 */
export class EventBatchDepositUpdate extends Message<EventBatchDepositUpdate> {
  /**
   * @generated from field: repeated injective.exchange.v1beta1.DepositUpdate deposit_updates = 1;
   */
  depositUpdates: DepositUpdate[] = [];

  constructor(data?: PartialMessage<EventBatchDepositUpdate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.EventBatchDepositUpdate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "deposit_updates", kind: "message", T: DepositUpdate, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventBatchDepositUpdate {
    return new EventBatchDepositUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventBatchDepositUpdate {
    return new EventBatchDepositUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventBatchDepositUpdate {
    return new EventBatchDepositUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: EventBatchDepositUpdate | PlainMessage<EventBatchDepositUpdate> | undefined, b: EventBatchDepositUpdate | PlainMessage<EventBatchDepositUpdate> | undefined): boolean {
    return proto3.util.equals(EventBatchDepositUpdate, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.DerivativeMarketOrderCancel
 */
export class DerivativeMarketOrderCancel extends Message<DerivativeMarketOrderCancel> {
  /**
   * @generated from field: injective.exchange.v1beta1.DerivativeMarketOrder market_order = 1;
   */
  marketOrder?: DerivativeMarketOrder;

  /**
   * @generated from field: string cancel_quantity = 2;
   */
  cancelQuantity = "";

  constructor(data?: PartialMessage<DerivativeMarketOrderCancel>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.DerivativeMarketOrderCancel";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_order", kind: "message", T: DerivativeMarketOrder },
    { no: 2, name: "cancel_quantity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DerivativeMarketOrderCancel {
    return new DerivativeMarketOrderCancel().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DerivativeMarketOrderCancel {
    return new DerivativeMarketOrderCancel().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DerivativeMarketOrderCancel {
    return new DerivativeMarketOrderCancel().fromJsonString(jsonString, options);
  }

  static equals(a: DerivativeMarketOrderCancel | PlainMessage<DerivativeMarketOrderCancel> | undefined, b: DerivativeMarketOrderCancel | PlainMessage<DerivativeMarketOrderCancel> | undefined): boolean {
    return proto3.util.equals(DerivativeMarketOrderCancel, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.EventCancelDerivativeOrder
 */
export class EventCancelDerivativeOrder extends Message<EventCancelDerivativeOrder> {
  /**
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  /**
   * @generated from field: bool isLimitCancel = 2;
   */
  isLimitCancel = false;

  /**
   * @generated from field: injective.exchange.v1beta1.DerivativeLimitOrder limit_order = 3;
   */
  limitOrder?: DerivativeLimitOrder;

  /**
   * @generated from field: injective.exchange.v1beta1.DerivativeMarketOrderCancel market_order_cancel = 4;
   */
  marketOrderCancel?: DerivativeMarketOrderCancel;

  constructor(data?: PartialMessage<EventCancelDerivativeOrder>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.EventCancelDerivativeOrder";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "isLimitCancel", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "limit_order", kind: "message", T: DerivativeLimitOrder },
    { no: 4, name: "market_order_cancel", kind: "message", T: DerivativeMarketOrderCancel },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventCancelDerivativeOrder {
    return new EventCancelDerivativeOrder().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventCancelDerivativeOrder {
    return new EventCancelDerivativeOrder().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventCancelDerivativeOrder {
    return new EventCancelDerivativeOrder().fromJsonString(jsonString, options);
  }

  static equals(a: EventCancelDerivativeOrder | PlainMessage<EventCancelDerivativeOrder> | undefined, b: EventCancelDerivativeOrder | PlainMessage<EventCancelDerivativeOrder> | undefined): boolean {
    return proto3.util.equals(EventCancelDerivativeOrder, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.EventFeeDiscountSchedule
 */
export class EventFeeDiscountSchedule extends Message<EventFeeDiscountSchedule> {
  /**
   * @generated from field: injective.exchange.v1beta1.FeeDiscountSchedule schedule = 1;
   */
  schedule?: FeeDiscountSchedule;

  constructor(data?: PartialMessage<EventFeeDiscountSchedule>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.EventFeeDiscountSchedule";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "schedule", kind: "message", T: FeeDiscountSchedule },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventFeeDiscountSchedule {
    return new EventFeeDiscountSchedule().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventFeeDiscountSchedule {
    return new EventFeeDiscountSchedule().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventFeeDiscountSchedule {
    return new EventFeeDiscountSchedule().fromJsonString(jsonString, options);
  }

  static equals(a: EventFeeDiscountSchedule | PlainMessage<EventFeeDiscountSchedule> | undefined, b: EventFeeDiscountSchedule | PlainMessage<EventFeeDiscountSchedule> | undefined): boolean {
    return proto3.util.equals(EventFeeDiscountSchedule, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.EventTradingRewardCampaignUpdate
 */
export class EventTradingRewardCampaignUpdate extends Message<EventTradingRewardCampaignUpdate> {
  /**
   * @generated from field: injective.exchange.v1beta1.TradingRewardCampaignInfo campaign_info = 1;
   */
  campaignInfo?: TradingRewardCampaignInfo;

  /**
   * @generated from field: repeated injective.exchange.v1beta1.CampaignRewardPool campaign_reward_pools = 2;
   */
  campaignRewardPools: CampaignRewardPool[] = [];

  constructor(data?: PartialMessage<EventTradingRewardCampaignUpdate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.EventTradingRewardCampaignUpdate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "campaign_info", kind: "message", T: TradingRewardCampaignInfo },
    { no: 2, name: "campaign_reward_pools", kind: "message", T: CampaignRewardPool, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventTradingRewardCampaignUpdate {
    return new EventTradingRewardCampaignUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventTradingRewardCampaignUpdate {
    return new EventTradingRewardCampaignUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventTradingRewardCampaignUpdate {
    return new EventTradingRewardCampaignUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: EventTradingRewardCampaignUpdate | PlainMessage<EventTradingRewardCampaignUpdate> | undefined, b: EventTradingRewardCampaignUpdate | PlainMessage<EventTradingRewardCampaignUpdate> | undefined): boolean {
    return proto3.util.equals(EventTradingRewardCampaignUpdate, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.EventTradingRewardDistribution
 */
export class EventTradingRewardDistribution extends Message<EventTradingRewardDistribution> {
  /**
   * @generated from field: repeated injective.exchange.v1beta1.AccountRewards account_rewards = 1;
   */
  accountRewards: AccountRewards[] = [];

  constructor(data?: PartialMessage<EventTradingRewardDistribution>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.EventTradingRewardDistribution";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "account_rewards", kind: "message", T: AccountRewards, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventTradingRewardDistribution {
    return new EventTradingRewardDistribution().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventTradingRewardDistribution {
    return new EventTradingRewardDistribution().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventTradingRewardDistribution {
    return new EventTradingRewardDistribution().fromJsonString(jsonString, options);
  }

  static equals(a: EventTradingRewardDistribution | PlainMessage<EventTradingRewardDistribution> | undefined, b: EventTradingRewardDistribution | PlainMessage<EventTradingRewardDistribution> | undefined): boolean {
    return proto3.util.equals(EventTradingRewardDistribution, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.EventNewConditionalDerivativeOrder
 */
export class EventNewConditionalDerivativeOrder extends Message<EventNewConditionalDerivativeOrder> {
  /**
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  /**
   * @generated from field: injective.exchange.v1beta1.DerivativeOrder order = 2;
   */
  order?: DerivativeOrder;

  /**
   * @generated from field: bytes hash = 3;
   */
  hash = new Uint8Array(0);

  /**
   * @generated from field: bool is_market = 4;
   */
  isMarket = false;

  constructor(data?: PartialMessage<EventNewConditionalDerivativeOrder>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.EventNewConditionalDerivativeOrder";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "order", kind: "message", T: DerivativeOrder },
    { no: 3, name: "hash", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 4, name: "is_market", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventNewConditionalDerivativeOrder {
    return new EventNewConditionalDerivativeOrder().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventNewConditionalDerivativeOrder {
    return new EventNewConditionalDerivativeOrder().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventNewConditionalDerivativeOrder {
    return new EventNewConditionalDerivativeOrder().fromJsonString(jsonString, options);
  }

  static equals(a: EventNewConditionalDerivativeOrder | PlainMessage<EventNewConditionalDerivativeOrder> | undefined, b: EventNewConditionalDerivativeOrder | PlainMessage<EventNewConditionalDerivativeOrder> | undefined): boolean {
    return proto3.util.equals(EventNewConditionalDerivativeOrder, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.EventCancelConditionalDerivativeOrder
 */
export class EventCancelConditionalDerivativeOrder extends Message<EventCancelConditionalDerivativeOrder> {
  /**
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  /**
   * @generated from field: bool isLimitCancel = 2;
   */
  isLimitCancel = false;

  /**
   * @generated from field: injective.exchange.v1beta1.DerivativeLimitOrder limit_order = 3;
   */
  limitOrder?: DerivativeLimitOrder;

  /**
   * @generated from field: injective.exchange.v1beta1.DerivativeMarketOrder market_order = 4;
   */
  marketOrder?: DerivativeMarketOrder;

  constructor(data?: PartialMessage<EventCancelConditionalDerivativeOrder>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.EventCancelConditionalDerivativeOrder";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "isLimitCancel", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "limit_order", kind: "message", T: DerivativeLimitOrder },
    { no: 4, name: "market_order", kind: "message", T: DerivativeMarketOrder },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventCancelConditionalDerivativeOrder {
    return new EventCancelConditionalDerivativeOrder().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventCancelConditionalDerivativeOrder {
    return new EventCancelConditionalDerivativeOrder().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventCancelConditionalDerivativeOrder {
    return new EventCancelConditionalDerivativeOrder().fromJsonString(jsonString, options);
  }

  static equals(a: EventCancelConditionalDerivativeOrder | PlainMessage<EventCancelConditionalDerivativeOrder> | undefined, b: EventCancelConditionalDerivativeOrder | PlainMessage<EventCancelConditionalDerivativeOrder> | undefined): boolean {
    return proto3.util.equals(EventCancelConditionalDerivativeOrder, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.EventConditionalDerivativeOrderTrigger
 */
export class EventConditionalDerivativeOrderTrigger extends Message<EventConditionalDerivativeOrderTrigger> {
  /**
   * @generated from field: bytes market_id = 1;
   */
  marketId = new Uint8Array(0);

  /**
   * @generated from field: bool isLimitTrigger = 2;
   */
  isLimitTrigger = false;

  /**
   * @generated from field: bytes triggered_order_hash = 3;
   */
  triggeredOrderHash = new Uint8Array(0);

  /**
   * @generated from field: bytes placed_order_hash = 4;
   */
  placedOrderHash = new Uint8Array(0);

  constructor(data?: PartialMessage<EventConditionalDerivativeOrderTrigger>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.EventConditionalDerivativeOrderTrigger";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "isLimitTrigger", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "triggered_order_hash", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 4, name: "placed_order_hash", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventConditionalDerivativeOrderTrigger {
    return new EventConditionalDerivativeOrderTrigger().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventConditionalDerivativeOrderTrigger {
    return new EventConditionalDerivativeOrderTrigger().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventConditionalDerivativeOrderTrigger {
    return new EventConditionalDerivativeOrderTrigger().fromJsonString(jsonString, options);
  }

  static equals(a: EventConditionalDerivativeOrderTrigger | PlainMessage<EventConditionalDerivativeOrderTrigger> | undefined, b: EventConditionalDerivativeOrderTrigger | PlainMessage<EventConditionalDerivativeOrderTrigger> | undefined): boolean {
    return proto3.util.equals(EventConditionalDerivativeOrderTrigger, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.EventOrderFail
 */
export class EventOrderFail extends Message<EventOrderFail> {
  /**
   * @generated from field: bytes account = 1;
   */
  account = new Uint8Array(0);

  /**
   * @generated from field: repeated bytes hashes = 2;
   */
  hashes: Uint8Array[] = [];

  /**
   * @generated from field: repeated uint32 flags = 3;
   */
  flags: number[] = [];

  constructor(data?: PartialMessage<EventOrderFail>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.EventOrderFail";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "account", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "hashes", kind: "scalar", T: 12 /* ScalarType.BYTES */, repeated: true },
    { no: 3, name: "flags", kind: "scalar", T: 13 /* ScalarType.UINT32 */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventOrderFail {
    return new EventOrderFail().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventOrderFail {
    return new EventOrderFail().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventOrderFail {
    return new EventOrderFail().fromJsonString(jsonString, options);
  }

  static equals(a: EventOrderFail | PlainMessage<EventOrderFail> | undefined, b: EventOrderFail | PlainMessage<EventOrderFail> | undefined): boolean {
    return proto3.util.equals(EventOrderFail, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.EventAtomicMarketOrderFeeMultipliersUpdated
 */
export class EventAtomicMarketOrderFeeMultipliersUpdated extends Message<EventAtomicMarketOrderFeeMultipliersUpdated> {
  /**
   * @generated from field: repeated injective.exchange.v1beta1.MarketFeeMultiplier market_fee_multipliers = 1;
   */
  marketFeeMultipliers: MarketFeeMultiplier[] = [];

  constructor(data?: PartialMessage<EventAtomicMarketOrderFeeMultipliersUpdated>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.EventAtomicMarketOrderFeeMultipliersUpdated";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_fee_multipliers", kind: "message", T: MarketFeeMultiplier, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventAtomicMarketOrderFeeMultipliersUpdated {
    return new EventAtomicMarketOrderFeeMultipliersUpdated().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventAtomicMarketOrderFeeMultipliersUpdated {
    return new EventAtomicMarketOrderFeeMultipliersUpdated().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventAtomicMarketOrderFeeMultipliersUpdated {
    return new EventAtomicMarketOrderFeeMultipliersUpdated().fromJsonString(jsonString, options);
  }

  static equals(a: EventAtomicMarketOrderFeeMultipliersUpdated | PlainMessage<EventAtomicMarketOrderFeeMultipliersUpdated> | undefined, b: EventAtomicMarketOrderFeeMultipliersUpdated | PlainMessage<EventAtomicMarketOrderFeeMultipliersUpdated> | undefined): boolean {
    return proto3.util.equals(EventAtomicMarketOrderFeeMultipliersUpdated, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.EventOrderbookUpdate
 */
export class EventOrderbookUpdate extends Message<EventOrderbookUpdate> {
  /**
   * @generated from field: repeated injective.exchange.v1beta1.OrderbookUpdate spot_updates = 1;
   */
  spotUpdates: OrderbookUpdate[] = [];

  /**
   * @generated from field: repeated injective.exchange.v1beta1.OrderbookUpdate derivative_updates = 2;
   */
  derivativeUpdates: OrderbookUpdate[] = [];

  constructor(data?: PartialMessage<EventOrderbookUpdate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.EventOrderbookUpdate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "spot_updates", kind: "message", T: OrderbookUpdate, repeated: true },
    { no: 2, name: "derivative_updates", kind: "message", T: OrderbookUpdate, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventOrderbookUpdate {
    return new EventOrderbookUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventOrderbookUpdate {
    return new EventOrderbookUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventOrderbookUpdate {
    return new EventOrderbookUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: EventOrderbookUpdate | PlainMessage<EventOrderbookUpdate> | undefined, b: EventOrderbookUpdate | PlainMessage<EventOrderbookUpdate> | undefined): boolean {
    return proto3.util.equals(EventOrderbookUpdate, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.OrderbookUpdate
 */
export class OrderbookUpdate extends Message<OrderbookUpdate> {
  /**
   * @generated from field: uint64 seq = 1;
   */
  seq = protoInt64.zero;

  /**
   * @generated from field: injective.exchange.v1beta1.Orderbook orderbook = 2;
   */
  orderbook?: Orderbook;

  constructor(data?: PartialMessage<OrderbookUpdate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.OrderbookUpdate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "seq", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "orderbook", kind: "message", T: Orderbook },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OrderbookUpdate {
    return new OrderbookUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OrderbookUpdate {
    return new OrderbookUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OrderbookUpdate {
    return new OrderbookUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: OrderbookUpdate | PlainMessage<OrderbookUpdate> | undefined, b: OrderbookUpdate | PlainMessage<OrderbookUpdate> | undefined): boolean {
    return proto3.util.equals(OrderbookUpdate, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.Orderbook
 */
export class Orderbook extends Message<Orderbook> {
  /**
   * @generated from field: bytes market_id = 1;
   */
  marketId = new Uint8Array(0);

  /**
   * @generated from field: repeated injective.exchange.v1beta1.Level buy_levels = 2;
   */
  buyLevels: Level[] = [];

  /**
   * @generated from field: repeated injective.exchange.v1beta1.Level sell_levels = 3;
   */
  sellLevels: Level[] = [];

  constructor(data?: PartialMessage<Orderbook>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.Orderbook";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "buy_levels", kind: "message", T: Level, repeated: true },
    { no: 3, name: "sell_levels", kind: "message", T: Level, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Orderbook {
    return new Orderbook().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Orderbook {
    return new Orderbook().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Orderbook {
    return new Orderbook().fromJsonString(jsonString, options);
  }

  static equals(a: Orderbook | PlainMessage<Orderbook> | undefined, b: Orderbook | PlainMessage<Orderbook> | undefined): boolean {
    return proto3.util.equals(Orderbook, a, b);
  }
}

