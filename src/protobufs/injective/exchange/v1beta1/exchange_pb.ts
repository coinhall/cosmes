// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file injective/exchange/v1beta1/exchange.proto (package injective.exchange.v1beta1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";
import { Coin } from "../../../cosmos/base/v1beta1/coin_pb.js";
import { OracleType } from "../../oracle/v1beta1/oracle_pb.js";

/**
 * @generated from enum injective.exchange.v1beta1.AtomicMarketOrderAccessLevel
 */
export enum AtomicMarketOrderAccessLevel {
  /**
   * @generated from enum value: Nobody = 0;
   */
  Nobody = 0,

  /**
   * currently unsupported
   *
   * @generated from enum value: BeginBlockerSmartContractsOnly = 1;
   */
  BeginBlockerSmartContractsOnly = 1,

  /**
   * @generated from enum value: SmartContractsOnly = 2;
   */
  SmartContractsOnly = 2,

  /**
   * @generated from enum value: Everyone = 3;
   */
  Everyone = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(AtomicMarketOrderAccessLevel)
proto3.util.setEnumType(AtomicMarketOrderAccessLevel, "injective.exchange.v1beta1.AtomicMarketOrderAccessLevel", [
  { no: 0, name: "Nobody" },
  { no: 1, name: "BeginBlockerSmartContractsOnly" },
  { no: 2, name: "SmartContractsOnly" },
  { no: 3, name: "Everyone" },
]);

/**
 * @generated from enum injective.exchange.v1beta1.MarketStatus
 */
export enum MarketStatus {
  /**
   * @generated from enum value: Unspecified = 0;
   */
  Unspecified = 0,

  /**
   * @generated from enum value: Active = 1;
   */
  Active = 1,

  /**
   * @generated from enum value: Paused = 2;
   */
  Paused = 2,

  /**
   * @generated from enum value: Demolished = 3;
   */
  Demolished = 3,

  /**
   * @generated from enum value: Expired = 4;
   */
  Expired = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(MarketStatus)
proto3.util.setEnumType(MarketStatus, "injective.exchange.v1beta1.MarketStatus", [
  { no: 0, name: "Unspecified" },
  { no: 1, name: "Active" },
  { no: 2, name: "Paused" },
  { no: 3, name: "Demolished" },
  { no: 4, name: "Expired" },
]);

/**
 * @generated from enum injective.exchange.v1beta1.OrderType
 */
export enum OrderType {
  /**
   * @generated from enum value: UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: BUY = 1;
   */
  BUY = 1,

  /**
   * @generated from enum value: SELL = 2;
   */
  SELL = 2,

  /**
   * @generated from enum value: STOP_BUY = 3;
   */
  STOP_BUY = 3,

  /**
   * @generated from enum value: STOP_SELL = 4;
   */
  STOP_SELL = 4,

  /**
   * @generated from enum value: TAKE_BUY = 5;
   */
  TAKE_BUY = 5,

  /**
   * @generated from enum value: TAKE_SELL = 6;
   */
  TAKE_SELL = 6,

  /**
   * @generated from enum value: BUY_PO = 7;
   */
  BUY_PO = 7,

  /**
   * @generated from enum value: SELL_PO = 8;
   */
  SELL_PO = 8,

  /**
   * @generated from enum value: BUY_ATOMIC = 9;
   */
  BUY_ATOMIC = 9,

  /**
   * @generated from enum value: SELL_ATOMIC = 10;
   */
  SELL_ATOMIC = 10,
}
// Retrieve enum metadata with: proto3.getEnumType(OrderType)
proto3.util.setEnumType(OrderType, "injective.exchange.v1beta1.OrderType", [
  { no: 0, name: "UNSPECIFIED" },
  { no: 1, name: "BUY" },
  { no: 2, name: "SELL" },
  { no: 3, name: "STOP_BUY" },
  { no: 4, name: "STOP_SELL" },
  { no: 5, name: "TAKE_BUY" },
  { no: 6, name: "TAKE_SELL" },
  { no: 7, name: "BUY_PO" },
  { no: 8, name: "SELL_PO" },
  { no: 9, name: "BUY_ATOMIC" },
  { no: 10, name: "SELL_ATOMIC" },
]);

/**
 * @generated from enum injective.exchange.v1beta1.ExecutionType
 */
export enum ExecutionType {
  /**
   * @generated from enum value: UnspecifiedExecutionType = 0;
   */
  UnspecifiedExecutionType = 0,

  /**
   * @generated from enum value: Market = 1;
   */
  Market = 1,

  /**
   * @generated from enum value: LimitFill = 2;
   */
  LimitFill = 2,

  /**
   * @generated from enum value: LimitMatchRestingOrder = 3;
   */
  LimitMatchRestingOrder = 3,

  /**
   * @generated from enum value: LimitMatchNewOrder = 4;
   */
  LimitMatchNewOrder = 4,

  /**
   * @generated from enum value: MarketLiquidation = 5;
   */
  MarketLiquidation = 5,

  /**
   * @generated from enum value: ExpiryMarketSettlement = 6;
   */
  ExpiryMarketSettlement = 6,
}
// Retrieve enum metadata with: proto3.getEnumType(ExecutionType)
proto3.util.setEnumType(ExecutionType, "injective.exchange.v1beta1.ExecutionType", [
  { no: 0, name: "UnspecifiedExecutionType" },
  { no: 1, name: "Market" },
  { no: 2, name: "LimitFill" },
  { no: 3, name: "LimitMatchRestingOrder" },
  { no: 4, name: "LimitMatchNewOrder" },
  { no: 5, name: "MarketLiquidation" },
  { no: 6, name: "ExpiryMarketSettlement" },
]);

/**
 * @generated from enum injective.exchange.v1beta1.OrderMask
 */
export enum OrderMask {
  /**
   * @generated from enum value: UNUSED = 0;
   */
  UNUSED = 0,

  /**
   * @generated from enum value: ANY = 1;
   */
  ANY = 1,

  /**
   * @generated from enum value: REGULAR = 2;
   */
  REGULAR = 2,

  /**
   * @generated from enum value: CONDITIONAL = 4;
   */
  CONDITIONAL = 4,

  /**
   * for conditional orders means HIGHER
   *
   * @generated from enum value: DIRECTION_BUY_OR_HIGHER = 8;
   */
  DIRECTION_BUY_OR_HIGHER = 8,

  /**
   * for conditional orders means LOWER
   *
   * @generated from enum value: DIRECTION_SELL_OR_LOWER = 16;
   */
  DIRECTION_SELL_OR_LOWER = 16,

  /**
   * @generated from enum value: TYPE_MARKET = 32;
   */
  TYPE_MARKET = 32,

  /**
   * @generated from enum value: TYPE_LIMIT = 64;
   */
  TYPE_LIMIT = 64,
}
// Retrieve enum metadata with: proto3.getEnumType(OrderMask)
proto3.util.setEnumType(OrderMask, "injective.exchange.v1beta1.OrderMask", [
  { no: 0, name: "UNUSED" },
  { no: 1, name: "ANY" },
  { no: 2, name: "REGULAR" },
  { no: 4, name: "CONDITIONAL" },
  { no: 8, name: "DIRECTION_BUY_OR_HIGHER" },
  { no: 16, name: "DIRECTION_SELL_OR_LOWER" },
  { no: 32, name: "TYPE_MARKET" },
  { no: 64, name: "TYPE_LIMIT" },
]);

/**
 * @generated from message injective.exchange.v1beta1.Params
 */
export class Params extends Message<Params> {
  /**
   * spot_market_instant_listing_fee defines the expedited fee in INJ required
   * to create a spot market by bypassing governance
   *
   * @generated from field: cosmos.base.v1beta1.Coin spot_market_instant_listing_fee = 1;
   */
  spotMarketInstantListingFee?: Coin;

  /**
   * derivative_market_instant_listing_fee defines the expedited fee in INJ
   * required to create a derivative market by bypassing governance
   *
   * @generated from field: cosmos.base.v1beta1.Coin derivative_market_instant_listing_fee = 2;
   */
  derivativeMarketInstantListingFee?: Coin;

  /**
   * default_spot_maker_fee defines the default exchange trade fee for makers on
   * a spot market
   *
   * @generated from field: string default_spot_maker_fee_rate = 3;
   */
  defaultSpotMakerFeeRate = "";

  /**
   * default_spot_taker_fee_rate defines the default exchange trade fee rate for
   * takers on a new spot market
   *
   * @generated from field: string default_spot_taker_fee_rate = 4;
   */
  defaultSpotTakerFeeRate = "";

  /**
   * default_derivative_maker_fee defines the default exchange trade fee for
   * makers on a new derivative market
   *
   * @generated from field: string default_derivative_maker_fee_rate = 5;
   */
  defaultDerivativeMakerFeeRate = "";

  /**
   * default_derivative_taker_fee defines the default exchange trade fee for
   * takers on a new derivative market
   *
   * @generated from field: string default_derivative_taker_fee_rate = 6;
   */
  defaultDerivativeTakerFeeRate = "";

  /**
   * default_initial_margin_ratio defines the default initial margin ratio on a
   * new derivative market
   *
   * @generated from field: string default_initial_margin_ratio = 7;
   */
  defaultInitialMarginRatio = "";

  /**
   * default_maintenance_margin_ratio defines the default maintenance margin
   * ratio on a new derivative market
   *
   * @generated from field: string default_maintenance_margin_ratio = 8;
   */
  defaultMaintenanceMarginRatio = "";

  /**
   * default_funding_interval defines the default funding interval on a
   * derivative market
   *
   * @generated from field: int64 default_funding_interval = 9;
   */
  defaultFundingInterval = protoInt64.zero;

  /**
   * funding_multiple defines the timestamp multiple that the funding timestamp
   * should be a multiple of
   *
   * @generated from field: int64 funding_multiple = 10;
   */
  fundingMultiple = protoInt64.zero;

  /**
   * relayer_fee_share_rate defines the trade fee share percentage that goes to
   * relayers
   *
   * @generated from field: string relayer_fee_share_rate = 11;
   */
  relayerFeeShareRate = "";

  /**
   * default_hourly_funding_rate_cap defines the default maximum absolute value
   * of the hourly funding rate
   *
   * @generated from field: string default_hourly_funding_rate_cap = 12;
   */
  defaultHourlyFundingRateCap = "";

  /**
   * hourly_interest_rate defines the hourly interest rate
   *
   * @generated from field: string default_hourly_interest_rate = 13;
   */
  defaultHourlyInterestRate = "";

  /**
   * max_derivative_order_side_count defines the maximum number of derivative
   * active orders a subaccount can have for a given orderbook side
   *
   * @generated from field: uint32 max_derivative_order_side_count = 14;
   */
  maxDerivativeOrderSideCount = 0;

  /**
   * inj_reward_staked_requirement_threshold defines the threshold on INJ
   * rewards after which one also needs staked INJ to receive more
   *
   * @generated from field: string inj_reward_staked_requirement_threshold = 15;
   */
  injRewardStakedRequirementThreshold = "";

  /**
   * the trading_rewards_vesting_duration defines the vesting times for trading
   * rewards
   *
   * @generated from field: int64 trading_rewards_vesting_duration = 16;
   */
  tradingRewardsVestingDuration = protoInt64.zero;

  /**
   * liquidator_reward_share_rate defines the ratio of the split of the surplus
   * collateral that goes to the liquidator
   *
   * @generated from field: string liquidator_reward_share_rate = 17;
   */
  liquidatorRewardShareRate = "";

  /**
   * binary_options_market_instant_listing_fee defines the expedited fee in INJ
   * required to create a derivative market by bypassing governance
   *
   * @generated from field: cosmos.base.v1beta1.Coin binary_options_market_instant_listing_fee = 18;
   */
  binaryOptionsMarketInstantListingFee?: Coin;

  /**
   * atomic_market_order_access_level defines the required access permissions
   * for executing atomic market orders
   *
   * @generated from field: injective.exchange.v1beta1.AtomicMarketOrderAccessLevel atomic_market_order_access_level = 19;
   */
  atomicMarketOrderAccessLevel = AtomicMarketOrderAccessLevel.Nobody;

  /**
   * spot_atomic_market_order_fee_multiplier defines the default multiplier for
   * executing atomic market orders in spot markets
   *
   * @generated from field: string spot_atomic_market_order_fee_multiplier = 20;
   */
  spotAtomicMarketOrderFeeMultiplier = "";

  /**
   * derivative_atomic_market_order_fee_multiplier defines the default
   * multiplier for executing atomic market orders in derivative markets
   *
   * @generated from field: string derivative_atomic_market_order_fee_multiplier = 21;
   */
  derivativeAtomicMarketOrderFeeMultiplier = "";

  /**
   * binary_options_atomic_market_order_fee_multiplier defines the default
   * multiplier for executing atomic market orders in binary markets
   *
   * @generated from field: string binary_options_atomic_market_order_fee_multiplier = 22;
   */
  binaryOptionsAtomicMarketOrderFeeMultiplier = "";

  /**
   * minimal_protocol_fee_rate defines the minimal protocol fee rate
   *
   * @generated from field: string minimal_protocol_fee_rate = 23;
   */
  minimalProtocolFeeRate = "";

  /**
   * is_instant_derivative_market_launch_enabled defines whether instant
   * derivative market launch is enabled
   *
   * @generated from field: bool is_instant_derivative_market_launch_enabled = 24;
   */
  isInstantDerivativeMarketLaunchEnabled = false;

  /**
   * @generated from field: int64 post_only_mode_height_threshold = 25;
   */
  postOnlyModeHeightThreshold = protoInt64.zero;

  constructor(data?: PartialMessage<Params>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.Params";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "spot_market_instant_listing_fee", kind: "message", T: Coin },
    { no: 2, name: "derivative_market_instant_listing_fee", kind: "message", T: Coin },
    { no: 3, name: "default_spot_maker_fee_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "default_spot_taker_fee_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "default_derivative_maker_fee_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "default_derivative_taker_fee_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "default_initial_margin_ratio", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "default_maintenance_margin_ratio", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "default_funding_interval", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 10, name: "funding_multiple", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 11, name: "relayer_fee_share_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 12, name: "default_hourly_funding_rate_cap", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 13, name: "default_hourly_interest_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 14, name: "max_derivative_order_side_count", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 15, name: "inj_reward_staked_requirement_threshold", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 16, name: "trading_rewards_vesting_duration", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 17, name: "liquidator_reward_share_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 18, name: "binary_options_market_instant_listing_fee", kind: "message", T: Coin },
    { no: 19, name: "atomic_market_order_access_level", kind: "enum", T: proto3.getEnumType(AtomicMarketOrderAccessLevel) },
    { no: 20, name: "spot_atomic_market_order_fee_multiplier", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 21, name: "derivative_atomic_market_order_fee_multiplier", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 22, name: "binary_options_atomic_market_order_fee_multiplier", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 23, name: "minimal_protocol_fee_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 24, name: "is_instant_derivative_market_launch_enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 25, name: "post_only_mode_height_threshold", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Params {
    return new Params().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Params {
    return new Params().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Params {
    return new Params().fromJsonString(jsonString, options);
  }

  static equals(a: Params | PlainMessage<Params> | undefined, b: Params | PlainMessage<Params> | undefined): boolean {
    return proto3.util.equals(Params, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.MarketFeeMultiplier
 */
export class MarketFeeMultiplier extends Message<MarketFeeMultiplier> {
  /**
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  /**
   * @generated from field: string fee_multiplier = 2;
   */
  feeMultiplier = "";

  constructor(data?: PartialMessage<MarketFeeMultiplier>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.MarketFeeMultiplier";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "fee_multiplier", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MarketFeeMultiplier {
    return new MarketFeeMultiplier().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MarketFeeMultiplier {
    return new MarketFeeMultiplier().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MarketFeeMultiplier {
    return new MarketFeeMultiplier().fromJsonString(jsonString, options);
  }

  static equals(a: MarketFeeMultiplier | PlainMessage<MarketFeeMultiplier> | undefined, b: MarketFeeMultiplier | PlainMessage<MarketFeeMultiplier> | undefined): boolean {
    return proto3.util.equals(MarketFeeMultiplier, a, b);
  }
}

/**
 * An object describing a derivative market in the Injective Futures Protocol.
 *
 * @generated from message injective.exchange.v1beta1.DerivativeMarket
 */
export class DerivativeMarket extends Message<DerivativeMarket> {
  /**
   * Ticker for the derivative contract.
   *
   * @generated from field: string ticker = 1;
   */
  ticker = "";

  /**
   * Oracle base currency
   *
   * @generated from field: string oracle_base = 2;
   */
  oracleBase = "";

  /**
   * Oracle quote currency
   *
   * @generated from field: string oracle_quote = 3;
   */
  oracleQuote = "";

  /**
   * Oracle type
   *
   * @generated from field: injective.oracle.v1beta1.OracleType oracle_type = 4;
   */
  oracleType = OracleType.Unspecified;

  /**
   * Scale factor for oracle prices.
   *
   * @generated from field: uint32 oracle_scale_factor = 5;
   */
  oracleScaleFactor = 0;

  /**
   * Address of the quote currency denomination for the derivative contract
   *
   * @generated from field: string quote_denom = 6;
   */
  quoteDenom = "";

  /**
   * Unique market ID.
   *
   * @generated from field: string market_id = 7;
   */
  marketId = "";

  /**
   * initial_margin_ratio defines the initial margin ratio of a derivative
   * market
   *
   * @generated from field: string initial_margin_ratio = 8;
   */
  initialMarginRatio = "";

  /**
   * maintenance_margin_ratio defines the maintenance margin ratio of a
   * derivative market
   *
   * @generated from field: string maintenance_margin_ratio = 9;
   */
  maintenanceMarginRatio = "";

  /**
   * maker_fee_rate defines the maker fee rate of a derivative market
   *
   * @generated from field: string maker_fee_rate = 10;
   */
  makerFeeRate = "";

  /**
   * taker_fee_rate defines the taker fee rate of a derivative market
   *
   * @generated from field: string taker_fee_rate = 11;
   */
  takerFeeRate = "";

  /**
   * relayer_fee_share_rate defines the percentage of the transaction fee shared
   * with the relayer in a derivative market
   *
   * @generated from field: string relayer_fee_share_rate = 12;
   */
  relayerFeeShareRate = "";

  /**
   * true if the market is a perpetual market. false if the market is an expiry
   * futures market
   *
   * @generated from field: bool isPerpetual = 13;
   */
  isPerpetual = false;

  /**
   * Status of the market
   *
   * @generated from field: injective.exchange.v1beta1.MarketStatus status = 14;
   */
  status = MarketStatus.Unspecified;

  /**
   * min_price_tick_size defines the minimum tick size that the price and margin
   * required for orders in the market
   *
   * @generated from field: string min_price_tick_size = 15;
   */
  minPriceTickSize = "";

  /**
   * min_quantity_tick_size defines the minimum tick size of the quantity
   * required for orders in the market
   *
   * @generated from field: string min_quantity_tick_size = 16;
   */
  minQuantityTickSize = "";

  constructor(data?: PartialMessage<DerivativeMarket>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.DerivativeMarket";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ticker", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "oracle_base", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "oracle_quote", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "oracle_type", kind: "enum", T: proto3.getEnumType(OracleType) },
    { no: 5, name: "oracle_scale_factor", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 6, name: "quote_denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "initial_margin_ratio", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "maintenance_margin_ratio", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "maker_fee_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "taker_fee_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 12, name: "relayer_fee_share_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 13, name: "isPerpetual", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 14, name: "status", kind: "enum", T: proto3.getEnumType(MarketStatus) },
    { no: 15, name: "min_price_tick_size", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 16, name: "min_quantity_tick_size", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DerivativeMarket {
    return new DerivativeMarket().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DerivativeMarket {
    return new DerivativeMarket().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DerivativeMarket {
    return new DerivativeMarket().fromJsonString(jsonString, options);
  }

  static equals(a: DerivativeMarket | PlainMessage<DerivativeMarket> | undefined, b: DerivativeMarket | PlainMessage<DerivativeMarket> | undefined): boolean {
    return proto3.util.equals(DerivativeMarket, a, b);
  }
}

/**
 * An object describing a binary options market in Injective Protocol.
 *
 * @generated from message injective.exchange.v1beta1.BinaryOptionsMarket
 */
export class BinaryOptionsMarket extends Message<BinaryOptionsMarket> {
  /**
   * Ticker for the derivative contract.
   *
   * @generated from field: string ticker = 1;
   */
  ticker = "";

  /**
   * Oracle symbol
   *
   * @generated from field: string oracle_symbol = 2;
   */
  oracleSymbol = "";

  /**
   * Oracle Provider
   *
   * @generated from field: string oracle_provider = 3;
   */
  oracleProvider = "";

  /**
   * Oracle type
   *
   * @generated from field: injective.oracle.v1beta1.OracleType oracle_type = 4;
   */
  oracleType = OracleType.Unspecified;

  /**
   * Scale factor for oracle prices.
   *
   * @generated from field: uint32 oracle_scale_factor = 5;
   */
  oracleScaleFactor = 0;

  /**
   * expiration timestamp
   *
   * @generated from field: int64 expiration_timestamp = 6;
   */
  expirationTimestamp = protoInt64.zero;

  /**
   * expiration timestamp
   *
   * @generated from field: int64 settlement_timestamp = 7;
   */
  settlementTimestamp = protoInt64.zero;

  /**
   * admin of the market
   *
   * @generated from field: string admin = 8;
   */
  admin = "";

  /**
   * Address of the quote currency denomination for the binary options contract
   *
   * @generated from field: string quote_denom = 9;
   */
  quoteDenom = "";

  /**
   * Unique market ID.
   *
   * @generated from field: string market_id = 10;
   */
  marketId = "";

  /**
   * maker_fee_rate defines the maker fee rate of a binary options market
   *
   * @generated from field: string maker_fee_rate = 11;
   */
  makerFeeRate = "";

  /**
   * taker_fee_rate defines the taker fee rate of a derivative market
   *
   * @generated from field: string taker_fee_rate = 12;
   */
  takerFeeRate = "";

  /**
   * relayer_fee_share_rate defines the percentage of the transaction fee shared
   * with the relayer in a derivative market
   *
   * @generated from field: string relayer_fee_share_rate = 13;
   */
  relayerFeeShareRate = "";

  /**
   * Status of the market
   *
   * @generated from field: injective.exchange.v1beta1.MarketStatus status = 14;
   */
  status = MarketStatus.Unspecified;

  /**
   * min_price_tick_size defines the minimum tick size that the price and margin
   * required for orders in the market
   *
   * @generated from field: string min_price_tick_size = 15;
   */
  minPriceTickSize = "";

  /**
   * min_quantity_tick_size defines the minimum tick size of the quantity
   * required for orders in the market
   *
   * @generated from field: string min_quantity_tick_size = 16;
   */
  minQuantityTickSize = "";

  /**
   * @generated from field: string settlement_price = 17;
   */
  settlementPrice = "";

  constructor(data?: PartialMessage<BinaryOptionsMarket>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.BinaryOptionsMarket";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ticker", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "oracle_symbol", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "oracle_provider", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "oracle_type", kind: "enum", T: proto3.getEnumType(OracleType) },
    { no: 5, name: "oracle_scale_factor", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 6, name: "expiration_timestamp", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 7, name: "settlement_timestamp", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 8, name: "admin", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "quote_denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "maker_fee_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 12, name: "taker_fee_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 13, name: "relayer_fee_share_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 14, name: "status", kind: "enum", T: proto3.getEnumType(MarketStatus) },
    { no: 15, name: "min_price_tick_size", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 16, name: "min_quantity_tick_size", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 17, name: "settlement_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BinaryOptionsMarket {
    return new BinaryOptionsMarket().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BinaryOptionsMarket {
    return new BinaryOptionsMarket().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BinaryOptionsMarket {
    return new BinaryOptionsMarket().fromJsonString(jsonString, options);
  }

  static equals(a: BinaryOptionsMarket | PlainMessage<BinaryOptionsMarket> | undefined, b: BinaryOptionsMarket | PlainMessage<BinaryOptionsMarket> | undefined): boolean {
    return proto3.util.equals(BinaryOptionsMarket, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.ExpiryFuturesMarketInfo
 */
export class ExpiryFuturesMarketInfo extends Message<ExpiryFuturesMarketInfo> {
  /**
   * market ID.
   *
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  /**
   * expiration_timestamp defines the expiration time for a time expiry futures
   * market.
   *
   * @generated from field: int64 expiration_timestamp = 2;
   */
  expirationTimestamp = protoInt64.zero;

  /**
   * expiration_twap_start_timestamp defines the start time of the TWAP
   * calculation window
   *
   * @generated from field: int64 twap_start_timestamp = 3;
   */
  twapStartTimestamp = protoInt64.zero;

  /**
   * expiration_twap_start_price_cumulative defines the cumulative price for the
   * start of the TWAP window
   *
   * @generated from field: string expiration_twap_start_price_cumulative = 4;
   */
  expirationTwapStartPriceCumulative = "";

  /**
   * settlement_price defines the settlement price for a time expiry futures
   * market.
   *
   * @generated from field: string settlement_price = 5;
   */
  settlementPrice = "";

  constructor(data?: PartialMessage<ExpiryFuturesMarketInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.ExpiryFuturesMarketInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "expiration_timestamp", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "twap_start_timestamp", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 4, name: "expiration_twap_start_price_cumulative", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "settlement_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExpiryFuturesMarketInfo {
    return new ExpiryFuturesMarketInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExpiryFuturesMarketInfo {
    return new ExpiryFuturesMarketInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExpiryFuturesMarketInfo {
    return new ExpiryFuturesMarketInfo().fromJsonString(jsonString, options);
  }

  static equals(a: ExpiryFuturesMarketInfo | PlainMessage<ExpiryFuturesMarketInfo> | undefined, b: ExpiryFuturesMarketInfo | PlainMessage<ExpiryFuturesMarketInfo> | undefined): boolean {
    return proto3.util.equals(ExpiryFuturesMarketInfo, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.PerpetualMarketInfo
 */
export class PerpetualMarketInfo extends Message<PerpetualMarketInfo> {
  /**
   * market ID.
   *
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  /**
   * hourly_funding_rate_cap defines the maximum absolute value of the hourly
   * funding rate
   *
   * @generated from field: string hourly_funding_rate_cap = 2;
   */
  hourlyFundingRateCap = "";

  /**
   * hourly_interest_rate defines the hourly interest rate
   *
   * @generated from field: string hourly_interest_rate = 3;
   */
  hourlyInterestRate = "";

  /**
   * next_funding_timestamp defines the next funding timestamp in seconds of a
   * perpetual market
   *
   * @generated from field: int64 next_funding_timestamp = 4;
   */
  nextFundingTimestamp = protoInt64.zero;

  /**
   * funding_interval defines the next funding interval in seconds of a
   * perpetual market.
   *
   * @generated from field: int64 funding_interval = 5;
   */
  fundingInterval = protoInt64.zero;

  constructor(data?: PartialMessage<PerpetualMarketInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.PerpetualMarketInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "hourly_funding_rate_cap", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "hourly_interest_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "next_funding_timestamp", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 5, name: "funding_interval", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PerpetualMarketInfo {
    return new PerpetualMarketInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PerpetualMarketInfo {
    return new PerpetualMarketInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PerpetualMarketInfo {
    return new PerpetualMarketInfo().fromJsonString(jsonString, options);
  }

  static equals(a: PerpetualMarketInfo | PlainMessage<PerpetualMarketInfo> | undefined, b: PerpetualMarketInfo | PlainMessage<PerpetualMarketInfo> | undefined): boolean {
    return proto3.util.equals(PerpetualMarketInfo, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.PerpetualMarketFunding
 */
export class PerpetualMarketFunding extends Message<PerpetualMarketFunding> {
  /**
   * cumulative_funding defines the cumulative funding of a perpetual market.
   *
   * @generated from field: string cumulative_funding = 1;
   */
  cumulativeFunding = "";

  /**
   * cumulative_price defines the cumulative price for the current hour up to
   * the last timestamp
   *
   * @generated from field: string cumulative_price = 2;
   */
  cumulativePrice = "";

  /**
   * @generated from field: int64 last_timestamp = 3;
   */
  lastTimestamp = protoInt64.zero;

  constructor(data?: PartialMessage<PerpetualMarketFunding>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.PerpetualMarketFunding";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "cumulative_funding", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "cumulative_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "last_timestamp", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PerpetualMarketFunding {
    return new PerpetualMarketFunding().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PerpetualMarketFunding {
    return new PerpetualMarketFunding().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PerpetualMarketFunding {
    return new PerpetualMarketFunding().fromJsonString(jsonString, options);
  }

  static equals(a: PerpetualMarketFunding | PlainMessage<PerpetualMarketFunding> | undefined, b: PerpetualMarketFunding | PlainMessage<PerpetualMarketFunding> | undefined): boolean {
    return proto3.util.equals(PerpetualMarketFunding, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.DerivativeMarketSettlementInfo
 */
export class DerivativeMarketSettlementInfo extends Message<DerivativeMarketSettlementInfo> {
  /**
   * market ID.
   *
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  /**
   * settlement_price defines the settlement price
   *
   * @generated from field: string settlement_price = 2;
   */
  settlementPrice = "";

  constructor(data?: PartialMessage<DerivativeMarketSettlementInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.DerivativeMarketSettlementInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "settlement_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DerivativeMarketSettlementInfo {
    return new DerivativeMarketSettlementInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DerivativeMarketSettlementInfo {
    return new DerivativeMarketSettlementInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DerivativeMarketSettlementInfo {
    return new DerivativeMarketSettlementInfo().fromJsonString(jsonString, options);
  }

  static equals(a: DerivativeMarketSettlementInfo | PlainMessage<DerivativeMarketSettlementInfo> | undefined, b: DerivativeMarketSettlementInfo | PlainMessage<DerivativeMarketSettlementInfo> | undefined): boolean {
    return proto3.util.equals(DerivativeMarketSettlementInfo, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.NextFundingTimestamp
 */
export class NextFundingTimestamp extends Message<NextFundingTimestamp> {
  /**
   * @generated from field: int64 next_timestamp = 1;
   */
  nextTimestamp = protoInt64.zero;

  constructor(data?: PartialMessage<NextFundingTimestamp>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.NextFundingTimestamp";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "next_timestamp", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NextFundingTimestamp {
    return new NextFundingTimestamp().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NextFundingTimestamp {
    return new NextFundingTimestamp().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NextFundingTimestamp {
    return new NextFundingTimestamp().fromJsonString(jsonString, options);
  }

  static equals(a: NextFundingTimestamp | PlainMessage<NextFundingTimestamp> | undefined, b: NextFundingTimestamp | PlainMessage<NextFundingTimestamp> | undefined): boolean {
    return proto3.util.equals(NextFundingTimestamp, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.MidPriceAndTOB
 */
export class MidPriceAndTOB extends Message<MidPriceAndTOB> {
  /**
   * mid price of the market
   *
   * @generated from field: string mid_price = 1;
   */
  midPrice = "";

  /**
   * best buy price of the market
   *
   * @generated from field: string best_buy_price = 2;
   */
  bestBuyPrice = "";

  /**
   * best sell price of the market
   *
   * @generated from field: string best_sell_price = 3;
   */
  bestSellPrice = "";

  constructor(data?: PartialMessage<MidPriceAndTOB>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.MidPriceAndTOB";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "mid_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "best_buy_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "best_sell_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MidPriceAndTOB {
    return new MidPriceAndTOB().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MidPriceAndTOB {
    return new MidPriceAndTOB().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MidPriceAndTOB {
    return new MidPriceAndTOB().fromJsonString(jsonString, options);
  }

  static equals(a: MidPriceAndTOB | PlainMessage<MidPriceAndTOB> | undefined, b: MidPriceAndTOB | PlainMessage<MidPriceAndTOB> | undefined): boolean {
    return proto3.util.equals(MidPriceAndTOB, a, b);
  }
}

/**
 * An object describing trade pair of two assets.
 *
 * @generated from message injective.exchange.v1beta1.SpotMarket
 */
export class SpotMarket extends Message<SpotMarket> {
  /**
   * A name of the pair in format AAA/BBB, where AAA is base asset, BBB is quote
   * asset.
   *
   * @generated from field: string ticker = 1;
   */
  ticker = "";

  /**
   * Coin denom used for the base asset
   *
   * @generated from field: string base_denom = 2;
   */
  baseDenom = "";

  /**
   * Coin used for the quote asset
   *
   * @generated from field: string quote_denom = 3;
   */
  quoteDenom = "";

  /**
   * maker_fee_rate defines the fee percentage makers pay when trading
   *
   * @generated from field: string maker_fee_rate = 4;
   */
  makerFeeRate = "";

  /**
   * taker_fee_rate defines the fee percentage takers pay when trading
   *
   * @generated from field: string taker_fee_rate = 5;
   */
  takerFeeRate = "";

  /**
   * relayer_fee_share_rate defines the percentage of the transaction fee shared
   * with the relayer in a derivative market
   *
   * @generated from field: string relayer_fee_share_rate = 6;
   */
  relayerFeeShareRate = "";

  /**
   * Unique market ID.
   *
   * @generated from field: string market_id = 7;
   */
  marketId = "";

  /**
   * Status of the market
   *
   * @generated from field: injective.exchange.v1beta1.MarketStatus status = 8;
   */
  status = MarketStatus.Unspecified;

  /**
   * min_price_tick_size defines the minimum tick size that the price required
   * for orders in the market
   *
   * @generated from field: string min_price_tick_size = 9;
   */
  minPriceTickSize = "";

  /**
   * min_quantity_tick_size defines the minimum tick size of the quantity
   * required for orders in the market
   *
   * @generated from field: string min_quantity_tick_size = 10;
   */
  minQuantityTickSize = "";

  constructor(data?: PartialMessage<SpotMarket>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.SpotMarket";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ticker", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "base_denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "quote_denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "maker_fee_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "taker_fee_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "relayer_fee_share_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "status", kind: "enum", T: proto3.getEnumType(MarketStatus) },
    { no: 9, name: "min_price_tick_size", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "min_quantity_tick_size", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SpotMarket {
    return new SpotMarket().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SpotMarket {
    return new SpotMarket().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SpotMarket {
    return new SpotMarket().fromJsonString(jsonString, options);
  }

  static equals(a: SpotMarket | PlainMessage<SpotMarket> | undefined, b: SpotMarket | PlainMessage<SpotMarket> | undefined): boolean {
    return proto3.util.equals(SpotMarket, a, b);
  }
}

/**
 * A subaccount's deposit for a given base currency
 *
 * @generated from message injective.exchange.v1beta1.Deposit
 */
export class Deposit extends Message<Deposit> {
  /**
   * @generated from field: string available_balance = 1;
   */
  availableBalance = "";

  /**
   * @generated from field: string total_balance = 2;
   */
  totalBalance = "";

  constructor(data?: PartialMessage<Deposit>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.Deposit";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "available_balance", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "total_balance", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Deposit {
    return new Deposit().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Deposit {
    return new Deposit().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Deposit {
    return new Deposit().fromJsonString(jsonString, options);
  }

  static equals(a: Deposit | PlainMessage<Deposit> | undefined, b: Deposit | PlainMessage<Deposit> | undefined): boolean {
    return proto3.util.equals(Deposit, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.SubaccountTradeNonce
 */
export class SubaccountTradeNonce extends Message<SubaccountTradeNonce> {
  /**
   * @generated from field: uint32 nonce = 1;
   */
  nonce = 0;

  constructor(data?: PartialMessage<SubaccountTradeNonce>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.SubaccountTradeNonce";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "nonce", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubaccountTradeNonce {
    return new SubaccountTradeNonce().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubaccountTradeNonce {
    return new SubaccountTradeNonce().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubaccountTradeNonce {
    return new SubaccountTradeNonce().fromJsonString(jsonString, options);
  }

  static equals(a: SubaccountTradeNonce | PlainMessage<SubaccountTradeNonce> | undefined, b: SubaccountTradeNonce | PlainMessage<SubaccountTradeNonce> | undefined): boolean {
    return proto3.util.equals(SubaccountTradeNonce, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.OrderInfo
 */
export class OrderInfo extends Message<OrderInfo> {
  /**
   * bytes32 subaccount ID that created the order
   *
   * @generated from field: string subaccount_id = 1;
   */
  subaccountId = "";

  /**
   * address fee_recipient address that will receive fees for the order
   *
   * @generated from field: string fee_recipient = 2;
   */
  feeRecipient = "";

  /**
   * price of the order
   *
   * @generated from field: string price = 3;
   */
  price = "";

  /**
   * quantity of the order
   *
   * @generated from field: string quantity = 4;
   */
  quantity = "";

  /**
   * @generated from field: string cid = 5;
   */
  cid = "";

  constructor(data?: PartialMessage<OrderInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.OrderInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "fee_recipient", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "quantity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "cid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OrderInfo {
    return new OrderInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OrderInfo {
    return new OrderInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OrderInfo {
    return new OrderInfo().fromJsonString(jsonString, options);
  }

  static equals(a: OrderInfo | PlainMessage<OrderInfo> | undefined, b: OrderInfo | PlainMessage<OrderInfo> | undefined): boolean {
    return proto3.util.equals(OrderInfo, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.SpotOrder
 */
export class SpotOrder extends Message<SpotOrder> {
  /**
   * market_id represents the unique ID of the market
   *
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  /**
   * order_info contains the information of the order
   *
   * @generated from field: injective.exchange.v1beta1.OrderInfo order_info = 2;
   */
  orderInfo?: OrderInfo;

  /**
   * order types
   *
   * @generated from field: injective.exchange.v1beta1.OrderType order_type = 3;
   */
  orderType = OrderType.UNSPECIFIED;

  /**
   * trigger_price is the trigger price used by stop/take orders
   *
   * @generated from field: string trigger_price = 4;
   */
  triggerPrice = "";

  constructor(data?: PartialMessage<SpotOrder>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.SpotOrder";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "order_info", kind: "message", T: OrderInfo },
    { no: 3, name: "order_type", kind: "enum", T: proto3.getEnumType(OrderType) },
    { no: 4, name: "trigger_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SpotOrder {
    return new SpotOrder().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SpotOrder {
    return new SpotOrder().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SpotOrder {
    return new SpotOrder().fromJsonString(jsonString, options);
  }

  static equals(a: SpotOrder | PlainMessage<SpotOrder> | undefined, b: SpotOrder | PlainMessage<SpotOrder> | undefined): boolean {
    return proto3.util.equals(SpotOrder, a, b);
  }
}

/**
 * A valid Spot limit order with Metadata.
 *
 * @generated from message injective.exchange.v1beta1.SpotLimitOrder
 */
export class SpotLimitOrder extends Message<SpotLimitOrder> {
  /**
   * order_info contains the information of the order
   *
   * @generated from field: injective.exchange.v1beta1.OrderInfo order_info = 1;
   */
  orderInfo?: OrderInfo;

  /**
   * order types
   *
   * @generated from field: injective.exchange.v1beta1.OrderType order_type = 2;
   */
  orderType = OrderType.UNSPECIFIED;

  /**
   * the amount of the quantity remaining fillable
   *
   * @generated from field: string fillable = 3;
   */
  fillable = "";

  /**
   * trigger_price is the trigger price used by stop/take orders
   *
   * @generated from field: string trigger_price = 4;
   */
  triggerPrice = "";

  /**
   * @generated from field: bytes order_hash = 5;
   */
  orderHash = new Uint8Array(0);

  constructor(data?: PartialMessage<SpotLimitOrder>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.SpotLimitOrder";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "order_info", kind: "message", T: OrderInfo },
    { no: 2, name: "order_type", kind: "enum", T: proto3.getEnumType(OrderType) },
    { no: 3, name: "fillable", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "trigger_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "order_hash", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SpotLimitOrder {
    return new SpotLimitOrder().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SpotLimitOrder {
    return new SpotLimitOrder().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SpotLimitOrder {
    return new SpotLimitOrder().fromJsonString(jsonString, options);
  }

  static equals(a: SpotLimitOrder | PlainMessage<SpotLimitOrder> | undefined, b: SpotLimitOrder | PlainMessage<SpotLimitOrder> | undefined): boolean {
    return proto3.util.equals(SpotLimitOrder, a, b);
  }
}

/**
 * A valid Spot market order with Metadata.
 *
 * @generated from message injective.exchange.v1beta1.SpotMarketOrder
 */
export class SpotMarketOrder extends Message<SpotMarketOrder> {
  /**
   * order_info contains the information of the order
   *
   * @generated from field: injective.exchange.v1beta1.OrderInfo order_info = 1;
   */
  orderInfo?: OrderInfo;

  /**
   * @generated from field: string balance_hold = 2;
   */
  balanceHold = "";

  /**
   * @generated from field: bytes order_hash = 3;
   */
  orderHash = new Uint8Array(0);

  /**
   * order types
   *
   * @generated from field: injective.exchange.v1beta1.OrderType order_type = 4;
   */
  orderType = OrderType.UNSPECIFIED;

  /**
   * trigger_price is the trigger price used by stop/take orders
   *
   * @generated from field: string trigger_price = 5;
   */
  triggerPrice = "";

  constructor(data?: PartialMessage<SpotMarketOrder>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.SpotMarketOrder";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "order_info", kind: "message", T: OrderInfo },
    { no: 2, name: "balance_hold", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "order_hash", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 4, name: "order_type", kind: "enum", T: proto3.getEnumType(OrderType) },
    { no: 5, name: "trigger_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SpotMarketOrder {
    return new SpotMarketOrder().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SpotMarketOrder {
    return new SpotMarketOrder().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SpotMarketOrder {
    return new SpotMarketOrder().fromJsonString(jsonString, options);
  }

  static equals(a: SpotMarketOrder | PlainMessage<SpotMarketOrder> | undefined, b: SpotMarketOrder | PlainMessage<SpotMarketOrder> | undefined): boolean {
    return proto3.util.equals(SpotMarketOrder, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.DerivativeOrder
 */
export class DerivativeOrder extends Message<DerivativeOrder> {
  /**
   * market_id represents the unique ID of the market
   *
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  /**
   * order_info contains the information of the order
   *
   * @generated from field: injective.exchange.v1beta1.OrderInfo order_info = 2;
   */
  orderInfo?: OrderInfo;

  /**
   * order types
   *
   * @generated from field: injective.exchange.v1beta1.OrderType order_type = 3;
   */
  orderType = OrderType.UNSPECIFIED;

  /**
   * margin is the margin used by the limit order
   *
   * @generated from field: string margin = 4;
   */
  margin = "";

  /**
   * trigger_price is the trigger price used by stop/take orders
   *
   * @generated from field: string trigger_price = 5;
   */
  triggerPrice = "";

  constructor(data?: PartialMessage<DerivativeOrder>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.DerivativeOrder";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "order_info", kind: "message", T: OrderInfo },
    { no: 3, name: "order_type", kind: "enum", T: proto3.getEnumType(OrderType) },
    { no: 4, name: "margin", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "trigger_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DerivativeOrder {
    return new DerivativeOrder().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DerivativeOrder {
    return new DerivativeOrder().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DerivativeOrder {
    return new DerivativeOrder().fromJsonString(jsonString, options);
  }

  static equals(a: DerivativeOrder | PlainMessage<DerivativeOrder> | undefined, b: DerivativeOrder | PlainMessage<DerivativeOrder> | undefined): boolean {
    return proto3.util.equals(DerivativeOrder, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.SubaccountOrderbookMetadata
 */
export class SubaccountOrderbookMetadata extends Message<SubaccountOrderbookMetadata> {
  /**
   * @generated from field: uint32 vanilla_limit_order_count = 1;
   */
  vanillaLimitOrderCount = 0;

  /**
   * @generated from field: uint32 reduce_only_limit_order_count = 2;
   */
  reduceOnlyLimitOrderCount = 0;

  /**
   * AggregateReduceOnlyQuantity is the aggregate fillable quantity of the
   * subaccount's reduce-only limit orders in the given direction.
   *
   * @generated from field: string aggregate_reduce_only_quantity = 3;
   */
  aggregateReduceOnlyQuantity = "";

  /**
   * AggregateVanillaQuantity is the aggregate fillable quantity of the
   * subaccount's vanilla limit orders in the given direction.
   *
   * @generated from field: string aggregate_vanilla_quantity = 4;
   */
  aggregateVanillaQuantity = "";

  /**
   * @generated from field: uint32 vanilla_conditional_order_count = 5;
   */
  vanillaConditionalOrderCount = 0;

  /**
   * @generated from field: uint32 reduce_only_conditional_order_count = 6;
   */
  reduceOnlyConditionalOrderCount = 0;

  constructor(data?: PartialMessage<SubaccountOrderbookMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.SubaccountOrderbookMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "vanilla_limit_order_count", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "reduce_only_limit_order_count", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 3, name: "aggregate_reduce_only_quantity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "aggregate_vanilla_quantity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "vanilla_conditional_order_count", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 6, name: "reduce_only_conditional_order_count", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubaccountOrderbookMetadata {
    return new SubaccountOrderbookMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubaccountOrderbookMetadata {
    return new SubaccountOrderbookMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubaccountOrderbookMetadata {
    return new SubaccountOrderbookMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: SubaccountOrderbookMetadata | PlainMessage<SubaccountOrderbookMetadata> | undefined, b: SubaccountOrderbookMetadata | PlainMessage<SubaccountOrderbookMetadata> | undefined): boolean {
    return proto3.util.equals(SubaccountOrderbookMetadata, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.SubaccountOrder
 */
export class SubaccountOrder extends Message<SubaccountOrder> {
  /**
   * price of the order
   *
   * @generated from field: string price = 1;
   */
  price = "";

  /**
   * the amount of the quantity remaining fillable
   *
   * @generated from field: string quantity = 2;
   */
  quantity = "";

  /**
   * @generated from field: bool isReduceOnly = 3;
   */
  isReduceOnly = false;

  constructor(data?: PartialMessage<SubaccountOrder>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.SubaccountOrder";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "quantity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "isReduceOnly", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubaccountOrder {
    return new SubaccountOrder().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubaccountOrder {
    return new SubaccountOrder().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubaccountOrder {
    return new SubaccountOrder().fromJsonString(jsonString, options);
  }

  static equals(a: SubaccountOrder | PlainMessage<SubaccountOrder> | undefined, b: SubaccountOrder | PlainMessage<SubaccountOrder> | undefined): boolean {
    return proto3.util.equals(SubaccountOrder, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.SubaccountOrderData
 */
export class SubaccountOrderData extends Message<SubaccountOrderData> {
  /**
   * @generated from field: injective.exchange.v1beta1.SubaccountOrder order = 1;
   */
  order?: SubaccountOrder;

  /**
   * @generated from field: bytes order_hash = 2;
   */
  orderHash = new Uint8Array(0);

  constructor(data?: PartialMessage<SubaccountOrderData>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.SubaccountOrderData";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "order", kind: "message", T: SubaccountOrder },
    { no: 2, name: "order_hash", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubaccountOrderData {
    return new SubaccountOrderData().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubaccountOrderData {
    return new SubaccountOrderData().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubaccountOrderData {
    return new SubaccountOrderData().fromJsonString(jsonString, options);
  }

  static equals(a: SubaccountOrderData | PlainMessage<SubaccountOrderData> | undefined, b: SubaccountOrderData | PlainMessage<SubaccountOrderData> | undefined): boolean {
    return proto3.util.equals(SubaccountOrderData, a, b);
  }
}

/**
 * A valid Derivative limit order with Metadata.
 *
 * @generated from message injective.exchange.v1beta1.DerivativeLimitOrder
 */
export class DerivativeLimitOrder extends Message<DerivativeLimitOrder> {
  /**
   * order_info contains the information of the order
   *
   * @generated from field: injective.exchange.v1beta1.OrderInfo order_info = 1;
   */
  orderInfo?: OrderInfo;

  /**
   * order types
   *
   * @generated from field: injective.exchange.v1beta1.OrderType order_type = 2;
   */
  orderType = OrderType.UNSPECIFIED;

  /**
   * margin is the margin used by the limit order
   *
   * @generated from field: string margin = 3;
   */
  margin = "";

  /**
   * the amount of the quantity remaining fillable
   *
   * @generated from field: string fillable = 4;
   */
  fillable = "";

  /**
   * trigger_price is the trigger price used by stop/take orders
   *
   * @generated from field: string trigger_price = 5;
   */
  triggerPrice = "";

  /**
   * @generated from field: bytes order_hash = 6;
   */
  orderHash = new Uint8Array(0);

  constructor(data?: PartialMessage<DerivativeLimitOrder>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.DerivativeLimitOrder";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "order_info", kind: "message", T: OrderInfo },
    { no: 2, name: "order_type", kind: "enum", T: proto3.getEnumType(OrderType) },
    { no: 3, name: "margin", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "fillable", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "trigger_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "order_hash", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DerivativeLimitOrder {
    return new DerivativeLimitOrder().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DerivativeLimitOrder {
    return new DerivativeLimitOrder().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DerivativeLimitOrder {
    return new DerivativeLimitOrder().fromJsonString(jsonString, options);
  }

  static equals(a: DerivativeLimitOrder | PlainMessage<DerivativeLimitOrder> | undefined, b: DerivativeLimitOrder | PlainMessage<DerivativeLimitOrder> | undefined): boolean {
    return proto3.util.equals(DerivativeLimitOrder, a, b);
  }
}

/**
 * A valid Derivative market order with Metadata.
 *
 * @generated from message injective.exchange.v1beta1.DerivativeMarketOrder
 */
export class DerivativeMarketOrder extends Message<DerivativeMarketOrder> {
  /**
   * order_info contains the information of the order
   *
   * @generated from field: injective.exchange.v1beta1.OrderInfo order_info = 1;
   */
  orderInfo?: OrderInfo;

  /**
   * order types
   *
   * @generated from field: injective.exchange.v1beta1.OrderType order_type = 2;
   */
  orderType = OrderType.UNSPECIFIED;

  /**
   * @generated from field: string margin = 3;
   */
  margin = "";

  /**
   * @generated from field: string margin_hold = 4;
   */
  marginHold = "";

  /**
   * trigger_price is the trigger price used by stop/take orders
   *
   * @generated from field: string trigger_price = 5;
   */
  triggerPrice = "";

  /**
   * @generated from field: bytes order_hash = 6;
   */
  orderHash = new Uint8Array(0);

  constructor(data?: PartialMessage<DerivativeMarketOrder>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.DerivativeMarketOrder";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "order_info", kind: "message", T: OrderInfo },
    { no: 2, name: "order_type", kind: "enum", T: proto3.getEnumType(OrderType) },
    { no: 3, name: "margin", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "margin_hold", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "trigger_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "order_hash", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DerivativeMarketOrder {
    return new DerivativeMarketOrder().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DerivativeMarketOrder {
    return new DerivativeMarketOrder().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DerivativeMarketOrder {
    return new DerivativeMarketOrder().fromJsonString(jsonString, options);
  }

  static equals(a: DerivativeMarketOrder | PlainMessage<DerivativeMarketOrder> | undefined, b: DerivativeMarketOrder | PlainMessage<DerivativeMarketOrder> | undefined): boolean {
    return proto3.util.equals(DerivativeMarketOrder, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.Position
 */
export class Position extends Message<Position> {
  /**
   * @generated from field: bool isLong = 1;
   */
  isLong = false;

  /**
   * @generated from field: string quantity = 2;
   */
  quantity = "";

  /**
   * @generated from field: string entry_price = 3;
   */
  entryPrice = "";

  /**
   * @generated from field: string margin = 4;
   */
  margin = "";

  /**
   * @generated from field: string cumulative_funding_entry = 5;
   */
  cumulativeFundingEntry = "";

  constructor(data?: PartialMessage<Position>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.Position";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "isLong", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "quantity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "entry_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "margin", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "cumulative_funding_entry", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Position {
    return new Position().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Position {
    return new Position().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Position {
    return new Position().fromJsonString(jsonString, options);
  }

  static equals(a: Position | PlainMessage<Position> | undefined, b: Position | PlainMessage<Position> | undefined): boolean {
    return proto3.util.equals(Position, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.MarketOrderIndicator
 */
export class MarketOrderIndicator extends Message<MarketOrderIndicator> {
  /**
   * market_id represents the unique ID of the market
   *
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  /**
   * @generated from field: bool isBuy = 2;
   */
  isBuy = false;

  constructor(data?: PartialMessage<MarketOrderIndicator>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.MarketOrderIndicator";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "isBuy", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MarketOrderIndicator {
    return new MarketOrderIndicator().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MarketOrderIndicator {
    return new MarketOrderIndicator().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MarketOrderIndicator {
    return new MarketOrderIndicator().fromJsonString(jsonString, options);
  }

  static equals(a: MarketOrderIndicator | PlainMessage<MarketOrderIndicator> | undefined, b: MarketOrderIndicator | PlainMessage<MarketOrderIndicator> | undefined): boolean {
    return proto3.util.equals(MarketOrderIndicator, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.TradeLog
 */
export class TradeLog extends Message<TradeLog> {
  /**
   * @generated from field: string quantity = 1;
   */
  quantity = "";

  /**
   * @generated from field: string price = 2;
   */
  price = "";

  /**
   * bytes32 subaccount ID that executed the trade
   *
   * @generated from field: bytes subaccount_id = 3;
   */
  subaccountId = new Uint8Array(0);

  /**
   * @generated from field: string fee = 4;
   */
  fee = "";

  /**
   * @generated from field: bytes order_hash = 5;
   */
  orderHash = new Uint8Array(0);

  /**
   * @generated from field: bytes fee_recipient_address = 6;
   */
  feeRecipientAddress = new Uint8Array(0);

  /**
   * @generated from field: string cid = 7;
   */
  cid = "";

  constructor(data?: PartialMessage<TradeLog>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.TradeLog";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "quantity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "subaccount_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 4, name: "fee", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "order_hash", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 6, name: "fee_recipient_address", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 7, name: "cid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TradeLog {
    return new TradeLog().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TradeLog {
    return new TradeLog().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TradeLog {
    return new TradeLog().fromJsonString(jsonString, options);
  }

  static equals(a: TradeLog | PlainMessage<TradeLog> | undefined, b: TradeLog | PlainMessage<TradeLog> | undefined): boolean {
    return proto3.util.equals(TradeLog, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.PositionDelta
 */
export class PositionDelta extends Message<PositionDelta> {
  /**
   * @generated from field: bool is_long = 1;
   */
  isLong = false;

  /**
   * @generated from field: string execution_quantity = 2;
   */
  executionQuantity = "";

  /**
   * @generated from field: string execution_margin = 3;
   */
  executionMargin = "";

  /**
   * @generated from field: string execution_price = 4;
   */
  executionPrice = "";

  constructor(data?: PartialMessage<PositionDelta>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.PositionDelta";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "is_long", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "execution_quantity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "execution_margin", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "execution_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PositionDelta {
    return new PositionDelta().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PositionDelta {
    return new PositionDelta().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PositionDelta {
    return new PositionDelta().fromJsonString(jsonString, options);
  }

  static equals(a: PositionDelta | PlainMessage<PositionDelta> | undefined, b: PositionDelta | PlainMessage<PositionDelta> | undefined): boolean {
    return proto3.util.equals(PositionDelta, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.DerivativeTradeLog
 */
export class DerivativeTradeLog extends Message<DerivativeTradeLog> {
  /**
   * @generated from field: bytes subaccount_id = 1;
   */
  subaccountId = new Uint8Array(0);

  /**
   * @generated from field: injective.exchange.v1beta1.PositionDelta position_delta = 2;
   */
  positionDelta?: PositionDelta;

  /**
   * @generated from field: string payout = 3;
   */
  payout = "";

  /**
   * @generated from field: string fee = 4;
   */
  fee = "";

  /**
   * @generated from field: bytes order_hash = 5;
   */
  orderHash = new Uint8Array(0);

  /**
   * @generated from field: bytes fee_recipient_address = 6;
   */
  feeRecipientAddress = new Uint8Array(0);

  /**
   * @generated from field: string cid = 7;
   */
  cid = "";

  constructor(data?: PartialMessage<DerivativeTradeLog>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.DerivativeTradeLog";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "subaccount_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "position_delta", kind: "message", T: PositionDelta },
    { no: 3, name: "payout", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "fee", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "order_hash", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 6, name: "fee_recipient_address", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 7, name: "cid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DerivativeTradeLog {
    return new DerivativeTradeLog().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DerivativeTradeLog {
    return new DerivativeTradeLog().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DerivativeTradeLog {
    return new DerivativeTradeLog().fromJsonString(jsonString, options);
  }

  static equals(a: DerivativeTradeLog | PlainMessage<DerivativeTradeLog> | undefined, b: DerivativeTradeLog | PlainMessage<DerivativeTradeLog> | undefined): boolean {
    return proto3.util.equals(DerivativeTradeLog, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.SubaccountPosition
 */
export class SubaccountPosition extends Message<SubaccountPosition> {
  /**
   * @generated from field: injective.exchange.v1beta1.Position position = 1;
   */
  position?: Position;

  /**
   * @generated from field: bytes subaccount_id = 2;
   */
  subaccountId = new Uint8Array(0);

  constructor(data?: PartialMessage<SubaccountPosition>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.SubaccountPosition";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "position", kind: "message", T: Position },
    { no: 2, name: "subaccount_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubaccountPosition {
    return new SubaccountPosition().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubaccountPosition {
    return new SubaccountPosition().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubaccountPosition {
    return new SubaccountPosition().fromJsonString(jsonString, options);
  }

  static equals(a: SubaccountPosition | PlainMessage<SubaccountPosition> | undefined, b: SubaccountPosition | PlainMessage<SubaccountPosition> | undefined): boolean {
    return proto3.util.equals(SubaccountPosition, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.SubaccountDeposit
 */
export class SubaccountDeposit extends Message<SubaccountDeposit> {
  /**
   * @generated from field: bytes subaccount_id = 1;
   */
  subaccountId = new Uint8Array(0);

  /**
   * @generated from field: injective.exchange.v1beta1.Deposit deposit = 2;
   */
  deposit?: Deposit;

  constructor(data?: PartialMessage<SubaccountDeposit>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.SubaccountDeposit";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "subaccount_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "deposit", kind: "message", T: Deposit },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubaccountDeposit {
    return new SubaccountDeposit().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubaccountDeposit {
    return new SubaccountDeposit().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubaccountDeposit {
    return new SubaccountDeposit().fromJsonString(jsonString, options);
  }

  static equals(a: SubaccountDeposit | PlainMessage<SubaccountDeposit> | undefined, b: SubaccountDeposit | PlainMessage<SubaccountDeposit> | undefined): boolean {
    return proto3.util.equals(SubaccountDeposit, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.DepositUpdate
 */
export class DepositUpdate extends Message<DepositUpdate> {
  /**
   * @generated from field: string denom = 1;
   */
  denom = "";

  /**
   * @generated from field: repeated injective.exchange.v1beta1.SubaccountDeposit deposits = 2;
   */
  deposits: SubaccountDeposit[] = [];

  constructor(data?: PartialMessage<DepositUpdate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.DepositUpdate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "deposits", kind: "message", T: SubaccountDeposit, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DepositUpdate {
    return new DepositUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DepositUpdate {
    return new DepositUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DepositUpdate {
    return new DepositUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: DepositUpdate | PlainMessage<DepositUpdate> | undefined, b: DepositUpdate | PlainMessage<DepositUpdate> | undefined): boolean {
    return proto3.util.equals(DepositUpdate, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.PointsMultiplier
 */
export class PointsMultiplier extends Message<PointsMultiplier> {
  /**
   * @generated from field: string maker_points_multiplier = 1;
   */
  makerPointsMultiplier = "";

  /**
   * @generated from field: string taker_points_multiplier = 2;
   */
  takerPointsMultiplier = "";

  constructor(data?: PartialMessage<PointsMultiplier>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.PointsMultiplier";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "maker_points_multiplier", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "taker_points_multiplier", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PointsMultiplier {
    return new PointsMultiplier().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PointsMultiplier {
    return new PointsMultiplier().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PointsMultiplier {
    return new PointsMultiplier().fromJsonString(jsonString, options);
  }

  static equals(a: PointsMultiplier | PlainMessage<PointsMultiplier> | undefined, b: PointsMultiplier | PlainMessage<PointsMultiplier> | undefined): boolean {
    return proto3.util.equals(PointsMultiplier, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.TradingRewardCampaignBoostInfo
 */
export class TradingRewardCampaignBoostInfo extends Message<TradingRewardCampaignBoostInfo> {
  /**
   * @generated from field: repeated string boosted_spot_market_ids = 1;
   */
  boostedSpotMarketIds: string[] = [];

  /**
   * @generated from field: repeated injective.exchange.v1beta1.PointsMultiplier spot_market_multipliers = 2;
   */
  spotMarketMultipliers: PointsMultiplier[] = [];

  /**
   * @generated from field: repeated string boosted_derivative_market_ids = 3;
   */
  boostedDerivativeMarketIds: string[] = [];

  /**
   * @generated from field: repeated injective.exchange.v1beta1.PointsMultiplier derivative_market_multipliers = 4;
   */
  derivativeMarketMultipliers: PointsMultiplier[] = [];

  constructor(data?: PartialMessage<TradingRewardCampaignBoostInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.TradingRewardCampaignBoostInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "boosted_spot_market_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "spot_market_multipliers", kind: "message", T: PointsMultiplier, repeated: true },
    { no: 3, name: "boosted_derivative_market_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "derivative_market_multipliers", kind: "message", T: PointsMultiplier, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TradingRewardCampaignBoostInfo {
    return new TradingRewardCampaignBoostInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TradingRewardCampaignBoostInfo {
    return new TradingRewardCampaignBoostInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TradingRewardCampaignBoostInfo {
    return new TradingRewardCampaignBoostInfo().fromJsonString(jsonString, options);
  }

  static equals(a: TradingRewardCampaignBoostInfo | PlainMessage<TradingRewardCampaignBoostInfo> | undefined, b: TradingRewardCampaignBoostInfo | PlainMessage<TradingRewardCampaignBoostInfo> | undefined): boolean {
    return proto3.util.equals(TradingRewardCampaignBoostInfo, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.CampaignRewardPool
 */
export class CampaignRewardPool extends Message<CampaignRewardPool> {
  /**
   * @generated from field: int64 start_timestamp = 1;
   */
  startTimestamp = protoInt64.zero;

  /**
   * max_campaign_rewards are the maximum reward amounts to be disbursed at the
   * end of the campaign
   *
   * @generated from field: repeated cosmos.base.v1beta1.Coin max_campaign_rewards = 2;
   */
  maxCampaignRewards: Coin[] = [];

  constructor(data?: PartialMessage<CampaignRewardPool>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.CampaignRewardPool";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "start_timestamp", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "max_campaign_rewards", kind: "message", T: Coin, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CampaignRewardPool {
    return new CampaignRewardPool().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CampaignRewardPool {
    return new CampaignRewardPool().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CampaignRewardPool {
    return new CampaignRewardPool().fromJsonString(jsonString, options);
  }

  static equals(a: CampaignRewardPool | PlainMessage<CampaignRewardPool> | undefined, b: CampaignRewardPool | PlainMessage<CampaignRewardPool> | undefined): boolean {
    return proto3.util.equals(CampaignRewardPool, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.TradingRewardCampaignInfo
 */
export class TradingRewardCampaignInfo extends Message<TradingRewardCampaignInfo> {
  /**
   * number of seconds of the duration of each campaign
   *
   * @generated from field: int64 campaign_duration_seconds = 1;
   */
  campaignDurationSeconds = protoInt64.zero;

  /**
   * the trading fee quote denoms which will be counted for the rewards
   *
   * @generated from field: repeated string quote_denoms = 2;
   */
  quoteDenoms: string[] = [];

  /**
   * the optional boost info for markets
   *
   * @generated from field: injective.exchange.v1beta1.TradingRewardCampaignBoostInfo trading_reward_boost_info = 3;
   */
  tradingRewardBoostInfo?: TradingRewardCampaignBoostInfo;

  /**
   * the marketIDs which are disqualified from being rewarded
   *
   * @generated from field: repeated string disqualified_market_ids = 4;
   */
  disqualifiedMarketIds: string[] = [];

  constructor(data?: PartialMessage<TradingRewardCampaignInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.TradingRewardCampaignInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "campaign_duration_seconds", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "quote_denoms", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "trading_reward_boost_info", kind: "message", T: TradingRewardCampaignBoostInfo },
    { no: 4, name: "disqualified_market_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TradingRewardCampaignInfo {
    return new TradingRewardCampaignInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TradingRewardCampaignInfo {
    return new TradingRewardCampaignInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TradingRewardCampaignInfo {
    return new TradingRewardCampaignInfo().fromJsonString(jsonString, options);
  }

  static equals(a: TradingRewardCampaignInfo | PlainMessage<TradingRewardCampaignInfo> | undefined, b: TradingRewardCampaignInfo | PlainMessage<TradingRewardCampaignInfo> | undefined): boolean {
    return proto3.util.equals(TradingRewardCampaignInfo, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.FeeDiscountTierInfo
 */
export class FeeDiscountTierInfo extends Message<FeeDiscountTierInfo> {
  /**
   * @generated from field: string maker_discount_rate = 1;
   */
  makerDiscountRate = "";

  /**
   * @generated from field: string taker_discount_rate = 2;
   */
  takerDiscountRate = "";

  /**
   * @generated from field: string staked_amount = 3;
   */
  stakedAmount = "";

  /**
   * @generated from field: string volume = 4;
   */
  volume = "";

  constructor(data?: PartialMessage<FeeDiscountTierInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.FeeDiscountTierInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "maker_discount_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "taker_discount_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "staked_amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "volume", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FeeDiscountTierInfo {
    return new FeeDiscountTierInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FeeDiscountTierInfo {
    return new FeeDiscountTierInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FeeDiscountTierInfo {
    return new FeeDiscountTierInfo().fromJsonString(jsonString, options);
  }

  static equals(a: FeeDiscountTierInfo | PlainMessage<FeeDiscountTierInfo> | undefined, b: FeeDiscountTierInfo | PlainMessage<FeeDiscountTierInfo> | undefined): boolean {
    return proto3.util.equals(FeeDiscountTierInfo, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.FeeDiscountSchedule
 */
export class FeeDiscountSchedule extends Message<FeeDiscountSchedule> {
  /**
   * @generated from field: uint64 bucket_count = 1;
   */
  bucketCount = protoInt64.zero;

  /**
   * @generated from field: int64 bucket_duration = 2;
   */
  bucketDuration = protoInt64.zero;

  /**
   * the trading fee quote denoms which will be counted for the fee paid
   * contribution
   *
   * @generated from field: repeated string quote_denoms = 3;
   */
  quoteDenoms: string[] = [];

  /**
   * the fee discount tiers
   *
   * @generated from field: repeated injective.exchange.v1beta1.FeeDiscountTierInfo tier_infos = 4;
   */
  tierInfos: FeeDiscountTierInfo[] = [];

  /**
   * the marketIDs which are disqualified from contributing to the fee paid
   * amount
   *
   * @generated from field: repeated string disqualified_market_ids = 5;
   */
  disqualifiedMarketIds: string[] = [];

  constructor(data?: PartialMessage<FeeDiscountSchedule>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.FeeDiscountSchedule";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "bucket_count", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "bucket_duration", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "quote_denoms", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "tier_infos", kind: "message", T: FeeDiscountTierInfo, repeated: true },
    { no: 5, name: "disqualified_market_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FeeDiscountSchedule {
    return new FeeDiscountSchedule().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FeeDiscountSchedule {
    return new FeeDiscountSchedule().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FeeDiscountSchedule {
    return new FeeDiscountSchedule().fromJsonString(jsonString, options);
  }

  static equals(a: FeeDiscountSchedule | PlainMessage<FeeDiscountSchedule> | undefined, b: FeeDiscountSchedule | PlainMessage<FeeDiscountSchedule> | undefined): boolean {
    return proto3.util.equals(FeeDiscountSchedule, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.FeeDiscountTierTTL
 */
export class FeeDiscountTierTTL extends Message<FeeDiscountTierTTL> {
  /**
   * @generated from field: uint64 tier = 1;
   */
  tier = protoInt64.zero;

  /**
   * @generated from field: int64 ttl_timestamp = 2;
   */
  ttlTimestamp = protoInt64.zero;

  constructor(data?: PartialMessage<FeeDiscountTierTTL>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.FeeDiscountTierTTL";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "tier", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "ttl_timestamp", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FeeDiscountTierTTL {
    return new FeeDiscountTierTTL().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FeeDiscountTierTTL {
    return new FeeDiscountTierTTL().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FeeDiscountTierTTL {
    return new FeeDiscountTierTTL().fromJsonString(jsonString, options);
  }

  static equals(a: FeeDiscountTierTTL | PlainMessage<FeeDiscountTierTTL> | undefined, b: FeeDiscountTierTTL | PlainMessage<FeeDiscountTierTTL> | undefined): boolean {
    return proto3.util.equals(FeeDiscountTierTTL, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.VolumeRecord
 */
export class VolumeRecord extends Message<VolumeRecord> {
  /**
   * @generated from field: string maker_volume = 1;
   */
  makerVolume = "";

  /**
   * @generated from field: string taker_volume = 2;
   */
  takerVolume = "";

  constructor(data?: PartialMessage<VolumeRecord>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.VolumeRecord";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "maker_volume", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "taker_volume", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VolumeRecord {
    return new VolumeRecord().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VolumeRecord {
    return new VolumeRecord().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VolumeRecord {
    return new VolumeRecord().fromJsonString(jsonString, options);
  }

  static equals(a: VolumeRecord | PlainMessage<VolumeRecord> | undefined, b: VolumeRecord | PlainMessage<VolumeRecord> | undefined): boolean {
    return proto3.util.equals(VolumeRecord, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.AccountRewards
 */
export class AccountRewards extends Message<AccountRewards> {
  /**
   * @generated from field: string account = 1;
   */
  account = "";

  /**
   * @generated from field: repeated cosmos.base.v1beta1.Coin rewards = 2;
   */
  rewards: Coin[] = [];

  constructor(data?: PartialMessage<AccountRewards>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.AccountRewards";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "account", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "rewards", kind: "message", T: Coin, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AccountRewards {
    return new AccountRewards().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AccountRewards {
    return new AccountRewards().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AccountRewards {
    return new AccountRewards().fromJsonString(jsonString, options);
  }

  static equals(a: AccountRewards | PlainMessage<AccountRewards> | undefined, b: AccountRewards | PlainMessage<AccountRewards> | undefined): boolean {
    return proto3.util.equals(AccountRewards, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.TradeRecords
 */
export class TradeRecords extends Message<TradeRecords> {
  /**
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  /**
   * @generated from field: repeated injective.exchange.v1beta1.TradeRecord latest_trade_records = 2;
   */
  latestTradeRecords: TradeRecord[] = [];

  constructor(data?: PartialMessage<TradeRecords>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.TradeRecords";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "latest_trade_records", kind: "message", T: TradeRecord, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TradeRecords {
    return new TradeRecords().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TradeRecords {
    return new TradeRecords().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TradeRecords {
    return new TradeRecords().fromJsonString(jsonString, options);
  }

  static equals(a: TradeRecords | PlainMessage<TradeRecords> | undefined, b: TradeRecords | PlainMessage<TradeRecords> | undefined): boolean {
    return proto3.util.equals(TradeRecords, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.SubaccountIDs
 */
export class SubaccountIDs extends Message<SubaccountIDs> {
  /**
   * @generated from field: repeated bytes subaccount_ids = 1;
   */
  subaccountIds: Uint8Array[] = [];

  constructor(data?: PartialMessage<SubaccountIDs>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.SubaccountIDs";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "subaccount_ids", kind: "scalar", T: 12 /* ScalarType.BYTES */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubaccountIDs {
    return new SubaccountIDs().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubaccountIDs {
    return new SubaccountIDs().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubaccountIDs {
    return new SubaccountIDs().fromJsonString(jsonString, options);
  }

  static equals(a: SubaccountIDs | PlainMessage<SubaccountIDs> | undefined, b: SubaccountIDs | PlainMessage<SubaccountIDs> | undefined): boolean {
    return proto3.util.equals(SubaccountIDs, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.TradeRecord
 */
export class TradeRecord extends Message<TradeRecord> {
  /**
   * @generated from field: int64 timestamp = 1;
   */
  timestamp = protoInt64.zero;

  /**
   * @generated from field: string price = 2;
   */
  price = "";

  /**
   * @generated from field: string quantity = 3;
   */
  quantity = "";

  constructor(data?: PartialMessage<TradeRecord>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.TradeRecord";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "timestamp", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "quantity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TradeRecord {
    return new TradeRecord().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TradeRecord {
    return new TradeRecord().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TradeRecord {
    return new TradeRecord().fromJsonString(jsonString, options);
  }

  static equals(a: TradeRecord | PlainMessage<TradeRecord> | undefined, b: TradeRecord | PlainMessage<TradeRecord> | undefined): boolean {
    return proto3.util.equals(TradeRecord, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.Level
 */
export class Level extends Message<Level> {
  /**
   * price
   *
   * @generated from field: string p = 1;
   */
  p = "";

  /**
   * quantity
   *
   * @generated from field: string q = 2;
   */
  q = "";

  constructor(data?: PartialMessage<Level>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.Level";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "p", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "q", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Level {
    return new Level().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Level {
    return new Level().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Level {
    return new Level().fromJsonString(jsonString, options);
  }

  static equals(a: Level | PlainMessage<Level> | undefined, b: Level | PlainMessage<Level> | undefined): boolean {
    return proto3.util.equals(Level, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.AggregateSubaccountVolumeRecord
 */
export class AggregateSubaccountVolumeRecord extends Message<AggregateSubaccountVolumeRecord> {
  /**
   * @generated from field: string subaccount_id = 1;
   */
  subaccountId = "";

  /**
   * @generated from field: repeated injective.exchange.v1beta1.MarketVolume market_volumes = 2;
   */
  marketVolumes: MarketVolume[] = [];

  constructor(data?: PartialMessage<AggregateSubaccountVolumeRecord>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.AggregateSubaccountVolumeRecord";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "market_volumes", kind: "message", T: MarketVolume, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AggregateSubaccountVolumeRecord {
    return new AggregateSubaccountVolumeRecord().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AggregateSubaccountVolumeRecord {
    return new AggregateSubaccountVolumeRecord().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AggregateSubaccountVolumeRecord {
    return new AggregateSubaccountVolumeRecord().fromJsonString(jsonString, options);
  }

  static equals(a: AggregateSubaccountVolumeRecord | PlainMessage<AggregateSubaccountVolumeRecord> | undefined, b: AggregateSubaccountVolumeRecord | PlainMessage<AggregateSubaccountVolumeRecord> | undefined): boolean {
    return proto3.util.equals(AggregateSubaccountVolumeRecord, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.AggregateAccountVolumeRecord
 */
export class AggregateAccountVolumeRecord extends Message<AggregateAccountVolumeRecord> {
  /**
   * @generated from field: string account = 1;
   */
  account = "";

  /**
   * @generated from field: repeated injective.exchange.v1beta1.MarketVolume market_volumes = 2;
   */
  marketVolumes: MarketVolume[] = [];

  constructor(data?: PartialMessage<AggregateAccountVolumeRecord>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.AggregateAccountVolumeRecord";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "account", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "market_volumes", kind: "message", T: MarketVolume, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AggregateAccountVolumeRecord {
    return new AggregateAccountVolumeRecord().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AggregateAccountVolumeRecord {
    return new AggregateAccountVolumeRecord().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AggregateAccountVolumeRecord {
    return new AggregateAccountVolumeRecord().fromJsonString(jsonString, options);
  }

  static equals(a: AggregateAccountVolumeRecord | PlainMessage<AggregateAccountVolumeRecord> | undefined, b: AggregateAccountVolumeRecord | PlainMessage<AggregateAccountVolumeRecord> | undefined): boolean {
    return proto3.util.equals(AggregateAccountVolumeRecord, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.MarketVolume
 */
export class MarketVolume extends Message<MarketVolume> {
  /**
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  /**
   * @generated from field: injective.exchange.v1beta1.VolumeRecord volume = 2;
   */
  volume?: VolumeRecord;

  constructor(data?: PartialMessage<MarketVolume>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.MarketVolume";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "volume", kind: "message", T: VolumeRecord },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MarketVolume {
    return new MarketVolume().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MarketVolume {
    return new MarketVolume().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MarketVolume {
    return new MarketVolume().fromJsonString(jsonString, options);
  }

  static equals(a: MarketVolume | PlainMessage<MarketVolume> | undefined, b: MarketVolume | PlainMessage<MarketVolume> | undefined): boolean {
    return proto3.util.equals(MarketVolume, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.DenomDecimals
 */
export class DenomDecimals extends Message<DenomDecimals> {
  /**
   * @generated from field: string denom = 1;
   */
  denom = "";

  /**
   * @generated from field: uint64 decimals = 2;
   */
  decimals = protoInt64.zero;

  constructor(data?: PartialMessage<DenomDecimals>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.DenomDecimals";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "decimals", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DenomDecimals {
    return new DenomDecimals().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DenomDecimals {
    return new DenomDecimals().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DenomDecimals {
    return new DenomDecimals().fromJsonString(jsonString, options);
  }

  static equals(a: DenomDecimals | PlainMessage<DenomDecimals> | undefined, b: DenomDecimals | PlainMessage<DenomDecimals> | undefined): boolean {
    return proto3.util.equals(DenomDecimals, a, b);
  }
}

