// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file injective/exchange/v1beta1/proposal.proto (package injective.exchange.v1beta1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";
import { CampaignRewardPool, DenomDecimals, FeeDiscountSchedule, MarketFeeMultiplier, MarketStatus, TradingRewardCampaignInfo } from "./exchange_pb.js";
import { OracleType } from "../../oracle/v1beta1/oracle_pb.js";
import { CommunityPoolSpendProposal } from "../../../cosmos/distribution/v1beta1/distribution_pb.js";

/**
 * @generated from enum injective.exchange.v1beta1.ExchangeType
 */
export enum ExchangeType {
  /**
   * @generated from enum value: EXCHANGE_UNSPECIFIED = 0;
   */
  EXCHANGE_UNSPECIFIED = 0,

  /**
   * @generated from enum value: SPOT = 1;
   */
  SPOT = 1,

  /**
   * @generated from enum value: DERIVATIVES = 2;
   */
  DERIVATIVES = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(ExchangeType)
proto3.util.setEnumType(ExchangeType, "injective.exchange.v1beta1.ExchangeType", [
  { no: 0, name: "EXCHANGE_UNSPECIFIED" },
  { no: 1, name: "SPOT" },
  { no: 2, name: "DERIVATIVES" },
]);

/**
 * @generated from message injective.exchange.v1beta1.SpotMarketParamUpdateProposal
 */
export class SpotMarketParamUpdateProposal extends Message<SpotMarketParamUpdateProposal> {
  /**
   * @generated from field: string title = 1;
   */
  title = "";

  /**
   * @generated from field: string description = 2;
   */
  description = "";

  /**
   * @generated from field: string market_id = 3;
   */
  marketId = "";

  /**
   * maker_fee_rate defines the trade fee rate for makers on the spot market
   *
   * @generated from field: string maker_fee_rate = 4;
   */
  makerFeeRate = "";

  /**
   * taker_fee_rate defines the trade fee rate for takers on the spot market
   *
   * @generated from field: string taker_fee_rate = 5;
   */
  takerFeeRate = "";

  /**
   * relayer_fee_share_rate defines the relayer fee share rate for the spot
   * market
   *
   * @generated from field: string relayer_fee_share_rate = 6;
   */
  relayerFeeShareRate = "";

  /**
   * min_price_tick_size defines the minimum tick size of the order's price and
   * margin
   *
   * @generated from field: string min_price_tick_size = 7;
   */
  minPriceTickSize = "";

  /**
   * min_quantity_tick_size defines the minimum tick size of the order's
   * quantity
   *
   * @generated from field: string min_quantity_tick_size = 8;
   */
  minQuantityTickSize = "";

  /**
   * @generated from field: injective.exchange.v1beta1.MarketStatus status = 9;
   */
  status = MarketStatus.Unspecified;

  constructor(data?: PartialMessage<SpotMarketParamUpdateProposal>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.SpotMarketParamUpdateProposal";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "title", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "maker_fee_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "taker_fee_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "relayer_fee_share_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "min_price_tick_size", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "min_quantity_tick_size", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "status", kind: "enum", T: proto3.getEnumType(MarketStatus) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SpotMarketParamUpdateProposal {
    return new SpotMarketParamUpdateProposal().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SpotMarketParamUpdateProposal {
    return new SpotMarketParamUpdateProposal().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SpotMarketParamUpdateProposal {
    return new SpotMarketParamUpdateProposal().fromJsonString(jsonString, options);
  }

  static equals(a: SpotMarketParamUpdateProposal | PlainMessage<SpotMarketParamUpdateProposal> | undefined, b: SpotMarketParamUpdateProposal | PlainMessage<SpotMarketParamUpdateProposal> | undefined): boolean {
    return proto3.util.equals(SpotMarketParamUpdateProposal, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.ExchangeEnableProposal
 */
export class ExchangeEnableProposal extends Message<ExchangeEnableProposal> {
  /**
   * @generated from field: string title = 1;
   */
  title = "";

  /**
   * @generated from field: string description = 2;
   */
  description = "";

  /**
   * @generated from field: injective.exchange.v1beta1.ExchangeType exchangeType = 3;
   */
  exchangeType = ExchangeType.EXCHANGE_UNSPECIFIED;

  constructor(data?: PartialMessage<ExchangeEnableProposal>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.ExchangeEnableProposal";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "title", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "exchangeType", kind: "enum", T: proto3.getEnumType(ExchangeType) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExchangeEnableProposal {
    return new ExchangeEnableProposal().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExchangeEnableProposal {
    return new ExchangeEnableProposal().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExchangeEnableProposal {
    return new ExchangeEnableProposal().fromJsonString(jsonString, options);
  }

  static equals(a: ExchangeEnableProposal | PlainMessage<ExchangeEnableProposal> | undefined, b: ExchangeEnableProposal | PlainMessage<ExchangeEnableProposal> | undefined): boolean {
    return proto3.util.equals(ExchangeEnableProposal, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.BatchExchangeModificationProposal
 */
export class BatchExchangeModificationProposal extends Message<BatchExchangeModificationProposal> {
  /**
   * @generated from field: string title = 1;
   */
  title = "";

  /**
   * @generated from field: string description = 2;
   */
  description = "";

  /**
   * @generated from field: repeated injective.exchange.v1beta1.SpotMarketParamUpdateProposal spot_market_param_update_proposals = 3;
   */
  spotMarketParamUpdateProposals: SpotMarketParamUpdateProposal[] = [];

  /**
   * @generated from field: repeated injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal derivative_market_param_update_proposals = 4;
   */
  derivativeMarketParamUpdateProposals: DerivativeMarketParamUpdateProposal[] = [];

  /**
   * @generated from field: repeated injective.exchange.v1beta1.SpotMarketLaunchProposal spot_market_launch_proposals = 5;
   */
  spotMarketLaunchProposals: SpotMarketLaunchProposal[] = [];

  /**
   * @generated from field: repeated injective.exchange.v1beta1.PerpetualMarketLaunchProposal perpetual_market_launch_proposals = 6;
   */
  perpetualMarketLaunchProposals: PerpetualMarketLaunchProposal[] = [];

  /**
   * @generated from field: repeated injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal expiry_futures_market_launch_proposals = 7;
   */
  expiryFuturesMarketLaunchProposals: ExpiryFuturesMarketLaunchProposal[] = [];

  /**
   * @generated from field: injective.exchange.v1beta1.TradingRewardCampaignUpdateProposal trading_reward_campaign_update_proposal = 8;
   */
  tradingRewardCampaignUpdateProposal?: TradingRewardCampaignUpdateProposal;

  /**
   * @generated from field: repeated injective.exchange.v1beta1.BinaryOptionsMarketLaunchProposal binary_options_market_launch_proposals = 9;
   */
  binaryOptionsMarketLaunchProposals: BinaryOptionsMarketLaunchProposal[] = [];

  /**
   * @generated from field: repeated injective.exchange.v1beta1.BinaryOptionsMarketParamUpdateProposal binary_options_param_update_proposals = 10;
   */
  binaryOptionsParamUpdateProposals: BinaryOptionsMarketParamUpdateProposal[] = [];

  /**
   * @generated from field: injective.exchange.v1beta1.UpdateDenomDecimalsProposal denom_decimals_update_proposal = 11;
   */
  denomDecimalsUpdateProposal?: UpdateDenomDecimalsProposal;

  /**
   * @generated from field: injective.exchange.v1beta1.FeeDiscountProposal fee_discount_proposal = 12;
   */
  feeDiscountProposal?: FeeDiscountProposal;

  /**
   * @generated from field: repeated injective.exchange.v1beta1.MarketForcedSettlementProposal market_forced_settlement_proposals = 13;
   */
  marketForcedSettlementProposals: MarketForcedSettlementProposal[] = [];

  constructor(data?: PartialMessage<BatchExchangeModificationProposal>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.BatchExchangeModificationProposal";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "title", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "spot_market_param_update_proposals", kind: "message", T: SpotMarketParamUpdateProposal, repeated: true },
    { no: 4, name: "derivative_market_param_update_proposals", kind: "message", T: DerivativeMarketParamUpdateProposal, repeated: true },
    { no: 5, name: "spot_market_launch_proposals", kind: "message", T: SpotMarketLaunchProposal, repeated: true },
    { no: 6, name: "perpetual_market_launch_proposals", kind: "message", T: PerpetualMarketLaunchProposal, repeated: true },
    { no: 7, name: "expiry_futures_market_launch_proposals", kind: "message", T: ExpiryFuturesMarketLaunchProposal, repeated: true },
    { no: 8, name: "trading_reward_campaign_update_proposal", kind: "message", T: TradingRewardCampaignUpdateProposal },
    { no: 9, name: "binary_options_market_launch_proposals", kind: "message", T: BinaryOptionsMarketLaunchProposal, repeated: true },
    { no: 10, name: "binary_options_param_update_proposals", kind: "message", T: BinaryOptionsMarketParamUpdateProposal, repeated: true },
    { no: 11, name: "denom_decimals_update_proposal", kind: "message", T: UpdateDenomDecimalsProposal },
    { no: 12, name: "fee_discount_proposal", kind: "message", T: FeeDiscountProposal },
    { no: 13, name: "market_forced_settlement_proposals", kind: "message", T: MarketForcedSettlementProposal, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BatchExchangeModificationProposal {
    return new BatchExchangeModificationProposal().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BatchExchangeModificationProposal {
    return new BatchExchangeModificationProposal().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BatchExchangeModificationProposal {
    return new BatchExchangeModificationProposal().fromJsonString(jsonString, options);
  }

  static equals(a: BatchExchangeModificationProposal | PlainMessage<BatchExchangeModificationProposal> | undefined, b: BatchExchangeModificationProposal | PlainMessage<BatchExchangeModificationProposal> | undefined): boolean {
    return proto3.util.equals(BatchExchangeModificationProposal, a, b);
  }
}

/**
 * SpotMarketLaunchProposal defines a SDK message for proposing a new spot
 * market through governance
 *
 * @generated from message injective.exchange.v1beta1.SpotMarketLaunchProposal
 */
export class SpotMarketLaunchProposal extends Message<SpotMarketLaunchProposal> {
  /**
   * @generated from field: string title = 1;
   */
  title = "";

  /**
   * @generated from field: string description = 2;
   */
  description = "";

  /**
   * Ticker for the spot market.
   *
   * @generated from field: string ticker = 3;
   */
  ticker = "";

  /**
   * type of coin to use as the base currency
   *
   * @generated from field: string base_denom = 4;
   */
  baseDenom = "";

  /**
   * type of coin to use as the quote currency
   *
   * @generated from field: string quote_denom = 5;
   */
  quoteDenom = "";

  /**
   * min_price_tick_size defines the minimum tick size of the order's price
   *
   * @generated from field: string min_price_tick_size = 6;
   */
  minPriceTickSize = "";

  /**
   * min_quantity_tick_size defines the minimum tick size of the order's
   * quantity
   *
   * @generated from field: string min_quantity_tick_size = 7;
   */
  minQuantityTickSize = "";

  /**
   * maker_fee_rate defines the fee percentage makers pay when trading
   *
   * @generated from field: string maker_fee_rate = 8;
   */
  makerFeeRate = "";

  /**
   * taker_fee_rate defines the fee percentage takers pay when trading
   *
   * @generated from field: string taker_fee_rate = 9;
   */
  takerFeeRate = "";

  constructor(data?: PartialMessage<SpotMarketLaunchProposal>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.SpotMarketLaunchProposal";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "title", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "ticker", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "base_denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "quote_denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "min_price_tick_size", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "min_quantity_tick_size", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "maker_fee_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "taker_fee_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SpotMarketLaunchProposal {
    return new SpotMarketLaunchProposal().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SpotMarketLaunchProposal {
    return new SpotMarketLaunchProposal().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SpotMarketLaunchProposal {
    return new SpotMarketLaunchProposal().fromJsonString(jsonString, options);
  }

  static equals(a: SpotMarketLaunchProposal | PlainMessage<SpotMarketLaunchProposal> | undefined, b: SpotMarketLaunchProposal | PlainMessage<SpotMarketLaunchProposal> | undefined): boolean {
    return proto3.util.equals(SpotMarketLaunchProposal, a, b);
  }
}

/**
 * PerpetualMarketLaunchProposal defines a SDK message for proposing a new
 * perpetual futures market through governance
 *
 * @generated from message injective.exchange.v1beta1.PerpetualMarketLaunchProposal
 */
export class PerpetualMarketLaunchProposal extends Message<PerpetualMarketLaunchProposal> {
  /**
   * @generated from field: string title = 1;
   */
  title = "";

  /**
   * @generated from field: string description = 2;
   */
  description = "";

  /**
   * Ticker for the derivative market.
   *
   * @generated from field: string ticker = 3;
   */
  ticker = "";

  /**
   * type of coin to use as the base currency
   *
   * @generated from field: string quote_denom = 4;
   */
  quoteDenom = "";

  /**
   * Oracle base currency
   *
   * @generated from field: string oracle_base = 5;
   */
  oracleBase = "";

  /**
   * Oracle quote currency
   *
   * @generated from field: string oracle_quote = 6;
   */
  oracleQuote = "";

  /**
   * Scale factor for oracle prices.
   *
   * @generated from field: uint32 oracle_scale_factor = 7;
   */
  oracleScaleFactor = 0;

  /**
   * Oracle type
   *
   * @generated from field: injective.oracle.v1beta1.OracleType oracle_type = 8;
   */
  oracleType = OracleType.Unspecified;

  /**
   * initial_margin_ratio defines the initial margin ratio for the derivative
   * market
   *
   * @generated from field: string initial_margin_ratio = 9;
   */
  initialMarginRatio = "";

  /**
   * maintenance_margin_ratio defines the maintenance margin ratio for the
   * derivative market
   *
   * @generated from field: string maintenance_margin_ratio = 10;
   */
  maintenanceMarginRatio = "";

  /**
   * maker_fee_rate defines the exchange trade fee for makers for the derivative
   * market
   *
   * @generated from field: string maker_fee_rate = 11;
   */
  makerFeeRate = "";

  /**
   * taker_fee_rate defines the exchange trade fee for takers for the derivative
   * market
   *
   * @generated from field: string taker_fee_rate = 12;
   */
  takerFeeRate = "";

  /**
   * min_price_tick_size defines the minimum tick size of the order's price and
   * margin
   *
   * @generated from field: string min_price_tick_size = 13;
   */
  minPriceTickSize = "";

  /**
   * min_quantity_tick_size defines the minimum tick size of the order's
   * quantity
   *
   * @generated from field: string min_quantity_tick_size = 14;
   */
  minQuantityTickSize = "";

  constructor(data?: PartialMessage<PerpetualMarketLaunchProposal>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.PerpetualMarketLaunchProposal";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "title", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "ticker", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "quote_denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "oracle_base", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "oracle_quote", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "oracle_scale_factor", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 8, name: "oracle_type", kind: "enum", T: proto3.getEnumType(OracleType) },
    { no: 9, name: "initial_margin_ratio", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "maintenance_margin_ratio", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "maker_fee_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 12, name: "taker_fee_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 13, name: "min_price_tick_size", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 14, name: "min_quantity_tick_size", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PerpetualMarketLaunchProposal {
    return new PerpetualMarketLaunchProposal().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PerpetualMarketLaunchProposal {
    return new PerpetualMarketLaunchProposal().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PerpetualMarketLaunchProposal {
    return new PerpetualMarketLaunchProposal().fromJsonString(jsonString, options);
  }

  static equals(a: PerpetualMarketLaunchProposal | PlainMessage<PerpetualMarketLaunchProposal> | undefined, b: PerpetualMarketLaunchProposal | PlainMessage<PerpetualMarketLaunchProposal> | undefined): boolean {
    return proto3.util.equals(PerpetualMarketLaunchProposal, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.BinaryOptionsMarketLaunchProposal
 */
export class BinaryOptionsMarketLaunchProposal extends Message<BinaryOptionsMarketLaunchProposal> {
  /**
   * @generated from field: string title = 1;
   */
  title = "";

  /**
   * @generated from field: string description = 2;
   */
  description = "";

  /**
   * Ticker for the derivative contract.
   *
   * @generated from field: string ticker = 3;
   */
  ticker = "";

  /**
   * Oracle symbol
   *
   * @generated from field: string oracle_symbol = 4;
   */
  oracleSymbol = "";

  /**
   * Oracle Provider
   *
   * @generated from field: string oracle_provider = 5;
   */
  oracleProvider = "";

  /**
   * Oracle type
   *
   * @generated from field: injective.oracle.v1beta1.OracleType oracle_type = 6;
   */
  oracleType = OracleType.Unspecified;

  /**
   * Scale factor for oracle prices.
   *
   * @generated from field: uint32 oracle_scale_factor = 7;
   */
  oracleScaleFactor = 0;

  /**
   * expiration timestamp
   *
   * @generated from field: int64 expiration_timestamp = 8;
   */
  expirationTimestamp = protoInt64.zero;

  /**
   * expiration timestamp
   *
   * @generated from field: int64 settlement_timestamp = 9;
   */
  settlementTimestamp = protoInt64.zero;

  /**
   * admin of the market
   *
   * @generated from field: string admin = 10;
   */
  admin = "";

  /**
   * Address of the quote currency denomination for the binary options contract
   *
   * @generated from field: string quote_denom = 11;
   */
  quoteDenom = "";

  /**
   * maker_fee_rate defines the maker fee rate of a binary options market
   *
   * @generated from field: string maker_fee_rate = 12;
   */
  makerFeeRate = "";

  /**
   * taker_fee_rate defines the taker fee rate of a derivative market
   *
   * @generated from field: string taker_fee_rate = 13;
   */
  takerFeeRate = "";

  /**
   * min_price_tick_size defines the minimum tick size that the price and margin
   * required for orders in the market
   *
   * @generated from field: string min_price_tick_size = 14;
   */
  minPriceTickSize = "";

  /**
   * min_quantity_tick_size defines the minimum tick size of the quantity
   * required for orders in the market
   *
   * @generated from field: string min_quantity_tick_size = 15;
   */
  minQuantityTickSize = "";

  constructor(data?: PartialMessage<BinaryOptionsMarketLaunchProposal>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.BinaryOptionsMarketLaunchProposal";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "title", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "ticker", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "oracle_symbol", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "oracle_provider", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "oracle_type", kind: "enum", T: proto3.getEnumType(OracleType) },
    { no: 7, name: "oracle_scale_factor", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 8, name: "expiration_timestamp", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 9, name: "settlement_timestamp", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 10, name: "admin", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "quote_denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 12, name: "maker_fee_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 13, name: "taker_fee_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 14, name: "min_price_tick_size", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 15, name: "min_quantity_tick_size", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BinaryOptionsMarketLaunchProposal {
    return new BinaryOptionsMarketLaunchProposal().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BinaryOptionsMarketLaunchProposal {
    return new BinaryOptionsMarketLaunchProposal().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BinaryOptionsMarketLaunchProposal {
    return new BinaryOptionsMarketLaunchProposal().fromJsonString(jsonString, options);
  }

  static equals(a: BinaryOptionsMarketLaunchProposal | PlainMessage<BinaryOptionsMarketLaunchProposal> | undefined, b: BinaryOptionsMarketLaunchProposal | PlainMessage<BinaryOptionsMarketLaunchProposal> | undefined): boolean {
    return proto3.util.equals(BinaryOptionsMarketLaunchProposal, a, b);
  }
}

/**
 * ExpiryFuturesMarketLaunchProposal defines a SDK message for proposing a new
 * expiry futures market through governance
 *
 * @generated from message injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal
 */
export class ExpiryFuturesMarketLaunchProposal extends Message<ExpiryFuturesMarketLaunchProposal> {
  /**
   * @generated from field: string title = 1;
   */
  title = "";

  /**
   * @generated from field: string description = 2;
   */
  description = "";

  /**
   * Ticker for the derivative market.
   *
   * @generated from field: string ticker = 3;
   */
  ticker = "";

  /**
   * type of coin to use as the quote currency
   *
   * @generated from field: string quote_denom = 4;
   */
  quoteDenom = "";

  /**
   * Oracle base currency
   *
   * @generated from field: string oracle_base = 5;
   */
  oracleBase = "";

  /**
   * Oracle quote currency
   *
   * @generated from field: string oracle_quote = 6;
   */
  oracleQuote = "";

  /**
   * Scale factor for oracle prices.
   *
   * @generated from field: uint32 oracle_scale_factor = 7;
   */
  oracleScaleFactor = 0;

  /**
   * Oracle type
   *
   * @generated from field: injective.oracle.v1beta1.OracleType oracle_type = 8;
   */
  oracleType = OracleType.Unspecified;

  /**
   * Expiration time of the market
   *
   * @generated from field: int64 expiry = 9;
   */
  expiry = protoInt64.zero;

  /**
   * initial_margin_ratio defines the initial margin ratio for the derivative
   * market
   *
   * @generated from field: string initial_margin_ratio = 10;
   */
  initialMarginRatio = "";

  /**
   * maintenance_margin_ratio defines the maintenance margin ratio for the
   * derivative market
   *
   * @generated from field: string maintenance_margin_ratio = 11;
   */
  maintenanceMarginRatio = "";

  /**
   * maker_fee_rate defines the exchange trade fee for makers for the derivative
   * market
   *
   * @generated from field: string maker_fee_rate = 12;
   */
  makerFeeRate = "";

  /**
   * taker_fee_rate defines the exchange trade fee for takers for the derivative
   * market
   *
   * @generated from field: string taker_fee_rate = 13;
   */
  takerFeeRate = "";

  /**
   * min_price_tick_size defines the minimum tick size of the order's price and
   * margin
   *
   * @generated from field: string min_price_tick_size = 14;
   */
  minPriceTickSize = "";

  /**
   * min_quantity_tick_size defines the minimum tick size of the order's
   * quantity
   *
   * @generated from field: string min_quantity_tick_size = 15;
   */
  minQuantityTickSize = "";

  constructor(data?: PartialMessage<ExpiryFuturesMarketLaunchProposal>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "title", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "ticker", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "quote_denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "oracle_base", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "oracle_quote", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "oracle_scale_factor", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 8, name: "oracle_type", kind: "enum", T: proto3.getEnumType(OracleType) },
    { no: 9, name: "expiry", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 10, name: "initial_margin_ratio", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "maintenance_margin_ratio", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 12, name: "maker_fee_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 13, name: "taker_fee_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 14, name: "min_price_tick_size", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 15, name: "min_quantity_tick_size", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExpiryFuturesMarketLaunchProposal {
    return new ExpiryFuturesMarketLaunchProposal().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExpiryFuturesMarketLaunchProposal {
    return new ExpiryFuturesMarketLaunchProposal().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExpiryFuturesMarketLaunchProposal {
    return new ExpiryFuturesMarketLaunchProposal().fromJsonString(jsonString, options);
  }

  static equals(a: ExpiryFuturesMarketLaunchProposal | PlainMessage<ExpiryFuturesMarketLaunchProposal> | undefined, b: ExpiryFuturesMarketLaunchProposal | PlainMessage<ExpiryFuturesMarketLaunchProposal> | undefined): boolean {
    return proto3.util.equals(ExpiryFuturesMarketLaunchProposal, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal
 */
export class DerivativeMarketParamUpdateProposal extends Message<DerivativeMarketParamUpdateProposal> {
  /**
   * @generated from field: string title = 1;
   */
  title = "";

  /**
   * @generated from field: string description = 2;
   */
  description = "";

  /**
   * @generated from field: string market_id = 3;
   */
  marketId = "";

  /**
   * initial_margin_ratio defines the initial margin ratio for the derivative
   * market
   *
   * @generated from field: string initial_margin_ratio = 4;
   */
  initialMarginRatio = "";

  /**
   * maintenance_margin_ratio defines the maintenance margin ratio for the
   * derivative market
   *
   * @generated from field: string maintenance_margin_ratio = 5;
   */
  maintenanceMarginRatio = "";

  /**
   * maker_fee_rate defines the exchange trade fee for makers for the derivative
   * market
   *
   * @generated from field: string maker_fee_rate = 6;
   */
  makerFeeRate = "";

  /**
   * taker_fee_rate defines the exchange trade fee for takers for the derivative
   * market
   *
   * @generated from field: string taker_fee_rate = 7;
   */
  takerFeeRate = "";

  /**
   * relayer_fee_share_rate defines the relayer fee share rate for the
   * derivative market
   *
   * @generated from field: string relayer_fee_share_rate = 8;
   */
  relayerFeeShareRate = "";

  /**
   * min_price_tick_size defines the minimum tick size of the order's price and
   * margin
   *
   * @generated from field: string min_price_tick_size = 9;
   */
  minPriceTickSize = "";

  /**
   * min_quantity_tick_size defines the minimum tick size of the order's
   * quantity
   *
   * @generated from field: string min_quantity_tick_size = 10;
   */
  minQuantityTickSize = "";

  /**
   * hourly_interest_rate defines the hourly interest rate
   *
   * @generated from field: string HourlyInterestRate = 11;
   */
  HourlyInterestRate = "";

  /**
   * hourly_funding_rate_cap defines the maximum absolute value of the hourly
   * funding rate
   *
   * @generated from field: string HourlyFundingRateCap = 12;
   */
  HourlyFundingRateCap = "";

  /**
   * @generated from field: injective.exchange.v1beta1.MarketStatus status = 13;
   */
  status = MarketStatus.Unspecified;

  /**
   * @generated from field: injective.exchange.v1beta1.OracleParams oracle_params = 14;
   */
  oracleParams?: OracleParams;

  constructor(data?: PartialMessage<DerivativeMarketParamUpdateProposal>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "title", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "initial_margin_ratio", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "maintenance_margin_ratio", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "maker_fee_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "taker_fee_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "relayer_fee_share_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "min_price_tick_size", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "min_quantity_tick_size", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "HourlyInterestRate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 12, name: "HourlyFundingRateCap", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 13, name: "status", kind: "enum", T: proto3.getEnumType(MarketStatus) },
    { no: 14, name: "oracle_params", kind: "message", T: OracleParams },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DerivativeMarketParamUpdateProposal {
    return new DerivativeMarketParamUpdateProposal().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DerivativeMarketParamUpdateProposal {
    return new DerivativeMarketParamUpdateProposal().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DerivativeMarketParamUpdateProposal {
    return new DerivativeMarketParamUpdateProposal().fromJsonString(jsonString, options);
  }

  static equals(a: DerivativeMarketParamUpdateProposal | PlainMessage<DerivativeMarketParamUpdateProposal> | undefined, b: DerivativeMarketParamUpdateProposal | PlainMessage<DerivativeMarketParamUpdateProposal> | undefined): boolean {
    return proto3.util.equals(DerivativeMarketParamUpdateProposal, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.MarketForcedSettlementProposal
 */
export class MarketForcedSettlementProposal extends Message<MarketForcedSettlementProposal> {
  /**
   * @generated from field: string title = 1;
   */
  title = "";

  /**
   * @generated from field: string description = 2;
   */
  description = "";

  /**
   * @generated from field: string market_id = 3;
   */
  marketId = "";

  /**
   * @generated from field: string settlement_price = 4;
   */
  settlementPrice = "";

  constructor(data?: PartialMessage<MarketForcedSettlementProposal>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.MarketForcedSettlementProposal";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "title", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "settlement_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MarketForcedSettlementProposal {
    return new MarketForcedSettlementProposal().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MarketForcedSettlementProposal {
    return new MarketForcedSettlementProposal().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MarketForcedSettlementProposal {
    return new MarketForcedSettlementProposal().fromJsonString(jsonString, options);
  }

  static equals(a: MarketForcedSettlementProposal | PlainMessage<MarketForcedSettlementProposal> | undefined, b: MarketForcedSettlementProposal | PlainMessage<MarketForcedSettlementProposal> | undefined): boolean {
    return proto3.util.equals(MarketForcedSettlementProposal, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.UpdateDenomDecimalsProposal
 */
export class UpdateDenomDecimalsProposal extends Message<UpdateDenomDecimalsProposal> {
  /**
   * @generated from field: string title = 1;
   */
  title = "";

  /**
   * @generated from field: string description = 2;
   */
  description = "";

  /**
   * @generated from field: repeated injective.exchange.v1beta1.DenomDecimals denom_decimals = 3;
   */
  denomDecimals: DenomDecimals[] = [];

  constructor(data?: PartialMessage<UpdateDenomDecimalsProposal>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.UpdateDenomDecimalsProposal";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "title", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "denom_decimals", kind: "message", T: DenomDecimals, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateDenomDecimalsProposal {
    return new UpdateDenomDecimalsProposal().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateDenomDecimalsProposal {
    return new UpdateDenomDecimalsProposal().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateDenomDecimalsProposal {
    return new UpdateDenomDecimalsProposal().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateDenomDecimalsProposal | PlainMessage<UpdateDenomDecimalsProposal> | undefined, b: UpdateDenomDecimalsProposal | PlainMessage<UpdateDenomDecimalsProposal> | undefined): boolean {
    return proto3.util.equals(UpdateDenomDecimalsProposal, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.BinaryOptionsMarketParamUpdateProposal
 */
export class BinaryOptionsMarketParamUpdateProposal extends Message<BinaryOptionsMarketParamUpdateProposal> {
  /**
   * @generated from field: string title = 1;
   */
  title = "";

  /**
   * @generated from field: string description = 2;
   */
  description = "";

  /**
   * @generated from field: string market_id = 3;
   */
  marketId = "";

  /**
   * maker_fee_rate defines the exchange trade fee for makers for the derivative
   * market
   *
   * @generated from field: string maker_fee_rate = 4;
   */
  makerFeeRate = "";

  /**
   * taker_fee_rate defines the exchange trade fee for takers for the derivative
   * market
   *
   * @generated from field: string taker_fee_rate = 5;
   */
  takerFeeRate = "";

  /**
   * relayer_fee_share_rate defines the relayer fee share rate for the
   * derivative market
   *
   * @generated from field: string relayer_fee_share_rate = 6;
   */
  relayerFeeShareRate = "";

  /**
   * min_price_tick_size defines the minimum tick size of the order's price and
   * margin
   *
   * @generated from field: string min_price_tick_size = 7;
   */
  minPriceTickSize = "";

  /**
   * min_quantity_tick_size defines the minimum tick size of the order's
   * quantity
   *
   * @generated from field: string min_quantity_tick_size = 8;
   */
  minQuantityTickSize = "";

  /**
   * expiration timestamp
   *
   * @generated from field: int64 expiration_timestamp = 9;
   */
  expirationTimestamp = protoInt64.zero;

  /**
   * expiration timestamp
   *
   * @generated from field: int64 settlement_timestamp = 10;
   */
  settlementTimestamp = protoInt64.zero;

  /**
   * new price at which market will be settled
   *
   * @generated from field: string settlement_price = 11;
   */
  settlementPrice = "";

  /**
   * admin of the market
   *
   * @generated from field: string admin = 12;
   */
  admin = "";

  /**
   * @generated from field: injective.exchange.v1beta1.MarketStatus status = 13;
   */
  status = MarketStatus.Unspecified;

  /**
   * @generated from field: injective.exchange.v1beta1.ProviderOracleParams oracle_params = 14;
   */
  oracleParams?: ProviderOracleParams;

  constructor(data?: PartialMessage<BinaryOptionsMarketParamUpdateProposal>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.BinaryOptionsMarketParamUpdateProposal";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "title", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "maker_fee_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "taker_fee_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "relayer_fee_share_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "min_price_tick_size", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "min_quantity_tick_size", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "expiration_timestamp", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 10, name: "settlement_timestamp", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 11, name: "settlement_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 12, name: "admin", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 13, name: "status", kind: "enum", T: proto3.getEnumType(MarketStatus) },
    { no: 14, name: "oracle_params", kind: "message", T: ProviderOracleParams },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BinaryOptionsMarketParamUpdateProposal {
    return new BinaryOptionsMarketParamUpdateProposal().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BinaryOptionsMarketParamUpdateProposal {
    return new BinaryOptionsMarketParamUpdateProposal().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BinaryOptionsMarketParamUpdateProposal {
    return new BinaryOptionsMarketParamUpdateProposal().fromJsonString(jsonString, options);
  }

  static equals(a: BinaryOptionsMarketParamUpdateProposal | PlainMessage<BinaryOptionsMarketParamUpdateProposal> | undefined, b: BinaryOptionsMarketParamUpdateProposal | PlainMessage<BinaryOptionsMarketParamUpdateProposal> | undefined): boolean {
    return proto3.util.equals(BinaryOptionsMarketParamUpdateProposal, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.ProviderOracleParams
 */
export class ProviderOracleParams extends Message<ProviderOracleParams> {
  /**
   * Oracle base currency
   *
   * @generated from field: string symbol = 1;
   */
  symbol = "";

  /**
   * Oracle quote currency
   *
   * @generated from field: string provider = 2;
   */
  provider = "";

  /**
   * Scale factor for oracle prices.
   *
   * @generated from field: uint32 oracle_scale_factor = 3;
   */
  oracleScaleFactor = 0;

  /**
   * Oracle type
   *
   * @generated from field: injective.oracle.v1beta1.OracleType oracle_type = 4;
   */
  oracleType = OracleType.Unspecified;

  constructor(data?: PartialMessage<ProviderOracleParams>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.ProviderOracleParams";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "symbol", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "provider", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "oracle_scale_factor", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 4, name: "oracle_type", kind: "enum", T: proto3.getEnumType(OracleType) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProviderOracleParams {
    return new ProviderOracleParams().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProviderOracleParams {
    return new ProviderOracleParams().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProviderOracleParams {
    return new ProviderOracleParams().fromJsonString(jsonString, options);
  }

  static equals(a: ProviderOracleParams | PlainMessage<ProviderOracleParams> | undefined, b: ProviderOracleParams | PlainMessage<ProviderOracleParams> | undefined): boolean {
    return proto3.util.equals(ProviderOracleParams, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.OracleParams
 */
export class OracleParams extends Message<OracleParams> {
  /**
   * Oracle base currency
   *
   * @generated from field: string oracle_base = 1;
   */
  oracleBase = "";

  /**
   * Oracle quote currency
   *
   * @generated from field: string oracle_quote = 2;
   */
  oracleQuote = "";

  /**
   * Scale factor for oracle prices.
   *
   * @generated from field: uint32 oracle_scale_factor = 3;
   */
  oracleScaleFactor = 0;

  /**
   * Oracle type
   *
   * @generated from field: injective.oracle.v1beta1.OracleType oracle_type = 4;
   */
  oracleType = OracleType.Unspecified;

  constructor(data?: PartialMessage<OracleParams>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.OracleParams";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "oracle_base", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "oracle_quote", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "oracle_scale_factor", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 4, name: "oracle_type", kind: "enum", T: proto3.getEnumType(OracleType) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OracleParams {
    return new OracleParams().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OracleParams {
    return new OracleParams().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OracleParams {
    return new OracleParams().fromJsonString(jsonString, options);
  }

  static equals(a: OracleParams | PlainMessage<OracleParams> | undefined, b: OracleParams | PlainMessage<OracleParams> | undefined): boolean {
    return proto3.util.equals(OracleParams, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.TradingRewardCampaignLaunchProposal
 */
export class TradingRewardCampaignLaunchProposal extends Message<TradingRewardCampaignLaunchProposal> {
  /**
   * @generated from field: string title = 1;
   */
  title = "";

  /**
   * @generated from field: string description = 2;
   */
  description = "";

  /**
   * @generated from field: injective.exchange.v1beta1.TradingRewardCampaignInfo campaign_info = 3;
   */
  campaignInfo?: TradingRewardCampaignInfo;

  /**
   * @generated from field: repeated injective.exchange.v1beta1.CampaignRewardPool campaign_reward_pools = 4;
   */
  campaignRewardPools: CampaignRewardPool[] = [];

  constructor(data?: PartialMessage<TradingRewardCampaignLaunchProposal>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.TradingRewardCampaignLaunchProposal";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "title", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "campaign_info", kind: "message", T: TradingRewardCampaignInfo },
    { no: 4, name: "campaign_reward_pools", kind: "message", T: CampaignRewardPool, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TradingRewardCampaignLaunchProposal {
    return new TradingRewardCampaignLaunchProposal().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TradingRewardCampaignLaunchProposal {
    return new TradingRewardCampaignLaunchProposal().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TradingRewardCampaignLaunchProposal {
    return new TradingRewardCampaignLaunchProposal().fromJsonString(jsonString, options);
  }

  static equals(a: TradingRewardCampaignLaunchProposal | PlainMessage<TradingRewardCampaignLaunchProposal> | undefined, b: TradingRewardCampaignLaunchProposal | PlainMessage<TradingRewardCampaignLaunchProposal> | undefined): boolean {
    return proto3.util.equals(TradingRewardCampaignLaunchProposal, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.TradingRewardCampaignUpdateProposal
 */
export class TradingRewardCampaignUpdateProposal extends Message<TradingRewardCampaignUpdateProposal> {
  /**
   * @generated from field: string title = 1;
   */
  title = "";

  /**
   * @generated from field: string description = 2;
   */
  description = "";

  /**
   * @generated from field: injective.exchange.v1beta1.TradingRewardCampaignInfo campaign_info = 3;
   */
  campaignInfo?: TradingRewardCampaignInfo;

  /**
   * @generated from field: repeated injective.exchange.v1beta1.CampaignRewardPool campaign_reward_pools_additions = 4;
   */
  campaignRewardPoolsAdditions: CampaignRewardPool[] = [];

  /**
   * @generated from field: repeated injective.exchange.v1beta1.CampaignRewardPool campaign_reward_pools_updates = 5;
   */
  campaignRewardPoolsUpdates: CampaignRewardPool[] = [];

  constructor(data?: PartialMessage<TradingRewardCampaignUpdateProposal>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.TradingRewardCampaignUpdateProposal";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "title", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "campaign_info", kind: "message", T: TradingRewardCampaignInfo },
    { no: 4, name: "campaign_reward_pools_additions", kind: "message", T: CampaignRewardPool, repeated: true },
    { no: 5, name: "campaign_reward_pools_updates", kind: "message", T: CampaignRewardPool, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TradingRewardCampaignUpdateProposal {
    return new TradingRewardCampaignUpdateProposal().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TradingRewardCampaignUpdateProposal {
    return new TradingRewardCampaignUpdateProposal().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TradingRewardCampaignUpdateProposal {
    return new TradingRewardCampaignUpdateProposal().fromJsonString(jsonString, options);
  }

  static equals(a: TradingRewardCampaignUpdateProposal | PlainMessage<TradingRewardCampaignUpdateProposal> | undefined, b: TradingRewardCampaignUpdateProposal | PlainMessage<TradingRewardCampaignUpdateProposal> | undefined): boolean {
    return proto3.util.equals(TradingRewardCampaignUpdateProposal, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.RewardPointUpdate
 */
export class RewardPointUpdate extends Message<RewardPointUpdate> {
  /**
   * @generated from field: string account_address = 1;
   */
  accountAddress = "";

  /**
   * new_points overwrites the current trading reward points for the account
   *
   * @generated from field: string new_points = 12;
   */
  newPoints = "";

  constructor(data?: PartialMessage<RewardPointUpdate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.RewardPointUpdate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "account_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 12, name: "new_points", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RewardPointUpdate {
    return new RewardPointUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RewardPointUpdate {
    return new RewardPointUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RewardPointUpdate {
    return new RewardPointUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: RewardPointUpdate | PlainMessage<RewardPointUpdate> | undefined, b: RewardPointUpdate | PlainMessage<RewardPointUpdate> | undefined): boolean {
    return proto3.util.equals(RewardPointUpdate, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.TradingRewardPendingPointsUpdateProposal
 */
export class TradingRewardPendingPointsUpdateProposal extends Message<TradingRewardPendingPointsUpdateProposal> {
  /**
   * @generated from field: string title = 1;
   */
  title = "";

  /**
   * @generated from field: string description = 2;
   */
  description = "";

  /**
   * @generated from field: int64 pending_pool_timestamp = 3;
   */
  pendingPoolTimestamp = protoInt64.zero;

  /**
   * @generated from field: repeated injective.exchange.v1beta1.RewardPointUpdate reward_point_updates = 4;
   */
  rewardPointUpdates: RewardPointUpdate[] = [];

  constructor(data?: PartialMessage<TradingRewardPendingPointsUpdateProposal>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.TradingRewardPendingPointsUpdateProposal";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "title", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "pending_pool_timestamp", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 4, name: "reward_point_updates", kind: "message", T: RewardPointUpdate, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TradingRewardPendingPointsUpdateProposal {
    return new TradingRewardPendingPointsUpdateProposal().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TradingRewardPendingPointsUpdateProposal {
    return new TradingRewardPendingPointsUpdateProposal().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TradingRewardPendingPointsUpdateProposal {
    return new TradingRewardPendingPointsUpdateProposal().fromJsonString(jsonString, options);
  }

  static equals(a: TradingRewardPendingPointsUpdateProposal | PlainMessage<TradingRewardPendingPointsUpdateProposal> | undefined, b: TradingRewardPendingPointsUpdateProposal | PlainMessage<TradingRewardPendingPointsUpdateProposal> | undefined): boolean {
    return proto3.util.equals(TradingRewardPendingPointsUpdateProposal, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.FeeDiscountProposal
 */
export class FeeDiscountProposal extends Message<FeeDiscountProposal> {
  /**
   * @generated from field: string title = 1;
   */
  title = "";

  /**
   * @generated from field: string description = 2;
   */
  description = "";

  /**
   * @generated from field: injective.exchange.v1beta1.FeeDiscountSchedule schedule = 3;
   */
  schedule?: FeeDiscountSchedule;

  constructor(data?: PartialMessage<FeeDiscountProposal>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.FeeDiscountProposal";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "title", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "schedule", kind: "message", T: FeeDiscountSchedule },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FeeDiscountProposal {
    return new FeeDiscountProposal().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FeeDiscountProposal {
    return new FeeDiscountProposal().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FeeDiscountProposal {
    return new FeeDiscountProposal().fromJsonString(jsonString, options);
  }

  static equals(a: FeeDiscountProposal | PlainMessage<FeeDiscountProposal> | undefined, b: FeeDiscountProposal | PlainMessage<FeeDiscountProposal> | undefined): boolean {
    return proto3.util.equals(FeeDiscountProposal, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.BatchCommunityPoolSpendProposal
 */
export class BatchCommunityPoolSpendProposal extends Message<BatchCommunityPoolSpendProposal> {
  /**
   * @generated from field: string title = 1;
   */
  title = "";

  /**
   * @generated from field: string description = 2;
   */
  description = "";

  /**
   * @generated from field: repeated cosmos.distribution.v1beta1.CommunityPoolSpendProposal proposals = 3;
   */
  proposals: CommunityPoolSpendProposal[] = [];

  constructor(data?: PartialMessage<BatchCommunityPoolSpendProposal>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.BatchCommunityPoolSpendProposal";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "title", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "proposals", kind: "message", T: CommunityPoolSpendProposal, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BatchCommunityPoolSpendProposal {
    return new BatchCommunityPoolSpendProposal().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BatchCommunityPoolSpendProposal {
    return new BatchCommunityPoolSpendProposal().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BatchCommunityPoolSpendProposal {
    return new BatchCommunityPoolSpendProposal().fromJsonString(jsonString, options);
  }

  static equals(a: BatchCommunityPoolSpendProposal | PlainMessage<BatchCommunityPoolSpendProposal> | undefined, b: BatchCommunityPoolSpendProposal | PlainMessage<BatchCommunityPoolSpendProposal> | undefined): boolean {
    return proto3.util.equals(BatchCommunityPoolSpendProposal, a, b);
  }
}

/**
 * AtomicMarketOrderFeeMultiplierScheduleProposal defines a SDK message for
 * proposing new atomic take fee multipliers for specified markets
 *
 * @generated from message injective.exchange.v1beta1.AtomicMarketOrderFeeMultiplierScheduleProposal
 */
export class AtomicMarketOrderFeeMultiplierScheduleProposal extends Message<AtomicMarketOrderFeeMultiplierScheduleProposal> {
  /**
   * @generated from field: string title = 1;
   */
  title = "";

  /**
   * @generated from field: string description = 2;
   */
  description = "";

  /**
   * @generated from field: repeated injective.exchange.v1beta1.MarketFeeMultiplier market_fee_multipliers = 3;
   */
  marketFeeMultipliers: MarketFeeMultiplier[] = [];

  constructor(data?: PartialMessage<AtomicMarketOrderFeeMultiplierScheduleProposal>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.AtomicMarketOrderFeeMultiplierScheduleProposal";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "title", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "market_fee_multipliers", kind: "message", T: MarketFeeMultiplier, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AtomicMarketOrderFeeMultiplierScheduleProposal {
    return new AtomicMarketOrderFeeMultiplierScheduleProposal().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AtomicMarketOrderFeeMultiplierScheduleProposal {
    return new AtomicMarketOrderFeeMultiplierScheduleProposal().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AtomicMarketOrderFeeMultiplierScheduleProposal {
    return new AtomicMarketOrderFeeMultiplierScheduleProposal().fromJsonString(jsonString, options);
  }

  static equals(a: AtomicMarketOrderFeeMultiplierScheduleProposal | PlainMessage<AtomicMarketOrderFeeMultiplierScheduleProposal> | undefined, b: AtomicMarketOrderFeeMultiplierScheduleProposal | PlainMessage<AtomicMarketOrderFeeMultiplierScheduleProposal> | undefined): boolean {
    return proto3.util.equals(AtomicMarketOrderFeeMultiplierScheduleProposal, a, b);
  }
}

