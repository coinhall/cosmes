// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file injective/exchange/v1beta1/genesis.proto (package injective.exchange.v1beta1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";
import { AggregateSubaccountVolumeRecord, BinaryOptionsMarket, CampaignRewardPool, DenomDecimals, Deposit, DerivativeLimitOrder, DerivativeMarket, DerivativeMarketOrder, DerivativeMarketSettlementInfo, ExpiryFuturesMarketInfo, FeeDiscountSchedule, FeeDiscountTierTTL, MarketFeeMultiplier, MarketVolume, Params, PerpetualMarketFunding, PerpetualMarketInfo, Position, SpotLimitOrder, SpotMarket, SubaccountTradeNonce, TradeRecords, TradingRewardCampaignInfo } from "./exchange_pb.js";

/**
 * GenesisState defines the exchange module's genesis state.
 *
 * @generated from message injective.exchange.v1beta1.GenesisState
 */
export class GenesisState extends Message<GenesisState> {
  /**
   * params defines all the parameters of related to exchange.
   *
   * @generated from field: injective.exchange.v1beta1.Params params = 1;
   */
  params?: Params;

  /**
   * spot_markets is an array containing the genesis trade pairs
   *
   * @generated from field: repeated injective.exchange.v1beta1.SpotMarket spot_markets = 2;
   */
  spotMarkets: SpotMarket[] = [];

  /**
   * derivative_markets is an array containing the genesis derivative markets
   *
   * @generated from field: repeated injective.exchange.v1beta1.DerivativeMarket derivative_markets = 3;
   */
  derivativeMarkets: DerivativeMarket[] = [];

  /**
   * spot_orderbook defines the spot exchange limit orderbook active at genesis.
   *
   * @generated from field: repeated injective.exchange.v1beta1.SpotOrderBook spot_orderbook = 4;
   */
  spotOrderbook: SpotOrderBook[] = [];

  /**
   * derivative_orderbook defines the derivative exchange limit orderbook active
   * at genesis.
   *
   * @generated from field: repeated injective.exchange.v1beta1.DerivativeOrderBook derivative_orderbook = 5;
   */
  derivativeOrderbook: DerivativeOrderBook[] = [];

  /**
   * balances defines the exchange users balances active at genesis.
   *
   * @generated from field: repeated injective.exchange.v1beta1.Balance balances = 6;
   */
  balances: Balance[] = [];

  /**
   * positions defines the exchange derivative positions at genesis
   *
   * @generated from field: repeated injective.exchange.v1beta1.DerivativePosition positions = 7;
   */
  positions: DerivativePosition[] = [];

  /**
   * subaccount_trade_nonces defines the subaccount trade nonces for the
   * subaccounts at genesis
   *
   * @generated from field: repeated injective.exchange.v1beta1.SubaccountNonce subaccount_trade_nonces = 8;
   */
  subaccountTradeNonces: SubaccountNonce[] = [];

  /**
   * expiry_futures_market_info defines the market info for the expiry futures
   * markets at genesis
   *
   * @generated from field: repeated injective.exchange.v1beta1.ExpiryFuturesMarketInfoState expiry_futures_market_info_state = 9;
   */
  expiryFuturesMarketInfoState: ExpiryFuturesMarketInfoState[] = [];

  /**
   * perpetual_market_info defines the market info for the perpetual derivative
   * markets at genesis
   *
   * @generated from field: repeated injective.exchange.v1beta1.PerpetualMarketInfo perpetual_market_info = 10;
   */
  perpetualMarketInfo: PerpetualMarketInfo[] = [];

  /**
   * perpetual_market_funding_state defines the funding state for the perpetual
   * derivative markets at genesis
   *
   * @generated from field: repeated injective.exchange.v1beta1.PerpetualMarketFundingState perpetual_market_funding_state = 11;
   */
  perpetualMarketFundingState: PerpetualMarketFundingState[] = [];

  /**
   * derivative_market_settlement_scheduled defines the scheduled markets for
   * settlement at genesis
   *
   * @generated from field: repeated injective.exchange.v1beta1.DerivativeMarketSettlementInfo derivative_market_settlement_scheduled = 12;
   */
  derivativeMarketSettlementScheduled: DerivativeMarketSettlementInfo[] = [];

  /**
   * sets spot markets as enabled
   *
   * @generated from field: bool is_spot_exchange_enabled = 13;
   */
  isSpotExchangeEnabled = false;

  /**
   * sets derivative markets as enabled
   *
   * @generated from field: bool is_derivatives_exchange_enabled = 14;
   */
  isDerivativesExchangeEnabled = false;

  /**
   * the current trading reward campaign info
   *
   * @generated from field: injective.exchange.v1beta1.TradingRewardCampaignInfo trading_reward_campaign_info = 15;
   */
  tradingRewardCampaignInfo?: TradingRewardCampaignInfo;

  /**
   * the current and upcoming trading reward campaign pools
   *
   * @generated from field: repeated injective.exchange.v1beta1.CampaignRewardPool trading_reward_pool_campaign_schedule = 16;
   */
  tradingRewardPoolCampaignSchedule: CampaignRewardPool[] = [];

  /**
   * the current trading reward account points
   *
   * @generated from field: repeated injective.exchange.v1beta1.TradingRewardCampaignAccountPoints trading_reward_campaign_account_points = 17;
   */
  tradingRewardCampaignAccountPoints: TradingRewardCampaignAccountPoints[] = [];

  /**
   * the fee discount schedule
   *
   * @generated from field: injective.exchange.v1beta1.FeeDiscountSchedule fee_discount_schedule = 18;
   */
  feeDiscountSchedule?: FeeDiscountSchedule;

  /**
   * the cached fee discount account tiers with TTL
   *
   * @generated from field: repeated injective.exchange.v1beta1.FeeDiscountAccountTierTTL fee_discount_account_tier_ttl = 19;
   */
  feeDiscountAccountTierTtl: FeeDiscountAccountTierTTL[] = [];

  /**
   * the fee discount paid by accounts in all buckets
   *
   * @generated from field: repeated injective.exchange.v1beta1.FeeDiscountBucketVolumeAccounts fee_discount_bucket_volume_accounts = 20;
   */
  feeDiscountBucketVolumeAccounts: FeeDiscountBucketVolumeAccounts[] = [];

  /**
   * sets the first fee cycle as finished
   *
   * @generated from field: bool is_first_fee_cycle_finished = 21;
   */
  isFirstFeeCycleFinished = false;

  /**
   * the current and upcoming trading reward campaign pending pools
   *
   * @generated from field: repeated injective.exchange.v1beta1.CampaignRewardPool pending_trading_reward_pool_campaign_schedule = 22;
   */
  pendingTradingRewardPoolCampaignSchedule: CampaignRewardPool[] = [];

  /**
   * the pending trading reward account points
   *
   * @generated from field: repeated injective.exchange.v1beta1.TradingRewardCampaignAccountPendingPoints pending_trading_reward_campaign_account_points = 23;
   */
  pendingTradingRewardCampaignAccountPoints: TradingRewardCampaignAccountPendingPoints[] = [];

  /**
   * the addresses opting out of trading rewards
   *
   * @generated from field: repeated string rewards_opt_out_addresses = 24;
   */
  rewardsOptOutAddresses: string[] = [];

  /**
   * @generated from field: repeated injective.exchange.v1beta1.TradeRecords historical_trade_records = 25;
   */
  historicalTradeRecords: TradeRecords[] = [];

  /**
   * binary_options_markets is an array containing the genesis binary options
   * markets
   *
   * @generated from field: repeated injective.exchange.v1beta1.BinaryOptionsMarket binary_options_markets = 26;
   */
  binaryOptionsMarkets: BinaryOptionsMarket[] = [];

  /**
   * binary_options_markets_scheduled_for_settlement contains the marketIDs of
   * binary options markets scheduled for next-block settlement
   *
   * @generated from field: repeated string binary_options_market_ids_scheduled_for_settlement = 27;
   */
  binaryOptionsMarketIdsScheduledForSettlement: string[] = [];

  /**
   * spot_market_ids_scheduled_to_force_close defines the scheduled markets for
   * forced closings at genesis
   *
   * @generated from field: repeated string spot_market_ids_scheduled_to_force_close = 28;
   */
  spotMarketIdsScheduledToForceClose: string[] = [];

  /**
   * denom_decimals defines the denom decimals for the exchange.
   *
   * @generated from field: repeated injective.exchange.v1beta1.DenomDecimals denom_decimals = 29;
   */
  denomDecimals: DenomDecimals[] = [];

  /**
   * conditional_derivative_orderbook contains conditional orderbooks for all
   * markets (both lmit and market conditional orders)
   *
   * @generated from field: repeated injective.exchange.v1beta1.ConditionalDerivativeOrderBook conditional_derivative_orderbooks = 30;
   */
  conditionalDerivativeOrderbooks: ConditionalDerivativeOrderBook[] = [];

  /**
   * market_fee_multipliers contains any non-default atomic order fee
   * multipliers
   *
   * @generated from field: repeated injective.exchange.v1beta1.MarketFeeMultiplier market_fee_multipliers = 31;
   */
  marketFeeMultipliers: MarketFeeMultiplier[] = [];

  /**
   * @generated from field: repeated injective.exchange.v1beta1.OrderbookSequence orderbook_sequences = 32;
   */
  orderbookSequences: OrderbookSequence[] = [];

  /**
   * @generated from field: repeated injective.exchange.v1beta1.AggregateSubaccountVolumeRecord subaccount_volumes = 33;
   */
  subaccountVolumes: AggregateSubaccountVolumeRecord[] = [];

  /**
   * @generated from field: repeated injective.exchange.v1beta1.MarketVolume market_volumes = 34;
   */
  marketVolumes: MarketVolume[] = [];

  constructor(data?: PartialMessage<GenesisState>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.GenesisState";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "params", kind: "message", T: Params },
    { no: 2, name: "spot_markets", kind: "message", T: SpotMarket, repeated: true },
    { no: 3, name: "derivative_markets", kind: "message", T: DerivativeMarket, repeated: true },
    { no: 4, name: "spot_orderbook", kind: "message", T: SpotOrderBook, repeated: true },
    { no: 5, name: "derivative_orderbook", kind: "message", T: DerivativeOrderBook, repeated: true },
    { no: 6, name: "balances", kind: "message", T: Balance, repeated: true },
    { no: 7, name: "positions", kind: "message", T: DerivativePosition, repeated: true },
    { no: 8, name: "subaccount_trade_nonces", kind: "message", T: SubaccountNonce, repeated: true },
    { no: 9, name: "expiry_futures_market_info_state", kind: "message", T: ExpiryFuturesMarketInfoState, repeated: true },
    { no: 10, name: "perpetual_market_info", kind: "message", T: PerpetualMarketInfo, repeated: true },
    { no: 11, name: "perpetual_market_funding_state", kind: "message", T: PerpetualMarketFundingState, repeated: true },
    { no: 12, name: "derivative_market_settlement_scheduled", kind: "message", T: DerivativeMarketSettlementInfo, repeated: true },
    { no: 13, name: "is_spot_exchange_enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 14, name: "is_derivatives_exchange_enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 15, name: "trading_reward_campaign_info", kind: "message", T: TradingRewardCampaignInfo },
    { no: 16, name: "trading_reward_pool_campaign_schedule", kind: "message", T: CampaignRewardPool, repeated: true },
    { no: 17, name: "trading_reward_campaign_account_points", kind: "message", T: TradingRewardCampaignAccountPoints, repeated: true },
    { no: 18, name: "fee_discount_schedule", kind: "message", T: FeeDiscountSchedule },
    { no: 19, name: "fee_discount_account_tier_ttl", kind: "message", T: FeeDiscountAccountTierTTL, repeated: true },
    { no: 20, name: "fee_discount_bucket_volume_accounts", kind: "message", T: FeeDiscountBucketVolumeAccounts, repeated: true },
    { no: 21, name: "is_first_fee_cycle_finished", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 22, name: "pending_trading_reward_pool_campaign_schedule", kind: "message", T: CampaignRewardPool, repeated: true },
    { no: 23, name: "pending_trading_reward_campaign_account_points", kind: "message", T: TradingRewardCampaignAccountPendingPoints, repeated: true },
    { no: 24, name: "rewards_opt_out_addresses", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 25, name: "historical_trade_records", kind: "message", T: TradeRecords, repeated: true },
    { no: 26, name: "binary_options_markets", kind: "message", T: BinaryOptionsMarket, repeated: true },
    { no: 27, name: "binary_options_market_ids_scheduled_for_settlement", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 28, name: "spot_market_ids_scheduled_to_force_close", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 29, name: "denom_decimals", kind: "message", T: DenomDecimals, repeated: true },
    { no: 30, name: "conditional_derivative_orderbooks", kind: "message", T: ConditionalDerivativeOrderBook, repeated: true },
    { no: 31, name: "market_fee_multipliers", kind: "message", T: MarketFeeMultiplier, repeated: true },
    { no: 32, name: "orderbook_sequences", kind: "message", T: OrderbookSequence, repeated: true },
    { no: 33, name: "subaccount_volumes", kind: "message", T: AggregateSubaccountVolumeRecord, repeated: true },
    { no: 34, name: "market_volumes", kind: "message", T: MarketVolume, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GenesisState {
    return new GenesisState().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GenesisState {
    return new GenesisState().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GenesisState {
    return new GenesisState().fromJsonString(jsonString, options);
  }

  static equals(a: GenesisState | PlainMessage<GenesisState> | undefined, b: GenesisState | PlainMessage<GenesisState> | undefined): boolean {
    return proto3.util.equals(GenesisState, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.OrderbookSequence
 */
export class OrderbookSequence extends Message<OrderbookSequence> {
  /**
   * @generated from field: uint64 sequence = 1;
   */
  sequence = protoInt64.zero;

  /**
   * @generated from field: string market_id = 2;
   */
  marketId = "";

  constructor(data?: PartialMessage<OrderbookSequence>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.OrderbookSequence";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sequence", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OrderbookSequence {
    return new OrderbookSequence().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OrderbookSequence {
    return new OrderbookSequence().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OrderbookSequence {
    return new OrderbookSequence().fromJsonString(jsonString, options);
  }

  static equals(a: OrderbookSequence | PlainMessage<OrderbookSequence> | undefined, b: OrderbookSequence | PlainMessage<OrderbookSequence> | undefined): boolean {
    return proto3.util.equals(OrderbookSequence, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.FeeDiscountAccountTierTTL
 */
export class FeeDiscountAccountTierTTL extends Message<FeeDiscountAccountTierTTL> {
  /**
   * @generated from field: string account = 1;
   */
  account = "";

  /**
   * @generated from field: injective.exchange.v1beta1.FeeDiscountTierTTL tier_ttl = 2;
   */
  tierTtl?: FeeDiscountTierTTL;

  constructor(data?: PartialMessage<FeeDiscountAccountTierTTL>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.FeeDiscountAccountTierTTL";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "account", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "tier_ttl", kind: "message", T: FeeDiscountTierTTL },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FeeDiscountAccountTierTTL {
    return new FeeDiscountAccountTierTTL().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FeeDiscountAccountTierTTL {
    return new FeeDiscountAccountTierTTL().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FeeDiscountAccountTierTTL {
    return new FeeDiscountAccountTierTTL().fromJsonString(jsonString, options);
  }

  static equals(a: FeeDiscountAccountTierTTL | PlainMessage<FeeDiscountAccountTierTTL> | undefined, b: FeeDiscountAccountTierTTL | PlainMessage<FeeDiscountAccountTierTTL> | undefined): boolean {
    return proto3.util.equals(FeeDiscountAccountTierTTL, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.FeeDiscountBucketVolumeAccounts
 */
export class FeeDiscountBucketVolumeAccounts extends Message<FeeDiscountBucketVolumeAccounts> {
  /**
   * @generated from field: int64 bucket_start_timestamp = 1;
   */
  bucketStartTimestamp = protoInt64.zero;

  /**
   * @generated from field: repeated injective.exchange.v1beta1.AccountVolume account_volume = 2;
   */
  accountVolume: AccountVolume[] = [];

  constructor(data?: PartialMessage<FeeDiscountBucketVolumeAccounts>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.FeeDiscountBucketVolumeAccounts";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "bucket_start_timestamp", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "account_volume", kind: "message", T: AccountVolume, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FeeDiscountBucketVolumeAccounts {
    return new FeeDiscountBucketVolumeAccounts().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FeeDiscountBucketVolumeAccounts {
    return new FeeDiscountBucketVolumeAccounts().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FeeDiscountBucketVolumeAccounts {
    return new FeeDiscountBucketVolumeAccounts().fromJsonString(jsonString, options);
  }

  static equals(a: FeeDiscountBucketVolumeAccounts | PlainMessage<FeeDiscountBucketVolumeAccounts> | undefined, b: FeeDiscountBucketVolumeAccounts | PlainMessage<FeeDiscountBucketVolumeAccounts> | undefined): boolean {
    return proto3.util.equals(FeeDiscountBucketVolumeAccounts, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.AccountVolume
 */
export class AccountVolume extends Message<AccountVolume> {
  /**
   * @generated from field: string account = 1;
   */
  account = "";

  /**
   * @generated from field: string volume = 2;
   */
  volume = "";

  constructor(data?: PartialMessage<AccountVolume>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.AccountVolume";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "account", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "volume", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AccountVolume {
    return new AccountVolume().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AccountVolume {
    return new AccountVolume().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AccountVolume {
    return new AccountVolume().fromJsonString(jsonString, options);
  }

  static equals(a: AccountVolume | PlainMessage<AccountVolume> | undefined, b: AccountVolume | PlainMessage<AccountVolume> | undefined): boolean {
    return proto3.util.equals(AccountVolume, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.TradingRewardCampaignAccountPoints
 */
export class TradingRewardCampaignAccountPoints extends Message<TradingRewardCampaignAccountPoints> {
  /**
   * @generated from field: string account = 1;
   */
  account = "";

  /**
   * @generated from field: string points = 2;
   */
  points = "";

  constructor(data?: PartialMessage<TradingRewardCampaignAccountPoints>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.TradingRewardCampaignAccountPoints";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "account", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "points", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TradingRewardCampaignAccountPoints {
    return new TradingRewardCampaignAccountPoints().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TradingRewardCampaignAccountPoints {
    return new TradingRewardCampaignAccountPoints().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TradingRewardCampaignAccountPoints {
    return new TradingRewardCampaignAccountPoints().fromJsonString(jsonString, options);
  }

  static equals(a: TradingRewardCampaignAccountPoints | PlainMessage<TradingRewardCampaignAccountPoints> | undefined, b: TradingRewardCampaignAccountPoints | PlainMessage<TradingRewardCampaignAccountPoints> | undefined): boolean {
    return proto3.util.equals(TradingRewardCampaignAccountPoints, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.TradingRewardCampaignAccountPendingPoints
 */
export class TradingRewardCampaignAccountPendingPoints extends Message<TradingRewardCampaignAccountPendingPoints> {
  /**
   * @generated from field: int64 reward_pool_start_timestamp = 1;
   */
  rewardPoolStartTimestamp = protoInt64.zero;

  /**
   * @generated from field: repeated injective.exchange.v1beta1.TradingRewardCampaignAccountPoints account_points = 2;
   */
  accountPoints: TradingRewardCampaignAccountPoints[] = [];

  constructor(data?: PartialMessage<TradingRewardCampaignAccountPendingPoints>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.TradingRewardCampaignAccountPendingPoints";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "reward_pool_start_timestamp", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "account_points", kind: "message", T: TradingRewardCampaignAccountPoints, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TradingRewardCampaignAccountPendingPoints {
    return new TradingRewardCampaignAccountPendingPoints().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TradingRewardCampaignAccountPendingPoints {
    return new TradingRewardCampaignAccountPendingPoints().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TradingRewardCampaignAccountPendingPoints {
    return new TradingRewardCampaignAccountPendingPoints().fromJsonString(jsonString, options);
  }

  static equals(a: TradingRewardCampaignAccountPendingPoints | PlainMessage<TradingRewardCampaignAccountPendingPoints> | undefined, b: TradingRewardCampaignAccountPendingPoints | PlainMessage<TradingRewardCampaignAccountPendingPoints> | undefined): boolean {
    return proto3.util.equals(TradingRewardCampaignAccountPendingPoints, a, b);
  }
}

/**
 * Spot Exchange Limit Orderbook
 *
 * @generated from message injective.exchange.v1beta1.SpotOrderBook
 */
export class SpotOrderBook extends Message<SpotOrderBook> {
  /**
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  /**
   * @generated from field: bool isBuySide = 2;
   */
  isBuySide = false;

  /**
   * @generated from field: repeated injective.exchange.v1beta1.SpotLimitOrder orders = 3;
   */
  orders: SpotLimitOrder[] = [];

  constructor(data?: PartialMessage<SpotOrderBook>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.SpotOrderBook";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "isBuySide", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "orders", kind: "message", T: SpotLimitOrder, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SpotOrderBook {
    return new SpotOrderBook().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SpotOrderBook {
    return new SpotOrderBook().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SpotOrderBook {
    return new SpotOrderBook().fromJsonString(jsonString, options);
  }

  static equals(a: SpotOrderBook | PlainMessage<SpotOrderBook> | undefined, b: SpotOrderBook | PlainMessage<SpotOrderBook> | undefined): boolean {
    return proto3.util.equals(SpotOrderBook, a, b);
  }
}

/**
 * Derivative Exchange Limit Orderbook
 *
 * @generated from message injective.exchange.v1beta1.DerivativeOrderBook
 */
export class DerivativeOrderBook extends Message<DerivativeOrderBook> {
  /**
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  /**
   * @generated from field: bool isBuySide = 2;
   */
  isBuySide = false;

  /**
   * @generated from field: repeated injective.exchange.v1beta1.DerivativeLimitOrder orders = 3;
   */
  orders: DerivativeLimitOrder[] = [];

  constructor(data?: PartialMessage<DerivativeOrderBook>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.DerivativeOrderBook";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "isBuySide", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "orders", kind: "message", T: DerivativeLimitOrder, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DerivativeOrderBook {
    return new DerivativeOrderBook().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DerivativeOrderBook {
    return new DerivativeOrderBook().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DerivativeOrderBook {
    return new DerivativeOrderBook().fromJsonString(jsonString, options);
  }

  static equals(a: DerivativeOrderBook | PlainMessage<DerivativeOrderBook> | undefined, b: DerivativeOrderBook | PlainMessage<DerivativeOrderBook> | undefined): boolean {
    return proto3.util.equals(DerivativeOrderBook, a, b);
  }
}

/**
 * Orderbook containing limit & market conditional orders
 *
 * @generated from message injective.exchange.v1beta1.ConditionalDerivativeOrderBook
 */
export class ConditionalDerivativeOrderBook extends Message<ConditionalDerivativeOrderBook> {
  /**
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  /**
   * @generated from field: repeated injective.exchange.v1beta1.DerivativeLimitOrder limit_buy_orders = 2;
   */
  limitBuyOrders: DerivativeLimitOrder[] = [];

  /**
   * @generated from field: repeated injective.exchange.v1beta1.DerivativeMarketOrder market_buy_orders = 3;
   */
  marketBuyOrders: DerivativeMarketOrder[] = [];

  /**
   * @generated from field: repeated injective.exchange.v1beta1.DerivativeLimitOrder limit_sell_orders = 4;
   */
  limitSellOrders: DerivativeLimitOrder[] = [];

  /**
   * @generated from field: repeated injective.exchange.v1beta1.DerivativeMarketOrder market_sell_orders = 5;
   */
  marketSellOrders: DerivativeMarketOrder[] = [];

  constructor(data?: PartialMessage<ConditionalDerivativeOrderBook>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.ConditionalDerivativeOrderBook";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "limit_buy_orders", kind: "message", T: DerivativeLimitOrder, repeated: true },
    { no: 3, name: "market_buy_orders", kind: "message", T: DerivativeMarketOrder, repeated: true },
    { no: 4, name: "limit_sell_orders", kind: "message", T: DerivativeLimitOrder, repeated: true },
    { no: 5, name: "market_sell_orders", kind: "message", T: DerivativeMarketOrder, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConditionalDerivativeOrderBook {
    return new ConditionalDerivativeOrderBook().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConditionalDerivativeOrderBook {
    return new ConditionalDerivativeOrderBook().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConditionalDerivativeOrderBook {
    return new ConditionalDerivativeOrderBook().fromJsonString(jsonString, options);
  }

  static equals(a: ConditionalDerivativeOrderBook | PlainMessage<ConditionalDerivativeOrderBook> | undefined, b: ConditionalDerivativeOrderBook | PlainMessage<ConditionalDerivativeOrderBook> | undefined): boolean {
    return proto3.util.equals(ConditionalDerivativeOrderBook, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.Balance
 */
export class Balance extends Message<Balance> {
  /**
   * @generated from field: string subaccount_id = 1;
   */
  subaccountId = "";

  /**
   * @generated from field: string denom = 2;
   */
  denom = "";

  /**
   * @generated from field: injective.exchange.v1beta1.Deposit deposits = 3;
   */
  deposits?: Deposit;

  constructor(data?: PartialMessage<Balance>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.Balance";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "deposits", kind: "message", T: Deposit },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Balance {
    return new Balance().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Balance {
    return new Balance().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Balance {
    return new Balance().fromJsonString(jsonString, options);
  }

  static equals(a: Balance | PlainMessage<Balance> | undefined, b: Balance | PlainMessage<Balance> | undefined): boolean {
    return proto3.util.equals(Balance, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.DerivativePosition
 */
export class DerivativePosition extends Message<DerivativePosition> {
  /**
   * @generated from field: string subaccount_id = 1;
   */
  subaccountId = "";

  /**
   * @generated from field: string market_id = 2;
   */
  marketId = "";

  /**
   * @generated from field: injective.exchange.v1beta1.Position position = 3;
   */
  position?: Position;

  constructor(data?: PartialMessage<DerivativePosition>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.DerivativePosition";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "position", kind: "message", T: Position },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DerivativePosition {
    return new DerivativePosition().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DerivativePosition {
    return new DerivativePosition().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DerivativePosition {
    return new DerivativePosition().fromJsonString(jsonString, options);
  }

  static equals(a: DerivativePosition | PlainMessage<DerivativePosition> | undefined, b: DerivativePosition | PlainMessage<DerivativePosition> | undefined): boolean {
    return proto3.util.equals(DerivativePosition, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.SubaccountNonce
 */
export class SubaccountNonce extends Message<SubaccountNonce> {
  /**
   * @generated from field: string subaccount_id = 1;
   */
  subaccountId = "";

  /**
   * @generated from field: injective.exchange.v1beta1.SubaccountTradeNonce subaccount_trade_nonce = 2;
   */
  subaccountTradeNonce?: SubaccountTradeNonce;

  constructor(data?: PartialMessage<SubaccountNonce>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.SubaccountNonce";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "subaccount_trade_nonce", kind: "message", T: SubaccountTradeNonce },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubaccountNonce {
    return new SubaccountNonce().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubaccountNonce {
    return new SubaccountNonce().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubaccountNonce {
    return new SubaccountNonce().fromJsonString(jsonString, options);
  }

  static equals(a: SubaccountNonce | PlainMessage<SubaccountNonce> | undefined, b: SubaccountNonce | PlainMessage<SubaccountNonce> | undefined): boolean {
    return proto3.util.equals(SubaccountNonce, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.ExpiryFuturesMarketInfoState
 */
export class ExpiryFuturesMarketInfoState extends Message<ExpiryFuturesMarketInfoState> {
  /**
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  /**
   * @generated from field: injective.exchange.v1beta1.ExpiryFuturesMarketInfo market_info = 2;
   */
  marketInfo?: ExpiryFuturesMarketInfo;

  constructor(data?: PartialMessage<ExpiryFuturesMarketInfoState>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.ExpiryFuturesMarketInfoState";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "market_info", kind: "message", T: ExpiryFuturesMarketInfo },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExpiryFuturesMarketInfoState {
    return new ExpiryFuturesMarketInfoState().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExpiryFuturesMarketInfoState {
    return new ExpiryFuturesMarketInfoState().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExpiryFuturesMarketInfoState {
    return new ExpiryFuturesMarketInfoState().fromJsonString(jsonString, options);
  }

  static equals(a: ExpiryFuturesMarketInfoState | PlainMessage<ExpiryFuturesMarketInfoState> | undefined, b: ExpiryFuturesMarketInfoState | PlainMessage<ExpiryFuturesMarketInfoState> | undefined): boolean {
    return proto3.util.equals(ExpiryFuturesMarketInfoState, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.PerpetualMarketFundingState
 */
export class PerpetualMarketFundingState extends Message<PerpetualMarketFundingState> {
  /**
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  /**
   * @generated from field: injective.exchange.v1beta1.PerpetualMarketFunding funding = 2;
   */
  funding?: PerpetualMarketFunding;

  constructor(data?: PartialMessage<PerpetualMarketFundingState>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.PerpetualMarketFundingState";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "funding", kind: "message", T: PerpetualMarketFunding },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PerpetualMarketFundingState {
    return new PerpetualMarketFundingState().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PerpetualMarketFundingState {
    return new PerpetualMarketFundingState().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PerpetualMarketFundingState {
    return new PerpetualMarketFundingState().fromJsonString(jsonString, options);
  }

  static equals(a: PerpetualMarketFundingState | PlainMessage<PerpetualMarketFundingState> | undefined, b: PerpetualMarketFundingState | PlainMessage<PerpetualMarketFundingState> | undefined): boolean {
    return proto3.util.equals(PerpetualMarketFundingState, a, b);
  }
}

