// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file injective/ocr/v1beta1/genesis.proto (package injective.ocr.v1beta1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";
import { EpochAndRound, FeedConfig, Params, Transmission } from "./ocr_pb.js";
import { Coin } from "../../../cosmos/base/v1beta1/coin_pb.js";

/**
 * GenesisState defines the OCR module's genesis state.
 *
 * @generated from message injective.ocr.v1beta1.GenesisState
 */
export class GenesisState extends Message<GenesisState> {
  /**
   * params defines all the parameters of related to OCR.
   *
   * @generated from field: injective.ocr.v1beta1.Params params = 1;
   */
  params?: Params;

  /**
   * feed_configs stores all of the supported OCR feeds
   *
   * @generated from field: repeated injective.ocr.v1beta1.FeedConfig feed_configs = 2;
   */
  feedConfigs: FeedConfig[] = [];

  /**
   * latest_epoch_and_rounds stores the latest epoch and round for each feedId
   *
   * @generated from field: repeated injective.ocr.v1beta1.FeedEpochAndRound latest_epoch_and_rounds = 3;
   */
  latestEpochAndRounds: FeedEpochAndRound[] = [];

  /**
   * feed_transmissions stores the last transmission for each feed
   *
   * @generated from field: repeated injective.ocr.v1beta1.FeedTransmission feed_transmissions = 4;
   */
  feedTransmissions: FeedTransmission[] = [];

  /**
   * latest_aggregator_round_ids stores the latest aggregator round ID for each
   * feedId
   *
   * @generated from field: repeated injective.ocr.v1beta1.FeedLatestAggregatorRoundIDs latest_aggregator_round_ids = 5;
   */
  latestAggregatorRoundIds: FeedLatestAggregatorRoundIDs[] = [];

  /**
   * reward_pools stores the reward pools
   *
   * @generated from field: repeated injective.ocr.v1beta1.RewardPool reward_pools = 6;
   */
  rewardPools: RewardPool[] = [];

  /**
   * feed_observation_counts stores the feed observation counts
   *
   * @generated from field: repeated injective.ocr.v1beta1.FeedCounts feed_observation_counts = 7;
   */
  feedObservationCounts: FeedCounts[] = [];

  /**
   * feed_transmission_counts stores the feed transmission counts
   *
   * @generated from field: repeated injective.ocr.v1beta1.FeedCounts feed_transmission_counts = 8;
   */
  feedTransmissionCounts: FeedCounts[] = [];

  /**
   * pending_payeeships stores the pending payeeships
   *
   * @generated from field: repeated injective.ocr.v1beta1.PendingPayeeship pending_payeeships = 9;
   */
  pendingPayeeships: PendingPayeeship[] = [];

  constructor(data?: PartialMessage<GenesisState>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.ocr.v1beta1.GenesisState";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "params", kind: "message", T: Params },
    { no: 2, name: "feed_configs", kind: "message", T: FeedConfig, repeated: true },
    { no: 3, name: "latest_epoch_and_rounds", kind: "message", T: FeedEpochAndRound, repeated: true },
    { no: 4, name: "feed_transmissions", kind: "message", T: FeedTransmission, repeated: true },
    { no: 5, name: "latest_aggregator_round_ids", kind: "message", T: FeedLatestAggregatorRoundIDs, repeated: true },
    { no: 6, name: "reward_pools", kind: "message", T: RewardPool, repeated: true },
    { no: 7, name: "feed_observation_counts", kind: "message", T: FeedCounts, repeated: true },
    { no: 8, name: "feed_transmission_counts", kind: "message", T: FeedCounts, repeated: true },
    { no: 9, name: "pending_payeeships", kind: "message", T: PendingPayeeship, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GenesisState {
    return new GenesisState().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GenesisState {
    return new GenesisState().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GenesisState {
    return new GenesisState().fromJsonString(jsonString, options);
  }

  static equals(a: GenesisState | PlainMessage<GenesisState> | undefined, b: GenesisState | PlainMessage<GenesisState> | undefined): boolean {
    return proto3.util.equals(GenesisState, a, b);
  }
}

/**
 * @generated from message injective.ocr.v1beta1.FeedTransmission
 */
export class FeedTransmission extends Message<FeedTransmission> {
  /**
   * @generated from field: string feed_id = 1;
   */
  feedId = "";

  /**
   * @generated from field: injective.ocr.v1beta1.Transmission transmission = 2;
   */
  transmission?: Transmission;

  constructor(data?: PartialMessage<FeedTransmission>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.ocr.v1beta1.FeedTransmission";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "feed_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "transmission", kind: "message", T: Transmission },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FeedTransmission {
    return new FeedTransmission().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FeedTransmission {
    return new FeedTransmission().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FeedTransmission {
    return new FeedTransmission().fromJsonString(jsonString, options);
  }

  static equals(a: FeedTransmission | PlainMessage<FeedTransmission> | undefined, b: FeedTransmission | PlainMessage<FeedTransmission> | undefined): boolean {
    return proto3.util.equals(FeedTransmission, a, b);
  }
}

/**
 * @generated from message injective.ocr.v1beta1.FeedEpochAndRound
 */
export class FeedEpochAndRound extends Message<FeedEpochAndRound> {
  /**
   * @generated from field: string feed_id = 1;
   */
  feedId = "";

  /**
   * @generated from field: injective.ocr.v1beta1.EpochAndRound epoch_and_round = 2;
   */
  epochAndRound?: EpochAndRound;

  constructor(data?: PartialMessage<FeedEpochAndRound>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.ocr.v1beta1.FeedEpochAndRound";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "feed_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "epoch_and_round", kind: "message", T: EpochAndRound },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FeedEpochAndRound {
    return new FeedEpochAndRound().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FeedEpochAndRound {
    return new FeedEpochAndRound().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FeedEpochAndRound {
    return new FeedEpochAndRound().fromJsonString(jsonString, options);
  }

  static equals(a: FeedEpochAndRound | PlainMessage<FeedEpochAndRound> | undefined, b: FeedEpochAndRound | PlainMessage<FeedEpochAndRound> | undefined): boolean {
    return proto3.util.equals(FeedEpochAndRound, a, b);
  }
}

/**
 * @generated from message injective.ocr.v1beta1.FeedLatestAggregatorRoundIDs
 */
export class FeedLatestAggregatorRoundIDs extends Message<FeedLatestAggregatorRoundIDs> {
  /**
   * @generated from field: string feed_id = 1;
   */
  feedId = "";

  /**
   * @generated from field: uint64 aggregator_round_id = 2;
   */
  aggregatorRoundId = protoInt64.zero;

  constructor(data?: PartialMessage<FeedLatestAggregatorRoundIDs>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.ocr.v1beta1.FeedLatestAggregatorRoundIDs";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "feed_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "aggregator_round_id", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FeedLatestAggregatorRoundIDs {
    return new FeedLatestAggregatorRoundIDs().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FeedLatestAggregatorRoundIDs {
    return new FeedLatestAggregatorRoundIDs().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FeedLatestAggregatorRoundIDs {
    return new FeedLatestAggregatorRoundIDs().fromJsonString(jsonString, options);
  }

  static equals(a: FeedLatestAggregatorRoundIDs | PlainMessage<FeedLatestAggregatorRoundIDs> | undefined, b: FeedLatestAggregatorRoundIDs | PlainMessage<FeedLatestAggregatorRoundIDs> | undefined): boolean {
    return proto3.util.equals(FeedLatestAggregatorRoundIDs, a, b);
  }
}

/**
 * @generated from message injective.ocr.v1beta1.RewardPool
 */
export class RewardPool extends Message<RewardPool> {
  /**
   * @generated from field: string feed_id = 1;
   */
  feedId = "";

  /**
   * @generated from field: cosmos.base.v1beta1.Coin amount = 2;
   */
  amount?: Coin;

  constructor(data?: PartialMessage<RewardPool>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.ocr.v1beta1.RewardPool";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "feed_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "amount", kind: "message", T: Coin },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RewardPool {
    return new RewardPool().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RewardPool {
    return new RewardPool().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RewardPool {
    return new RewardPool().fromJsonString(jsonString, options);
  }

  static equals(a: RewardPool | PlainMessage<RewardPool> | undefined, b: RewardPool | PlainMessage<RewardPool> | undefined): boolean {
    return proto3.util.equals(RewardPool, a, b);
  }
}

/**
 * @generated from message injective.ocr.v1beta1.FeedCounts
 */
export class FeedCounts extends Message<FeedCounts> {
  /**
   * @generated from field: string feed_id = 1;
   */
  feedId = "";

  /**
   * @generated from field: repeated injective.ocr.v1beta1.Count counts = 2;
   */
  counts: Count[] = [];

  constructor(data?: PartialMessage<FeedCounts>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.ocr.v1beta1.FeedCounts";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "feed_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "counts", kind: "message", T: Count, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FeedCounts {
    return new FeedCounts().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FeedCounts {
    return new FeedCounts().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FeedCounts {
    return new FeedCounts().fromJsonString(jsonString, options);
  }

  static equals(a: FeedCounts | PlainMessage<FeedCounts> | undefined, b: FeedCounts | PlainMessage<FeedCounts> | undefined): boolean {
    return proto3.util.equals(FeedCounts, a, b);
  }
}

/**
 * @generated from message injective.ocr.v1beta1.Count
 */
export class Count extends Message<Count> {
  /**
   * @generated from field: string address = 1;
   */
  address = "";

  /**
   * @generated from field: uint64 count = 2;
   */
  count = protoInt64.zero;

  constructor(data?: PartialMessage<Count>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.ocr.v1beta1.Count";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "count", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Count {
    return new Count().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Count {
    return new Count().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Count {
    return new Count().fromJsonString(jsonString, options);
  }

  static equals(a: Count | PlainMessage<Count> | undefined, b: Count | PlainMessage<Count> | undefined): boolean {
    return proto3.util.equals(Count, a, b);
  }
}

/**
 * @generated from message injective.ocr.v1beta1.PendingPayeeship
 */
export class PendingPayeeship extends Message<PendingPayeeship> {
  /**
   * @generated from field: string feed_id = 1;
   */
  feedId = "";

  /**
   * @generated from field: string transmitter = 2;
   */
  transmitter = "";

  /**
   * @generated from field: string proposed_payee = 3;
   */
  proposedPayee = "";

  constructor(data?: PartialMessage<PendingPayeeship>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.ocr.v1beta1.PendingPayeeship";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "feed_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "transmitter", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "proposed_payee", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PendingPayeeship {
    return new PendingPayeeship().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PendingPayeeship {
    return new PendingPayeeship().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PendingPayeeship {
    return new PendingPayeeship().fromJsonString(jsonString, options);
  }

  static equals(a: PendingPayeeship | PlainMessage<PendingPayeeship> | undefined, b: PendingPayeeship | PlainMessage<PendingPayeeship> | undefined): boolean {
    return proto3.util.equals(PendingPayeeship, a, b);
  }
}

