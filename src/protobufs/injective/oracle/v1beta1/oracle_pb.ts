// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file injective/oracle/v1beta1/oracle.proto (package injective.oracle.v1beta1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";
import { Coin } from "../../../cosmos/base/v1beta1/coin_pb.js";

/**
 * @generated from enum injective.oracle.v1beta1.OracleType
 */
export enum OracleType {
  /**
   * @generated from enum value: Unspecified = 0;
   */
  Unspecified = 0,

  /**
   * @generated from enum value: Band = 1;
   */
  Band = 1,

  /**
   * @generated from enum value: PriceFeed = 2;
   */
  PriceFeed = 2,

  /**
   * @generated from enum value: Coinbase = 3;
   */
  Coinbase = 3,

  /**
   * @generated from enum value: Chainlink = 4;
   */
  Chainlink = 4,

  /**
   * @generated from enum value: Razor = 5;
   */
  Razor = 5,

  /**
   * @generated from enum value: Dia = 6;
   */
  Dia = 6,

  /**
   * @generated from enum value: API3 = 7;
   */
  API3 = 7,

  /**
   * @generated from enum value: Uma = 8;
   */
  Uma = 8,

  /**
   * @generated from enum value: Pyth = 9;
   */
  Pyth = 9,

  /**
   * @generated from enum value: BandIBC = 10;
   */
  BandIBC = 10,

  /**
   * @generated from enum value: Provider = 11;
   */
  Provider = 11,
}
// Retrieve enum metadata with: proto3.getEnumType(OracleType)
proto3.util.setEnumType(OracleType, "injective.oracle.v1beta1.OracleType", [
  { no: 0, name: "Unspecified" },
  { no: 1, name: "Band" },
  { no: 2, name: "PriceFeed" },
  { no: 3, name: "Coinbase" },
  { no: 4, name: "Chainlink" },
  { no: 5, name: "Razor" },
  { no: 6, name: "Dia" },
  { no: 7, name: "API3" },
  { no: 8, name: "Uma" },
  { no: 9, name: "Pyth" },
  { no: 10, name: "BandIBC" },
  { no: 11, name: "Provider" },
]);

/**
 * @generated from message injective.oracle.v1beta1.Params
 */
export class Params extends Message<Params> {
  /**
   * @generated from field: string pyth_contract = 1;
   */
  pythContract = "";

  constructor(data?: PartialMessage<Params>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.oracle.v1beta1.Params";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "pyth_contract", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Params {
    return new Params().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Params {
    return new Params().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Params {
    return new Params().fromJsonString(jsonString, options);
  }

  static equals(a: Params | PlainMessage<Params> | undefined, b: Params | PlainMessage<Params> | undefined): boolean {
    return proto3.util.equals(Params, a, b);
  }
}

/**
 * @generated from message injective.oracle.v1beta1.OracleInfo
 */
export class OracleInfo extends Message<OracleInfo> {
  /**
   * @generated from field: string symbol = 1;
   */
  symbol = "";

  /**
   * @generated from field: injective.oracle.v1beta1.OracleType oracle_type = 2;
   */
  oracleType = OracleType.Unspecified;

  constructor(data?: PartialMessage<OracleInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.oracle.v1beta1.OracleInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "symbol", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "oracle_type", kind: "enum", T: proto3.getEnumType(OracleType) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OracleInfo {
    return new OracleInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OracleInfo {
    return new OracleInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OracleInfo {
    return new OracleInfo().fromJsonString(jsonString, options);
  }

  static equals(a: OracleInfo | PlainMessage<OracleInfo> | undefined, b: OracleInfo | PlainMessage<OracleInfo> | undefined): boolean {
    return proto3.util.equals(OracleInfo, a, b);
  }
}

/**
 * @generated from message injective.oracle.v1beta1.ChainlinkPriceState
 */
export class ChainlinkPriceState extends Message<ChainlinkPriceState> {
  /**
   * @generated from field: string feed_id = 1;
   */
  feedId = "";

  /**
   * @generated from field: string answer = 2;
   */
  answer = "";

  /**
   * @generated from field: uint64 timestamp = 3;
   */
  timestamp = protoInt64.zero;

  /**
   * @generated from field: injective.oracle.v1beta1.PriceState price_state = 4;
   */
  priceState?: PriceState;

  constructor(data?: PartialMessage<ChainlinkPriceState>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.oracle.v1beta1.ChainlinkPriceState";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "feed_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "answer", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "timestamp", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 4, name: "price_state", kind: "message", T: PriceState },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ChainlinkPriceState {
    return new ChainlinkPriceState().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ChainlinkPriceState {
    return new ChainlinkPriceState().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ChainlinkPriceState {
    return new ChainlinkPriceState().fromJsonString(jsonString, options);
  }

  static equals(a: ChainlinkPriceState | PlainMessage<ChainlinkPriceState> | undefined, b: ChainlinkPriceState | PlainMessage<ChainlinkPriceState> | undefined): boolean {
    return proto3.util.equals(ChainlinkPriceState, a, b);
  }
}

/**
 * @generated from message injective.oracle.v1beta1.BandPriceState
 */
export class BandPriceState extends Message<BandPriceState> {
  /**
   * @generated from field: string symbol = 1;
   */
  symbol = "";

  /**
   * @generated from field: string rate = 2;
   */
  rate = "";

  /**
   * @generated from field: uint64 resolve_time = 3;
   */
  resolveTime = protoInt64.zero;

  /**
   * @generated from field: uint64 request_ID = 4;
   */
  requestID = protoInt64.zero;

  /**
   * @generated from field: injective.oracle.v1beta1.PriceState price_state = 5;
   */
  priceState?: PriceState;

  constructor(data?: PartialMessage<BandPriceState>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.oracle.v1beta1.BandPriceState";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "symbol", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "resolve_time", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 4, name: "request_ID", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 5, name: "price_state", kind: "message", T: PriceState },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BandPriceState {
    return new BandPriceState().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BandPriceState {
    return new BandPriceState().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BandPriceState {
    return new BandPriceState().fromJsonString(jsonString, options);
  }

  static equals(a: BandPriceState | PlainMessage<BandPriceState> | undefined, b: BandPriceState | PlainMessage<BandPriceState> | undefined): boolean {
    return proto3.util.equals(BandPriceState, a, b);
  }
}

/**
 * @generated from message injective.oracle.v1beta1.PriceFeedState
 */
export class PriceFeedState extends Message<PriceFeedState> {
  /**
   * @generated from field: string base = 1;
   */
  base = "";

  /**
   * @generated from field: string quote = 2;
   */
  quote = "";

  /**
   * @generated from field: injective.oracle.v1beta1.PriceState price_state = 3;
   */
  priceState?: PriceState;

  /**
   * @generated from field: repeated string relayers = 4;
   */
  relayers: string[] = [];

  constructor(data?: PartialMessage<PriceFeedState>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.oracle.v1beta1.PriceFeedState";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "base", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "quote", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "price_state", kind: "message", T: PriceState },
    { no: 4, name: "relayers", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PriceFeedState {
    return new PriceFeedState().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PriceFeedState {
    return new PriceFeedState().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PriceFeedState {
    return new PriceFeedState().fromJsonString(jsonString, options);
  }

  static equals(a: PriceFeedState | PlainMessage<PriceFeedState> | undefined, b: PriceFeedState | PlainMessage<PriceFeedState> | undefined): boolean {
    return proto3.util.equals(PriceFeedState, a, b);
  }
}

/**
 * @generated from message injective.oracle.v1beta1.ProviderInfo
 */
export class ProviderInfo extends Message<ProviderInfo> {
  /**
   * @generated from field: string provider = 1;
   */
  provider = "";

  /**
   * @generated from field: repeated string relayers = 2;
   */
  relayers: string[] = [];

  constructor(data?: PartialMessage<ProviderInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.oracle.v1beta1.ProviderInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "provider", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "relayers", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProviderInfo {
    return new ProviderInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProviderInfo {
    return new ProviderInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProviderInfo {
    return new ProviderInfo().fromJsonString(jsonString, options);
  }

  static equals(a: ProviderInfo | PlainMessage<ProviderInfo> | undefined, b: ProviderInfo | PlainMessage<ProviderInfo> | undefined): boolean {
    return proto3.util.equals(ProviderInfo, a, b);
  }
}

/**
 * @generated from message injective.oracle.v1beta1.ProviderState
 */
export class ProviderState extends Message<ProviderState> {
  /**
   * @generated from field: injective.oracle.v1beta1.ProviderInfo provider_info = 1;
   */
  providerInfo?: ProviderInfo;

  /**
   * @generated from field: repeated injective.oracle.v1beta1.ProviderPriceState provider_price_states = 2;
   */
  providerPriceStates: ProviderPriceState[] = [];

  constructor(data?: PartialMessage<ProviderState>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.oracle.v1beta1.ProviderState";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "provider_info", kind: "message", T: ProviderInfo },
    { no: 2, name: "provider_price_states", kind: "message", T: ProviderPriceState, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProviderState {
    return new ProviderState().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProviderState {
    return new ProviderState().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProviderState {
    return new ProviderState().fromJsonString(jsonString, options);
  }

  static equals(a: ProviderState | PlainMessage<ProviderState> | undefined, b: ProviderState | PlainMessage<ProviderState> | undefined): boolean {
    return proto3.util.equals(ProviderState, a, b);
  }
}

/**
 * @generated from message injective.oracle.v1beta1.ProviderPriceState
 */
export class ProviderPriceState extends Message<ProviderPriceState> {
  /**
   * @generated from field: string symbol = 1;
   */
  symbol = "";

  /**
   * @generated from field: injective.oracle.v1beta1.PriceState state = 2;
   */
  state?: PriceState;

  constructor(data?: PartialMessage<ProviderPriceState>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.oracle.v1beta1.ProviderPriceState";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "symbol", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "state", kind: "message", T: PriceState },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProviderPriceState {
    return new ProviderPriceState().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProviderPriceState {
    return new ProviderPriceState().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProviderPriceState {
    return new ProviderPriceState().fromJsonString(jsonString, options);
  }

  static equals(a: ProviderPriceState | PlainMessage<ProviderPriceState> | undefined, b: ProviderPriceState | PlainMessage<ProviderPriceState> | undefined): boolean {
    return proto3.util.equals(ProviderPriceState, a, b);
  }
}

/**
 * @generated from message injective.oracle.v1beta1.PriceFeedInfo
 */
export class PriceFeedInfo extends Message<PriceFeedInfo> {
  /**
   * @generated from field: string base = 1;
   */
  base = "";

  /**
   * @generated from field: string quote = 2;
   */
  quote = "";

  constructor(data?: PartialMessage<PriceFeedInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.oracle.v1beta1.PriceFeedInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "base", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "quote", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PriceFeedInfo {
    return new PriceFeedInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PriceFeedInfo {
    return new PriceFeedInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PriceFeedInfo {
    return new PriceFeedInfo().fromJsonString(jsonString, options);
  }

  static equals(a: PriceFeedInfo | PlainMessage<PriceFeedInfo> | undefined, b: PriceFeedInfo | PlainMessage<PriceFeedInfo> | undefined): boolean {
    return proto3.util.equals(PriceFeedInfo, a, b);
  }
}

/**
 * @generated from message injective.oracle.v1beta1.PriceFeedPrice
 */
export class PriceFeedPrice extends Message<PriceFeedPrice> {
  /**
   * @generated from field: string price = 1;
   */
  price = "";

  constructor(data?: PartialMessage<PriceFeedPrice>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.oracle.v1beta1.PriceFeedPrice";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PriceFeedPrice {
    return new PriceFeedPrice().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PriceFeedPrice {
    return new PriceFeedPrice().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PriceFeedPrice {
    return new PriceFeedPrice().fromJsonString(jsonString, options);
  }

  static equals(a: PriceFeedPrice | PlainMessage<PriceFeedPrice> | undefined, b: PriceFeedPrice | PlainMessage<PriceFeedPrice> | undefined): boolean {
    return proto3.util.equals(PriceFeedPrice, a, b);
  }
}

/**
 * @generated from message injective.oracle.v1beta1.CoinbasePriceState
 */
export class CoinbasePriceState extends Message<CoinbasePriceState> {
  /**
   * kind should always be "prices"
   *
   * @generated from field: string kind = 1;
   */
  kind = "";

  /**
   * timestamp of the when the price was signed by coinbase
   *
   * @generated from field: uint64 timestamp = 2;
   */
  timestamp = protoInt64.zero;

  /**
   * the symbol of the price, e.g. BTC
   *
   * @generated from field: string key = 3;
   */
  key = "";

  /**
   * the value of the price scaled by 1e6
   *
   * @generated from field: uint64 value = 4;
   */
  value = protoInt64.zero;

  /**
   * the price state
   *
   * @generated from field: injective.oracle.v1beta1.PriceState price_state = 5;
   */
  priceState?: PriceState;

  constructor(data?: PartialMessage<CoinbasePriceState>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.oracle.v1beta1.CoinbasePriceState";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "kind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "timestamp", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 3, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "value", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 5, name: "price_state", kind: "message", T: PriceState },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CoinbasePriceState {
    return new CoinbasePriceState().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CoinbasePriceState {
    return new CoinbasePriceState().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CoinbasePriceState {
    return new CoinbasePriceState().fromJsonString(jsonString, options);
  }

  static equals(a: CoinbasePriceState | PlainMessage<CoinbasePriceState> | undefined, b: CoinbasePriceState | PlainMessage<CoinbasePriceState> | undefined): boolean {
    return proto3.util.equals(CoinbasePriceState, a, b);
  }
}

/**
 * @generated from message injective.oracle.v1beta1.PriceState
 */
export class PriceState extends Message<PriceState> {
  /**
   * @generated from field: string price = 1;
   */
  price = "";

  /**
   * @generated from field: string cumulative_price = 2;
   */
  cumulativePrice = "";

  /**
   * @generated from field: int64 timestamp = 3;
   */
  timestamp = protoInt64.zero;

  constructor(data?: PartialMessage<PriceState>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.oracle.v1beta1.PriceState";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "cumulative_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "timestamp", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PriceState {
    return new PriceState().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PriceState {
    return new PriceState().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PriceState {
    return new PriceState().fromJsonString(jsonString, options);
  }

  static equals(a: PriceState | PlainMessage<PriceState> | undefined, b: PriceState | PlainMessage<PriceState> | undefined): boolean {
    return proto3.util.equals(PriceState, a, b);
  }
}

/**
 * @generated from message injective.oracle.v1beta1.PythPriceState
 */
export class PythPriceState extends Message<PythPriceState> {
  /**
   * @generated from field: string price_id = 1;
   */
  priceId = "";

  /**
   * @generated from field: string ema_price = 2;
   */
  emaPrice = "";

  /**
   * @generated from field: string ema_conf = 3;
   */
  emaConf = "";

  /**
   * @generated from field: string conf = 4;
   */
  conf = "";

  /**
   * @generated from field: uint64 publish_time = 5;
   */
  publishTime = protoInt64.zero;

  /**
   * @generated from field: injective.oracle.v1beta1.PriceState price_state = 6;
   */
  priceState?: PriceState;

  constructor(data?: PartialMessage<PythPriceState>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.oracle.v1beta1.PythPriceState";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "price_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "ema_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "ema_conf", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "conf", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "publish_time", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 6, name: "price_state", kind: "message", T: PriceState },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PythPriceState {
    return new PythPriceState().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PythPriceState {
    return new PythPriceState().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PythPriceState {
    return new PythPriceState().fromJsonString(jsonString, options);
  }

  static equals(a: PythPriceState | PlainMessage<PythPriceState> | undefined, b: PythPriceState | PlainMessage<PythPriceState> | undefined): boolean {
    return proto3.util.equals(PythPriceState, a, b);
  }
}

/**
 * @generated from message injective.oracle.v1beta1.BandOracleRequest
 */
export class BandOracleRequest extends Message<BandOracleRequest> {
  /**
   * Unique Identifier for band ibc oracle request
   *
   * @generated from field: uint64 request_id = 1;
   */
  requestId = protoInt64.zero;

  /**
   * OracleScriptID is the unique identifier of the oracle script to be
   * executed.
   *
   * @generated from field: int64 oracle_script_id = 2;
   */
  oracleScriptId = protoInt64.zero;

  /**
   * Symbols is the list of symbols to prepare in the calldata
   *
   * @generated from field: repeated string symbols = 3;
   */
  symbols: string[] = [];

  /**
   * AskCount is the number of validators that are requested to respond to this
   * oracle request. Higher value means more security, at a higher gas cost.
   *
   * @generated from field: uint64 ask_count = 4;
   */
  askCount = protoInt64.zero;

  /**
   * MinCount is the minimum number of validators necessary for the request to
   * proceed to the execution phase. Higher value means more security, at the
   * cost of liveness.
   *
   * @generated from field: uint64 min_count = 5;
   */
  minCount = protoInt64.zero;

  /**
   * FeeLimit is the maximum tokens that will be paid to all data source
   * providers.
   *
   * @generated from field: repeated cosmos.base.v1beta1.Coin fee_limit = 6;
   */
  feeLimit: Coin[] = [];

  /**
   * PrepareGas is amount of gas to pay to prepare raw requests
   *
   * @generated from field: uint64 prepare_gas = 7;
   */
  prepareGas = protoInt64.zero;

  /**
   * ExecuteGas is amount of gas to reserve for executing
   *
   * @generated from field: uint64 execute_gas = 8;
   */
  executeGas = protoInt64.zero;

  /**
   * MinSourceCount is the minimum number of data sources that must be used by
   * each validator
   *
   * @generated from field: uint64 min_source_count = 9;
   */
  minSourceCount = protoInt64.zero;

  constructor(data?: PartialMessage<BandOracleRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.oracle.v1beta1.BandOracleRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "request_id", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "oracle_script_id", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "symbols", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "ask_count", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 5, name: "min_count", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 6, name: "fee_limit", kind: "message", T: Coin, repeated: true },
    { no: 7, name: "prepare_gas", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 8, name: "execute_gas", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 9, name: "min_source_count", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BandOracleRequest {
    return new BandOracleRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BandOracleRequest {
    return new BandOracleRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BandOracleRequest {
    return new BandOracleRequest().fromJsonString(jsonString, options);
  }

  static equals(a: BandOracleRequest | PlainMessage<BandOracleRequest> | undefined, b: BandOracleRequest | PlainMessage<BandOracleRequest> | undefined): boolean {
    return proto3.util.equals(BandOracleRequest, a, b);
  }
}

/**
 * @generated from message injective.oracle.v1beta1.BandIBCParams
 */
export class BandIBCParams extends Message<BandIBCParams> {
  /**
   * true if Band IBC should be enabled
   *
   * @generated from field: bool band_ibc_enabled = 1;
   */
  bandIbcEnabled = false;

  /**
   * block request interval to send Band IBC prices
   *
   * @generated from field: int64 ibc_request_interval = 2;
   */
  ibcRequestInterval = protoInt64.zero;

  /**
   * band IBC source channel
   *
   * @generated from field: string ibc_source_channel = 3;
   */
  ibcSourceChannel = "";

  /**
   * band IBC version
   *
   * @generated from field: string ibc_version = 4;
   */
  ibcVersion = "";

  /**
   * band IBC portID
   *
   * @generated from field: string ibc_port_id = 5;
   */
  ibcPortId = "";

  /**
   *  legacy oracle scheme ids
   *
   * @generated from field: repeated int64 legacy_oracle_ids = 6;
   */
  legacyOracleIds: bigint[] = [];

  constructor(data?: PartialMessage<BandIBCParams>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.oracle.v1beta1.BandIBCParams";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "band_ibc_enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "ibc_request_interval", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "ibc_source_channel", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "ibc_version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "ibc_port_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "legacy_oracle_ids", kind: "scalar", T: 3 /* ScalarType.INT64 */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BandIBCParams {
    return new BandIBCParams().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BandIBCParams {
    return new BandIBCParams().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BandIBCParams {
    return new BandIBCParams().fromJsonString(jsonString, options);
  }

  static equals(a: BandIBCParams | PlainMessage<BandIBCParams> | undefined, b: BandIBCParams | PlainMessage<BandIBCParams> | undefined): boolean {
    return proto3.util.equals(BandIBCParams, a, b);
  }
}

/**
 * @generated from message injective.oracle.v1beta1.SymbolPriceTimestamp
 */
export class SymbolPriceTimestamp extends Message<SymbolPriceTimestamp> {
  /**
   * @generated from field: injective.oracle.v1beta1.OracleType oracle = 1;
   */
  oracle = OracleType.Unspecified;

  /**
   * @generated from field: string symbol_id = 2;
   */
  symbolId = "";

  /**
   * @generated from field: int64 timestamp = 3;
   */
  timestamp = protoInt64.zero;

  constructor(data?: PartialMessage<SymbolPriceTimestamp>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.oracle.v1beta1.SymbolPriceTimestamp";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "oracle", kind: "enum", T: proto3.getEnumType(OracleType) },
    { no: 2, name: "symbol_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "timestamp", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SymbolPriceTimestamp {
    return new SymbolPriceTimestamp().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SymbolPriceTimestamp {
    return new SymbolPriceTimestamp().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SymbolPriceTimestamp {
    return new SymbolPriceTimestamp().fromJsonString(jsonString, options);
  }

  static equals(a: SymbolPriceTimestamp | PlainMessage<SymbolPriceTimestamp> | undefined, b: SymbolPriceTimestamp | PlainMessage<SymbolPriceTimestamp> | undefined): boolean {
    return proto3.util.equals(SymbolPriceTimestamp, a, b);
  }
}

/**
 * @generated from message injective.oracle.v1beta1.LastPriceTimestamps
 */
export class LastPriceTimestamps extends Message<LastPriceTimestamps> {
  /**
   * @generated from field: repeated injective.oracle.v1beta1.SymbolPriceTimestamp last_price_timestamps = 1;
   */
  lastPriceTimestamps: SymbolPriceTimestamp[] = [];

  constructor(data?: PartialMessage<LastPriceTimestamps>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.oracle.v1beta1.LastPriceTimestamps";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "last_price_timestamps", kind: "message", T: SymbolPriceTimestamp, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LastPriceTimestamps {
    return new LastPriceTimestamps().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LastPriceTimestamps {
    return new LastPriceTimestamps().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LastPriceTimestamps {
    return new LastPriceTimestamps().fromJsonString(jsonString, options);
  }

  static equals(a: LastPriceTimestamps | PlainMessage<LastPriceTimestamps> | undefined, b: LastPriceTimestamps | PlainMessage<LastPriceTimestamps> | undefined): boolean {
    return proto3.util.equals(LastPriceTimestamps, a, b);
  }
}

/**
 * @generated from message injective.oracle.v1beta1.PriceRecords
 */
export class PriceRecords extends Message<PriceRecords> {
  /**
   * @generated from field: injective.oracle.v1beta1.OracleType oracle = 1;
   */
  oracle = OracleType.Unspecified;

  /**
   * @generated from field: string symbol_id = 2;
   */
  symbolId = "";

  /**
   * @generated from field: repeated injective.oracle.v1beta1.PriceRecord latest_price_records = 3;
   */
  latestPriceRecords: PriceRecord[] = [];

  constructor(data?: PartialMessage<PriceRecords>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.oracle.v1beta1.PriceRecords";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "oracle", kind: "enum", T: proto3.getEnumType(OracleType) },
    { no: 2, name: "symbol_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "latest_price_records", kind: "message", T: PriceRecord, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PriceRecords {
    return new PriceRecords().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PriceRecords {
    return new PriceRecords().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PriceRecords {
    return new PriceRecords().fromJsonString(jsonString, options);
  }

  static equals(a: PriceRecords | PlainMessage<PriceRecords> | undefined, b: PriceRecords | PlainMessage<PriceRecords> | undefined): boolean {
    return proto3.util.equals(PriceRecords, a, b);
  }
}

/**
 * @generated from message injective.oracle.v1beta1.PriceRecord
 */
export class PriceRecord extends Message<PriceRecord> {
  /**
   * @generated from field: int64 timestamp = 1;
   */
  timestamp = protoInt64.zero;

  /**
   * @generated from field: string price = 2;
   */
  price = "";

  constructor(data?: PartialMessage<PriceRecord>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.oracle.v1beta1.PriceRecord";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "timestamp", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PriceRecord {
    return new PriceRecord().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PriceRecord {
    return new PriceRecord().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PriceRecord {
    return new PriceRecord().fromJsonString(jsonString, options);
  }

  static equals(a: PriceRecord | PlainMessage<PriceRecord> | undefined, b: PriceRecord | PlainMessage<PriceRecord> | undefined): boolean {
    return proto3.util.equals(PriceRecord, a, b);
  }
}

/**
 * MetadataStatistics refers to the metadata summary statistics of the
 * historical sample considered
 *
 * @generated from message injective.oracle.v1beta1.MetadataStatistics
 */
export class MetadataStatistics extends Message<MetadataStatistics> {
  /**
   * GroupCount refers to the number of groups used. Equals RecordsSampleSize if
   * no grouping is used
   *
   * @generated from field: uint32 group_count = 1;
   */
  groupCount = 0;

  /**
   * RecordsSampleSize refers to the total number of records used.
   *
   * @generated from field: uint32 records_sample_size = 2;
   */
  recordsSampleSize = 0;

  /**
   * Mean refers to the arithmetic mean
   * For trades, the mean is the VWAP computed over the grouped trade records ∑
   * (price * quantity) / ∑ quantity For oracle prices, the mean is computed
   * over the price records ∑ (price) / prices_count
   *
   * @generated from field: string mean = 3;
   */
  mean = "";

  /**
   * TWAP refers to the time-weighted average price which equals ∑ (price_i *
   * ∆t_i) / ∑ ∆t_i where ∆t_i = t_i - t_{i-1}
   *
   * @generated from field: string twap = 4;
   */
  twap = "";

  /**
   * FirstTimestamp is the timestamp of the oldest record considered
   *
   * @generated from field: int64 first_timestamp = 5;
   */
  firstTimestamp = protoInt64.zero;

  /**
   * LastTimestamp is the timestamp of the youngest record considered
   *
   * @generated from field: int64 last_timestamp = 6;
   */
  lastTimestamp = protoInt64.zero;

  /**
   * MinPrice refers to the smallest individual raw price considered
   *
   * @generated from field: string min_price = 7;
   */
  minPrice = "";

  /**
   * MaxPrice refers to the largest individual raw price considered
   *
   * @generated from field: string max_price = 8;
   */
  maxPrice = "";

  /**
   * MedianPrice refers to the median individual raw price considered
   *
   * @generated from field: string median_price = 9;
   */
  medianPrice = "";

  constructor(data?: PartialMessage<MetadataStatistics>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.oracle.v1beta1.MetadataStatistics";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "group_count", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "records_sample_size", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 3, name: "mean", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "twap", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "first_timestamp", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 6, name: "last_timestamp", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 7, name: "min_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "max_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "median_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MetadataStatistics {
    return new MetadataStatistics().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MetadataStatistics {
    return new MetadataStatistics().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MetadataStatistics {
    return new MetadataStatistics().fromJsonString(jsonString, options);
  }

  static equals(a: MetadataStatistics | PlainMessage<MetadataStatistics> | undefined, b: MetadataStatistics | PlainMessage<MetadataStatistics> | undefined): boolean {
    return proto3.util.equals(MetadataStatistics, a, b);
  }
}

/**
 * @generated from message injective.oracle.v1beta1.PriceAttestation
 */
export class PriceAttestation extends Message<PriceAttestation> {
  /**
   * @generated from field: string price_id = 1;
   */
  priceId = "";

  /**
   * MaxPrice refers to the largest individual raw price considered
   *
   * @generated from field: int64 price = 2;
   */
  price = protoInt64.zero;

  /**
   * @generated from field: uint64 conf = 3;
   */
  conf = protoInt64.zero;

  /**
   * @generated from field: int32 expo = 4;
   */
  expo = 0;

  /**
   * @generated from field: int64 ema_price = 5;
   */
  emaPrice = protoInt64.zero;

  /**
   * @generated from field: uint64 ema_conf = 6;
   */
  emaConf = protoInt64.zero;

  /**
   * @generated from field: int32 ema_expo = 7;
   */
  emaExpo = 0;

  /**
   * @generated from field: int64 publish_time = 8;
   */
  publishTime = protoInt64.zero;

  constructor(data?: PartialMessage<PriceAttestation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.oracle.v1beta1.PriceAttestation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "price_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "price", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "conf", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 4, name: "expo", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 5, name: "ema_price", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 6, name: "ema_conf", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 7, name: "ema_expo", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 8, name: "publish_time", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PriceAttestation {
    return new PriceAttestation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PriceAttestation {
    return new PriceAttestation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PriceAttestation {
    return new PriceAttestation().fromJsonString(jsonString, options);
  }

  static equals(a: PriceAttestation | PlainMessage<PriceAttestation> | undefined, b: PriceAttestation | PlainMessage<PriceAttestation> | undefined): boolean {
    return proto3.util.equals(PriceAttestation, a, b);
  }
}

