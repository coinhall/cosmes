// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file injective/stream/v1beta1/query.proto (package injective.stream.v1beta1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";
import { Deposit, DerivativeLimitOrder, Level, PositionDelta, SpotLimitOrder } from "../../exchange/v1beta1/exchange_pb.js";
import { Coin } from "../../../cosmos/base/v1beta1/coin_pb.js";

/**
 * @generated from enum injective.stream.v1beta1.OrderUpdateStatus
 */
export enum OrderUpdateStatus {
  /**
   * @generated from enum value: Unspecified = 0;
   */
  Unspecified = 0,

  /**
   * @generated from enum value: Booked = 1;
   */
  Booked = 1,

  /**
   * @generated from enum value: Matched = 2;
   */
  Matched = 2,

  /**
   * @generated from enum value: Cancelled = 3;
   */
  Cancelled = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(OrderUpdateStatus)
proto3.util.setEnumType(OrderUpdateStatus, "injective.stream.v1beta1.OrderUpdateStatus", [
  { no: 0, name: "Unspecified" },
  { no: 1, name: "Booked" },
  { no: 2, name: "Matched" },
  { no: 3, name: "Cancelled" },
]);

/**
 * @generated from message injective.stream.v1beta1.StreamRequest
 */
export class StreamRequest extends Message<StreamRequest> {
  /**
   * @generated from field: injective.stream.v1beta1.BankBalancesFilter bank_balances_filter = 1;
   */
  bankBalancesFilter?: BankBalancesFilter;

  /**
   * @generated from field: injective.stream.v1beta1.SubaccountDepositsFilter subaccount_deposits_filter = 2;
   */
  subaccountDepositsFilter?: SubaccountDepositsFilter;

  /**
   * @generated from field: injective.stream.v1beta1.TradesFilter spot_trades_filter = 3;
   */
  spotTradesFilter?: TradesFilter;

  /**
   * @generated from field: injective.stream.v1beta1.TradesFilter derivative_trades_filter = 4;
   */
  derivativeTradesFilter?: TradesFilter;

  /**
   * @generated from field: injective.stream.v1beta1.OrdersFilter spot_orders_filter = 5;
   */
  spotOrdersFilter?: OrdersFilter;

  /**
   * @generated from field: injective.stream.v1beta1.OrdersFilter derivative_orders_filter = 6;
   */
  derivativeOrdersFilter?: OrdersFilter;

  /**
   * @generated from field: injective.stream.v1beta1.OrderbookFilter spot_orderbooks_filter = 7;
   */
  spotOrderbooksFilter?: OrderbookFilter;

  /**
   * @generated from field: injective.stream.v1beta1.OrderbookFilter derivative_orderbooks_filter = 8;
   */
  derivativeOrderbooksFilter?: OrderbookFilter;

  /**
   * @generated from field: injective.stream.v1beta1.PositionsFilter positions_filter = 9;
   */
  positionsFilter?: PositionsFilter;

  /**
   * @generated from field: injective.stream.v1beta1.OraclePriceFilter oracle_price_filter = 10;
   */
  oraclePriceFilter?: OraclePriceFilter;

  constructor(data?: PartialMessage<StreamRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.stream.v1beta1.StreamRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "bank_balances_filter", kind: "message", T: BankBalancesFilter },
    { no: 2, name: "subaccount_deposits_filter", kind: "message", T: SubaccountDepositsFilter },
    { no: 3, name: "spot_trades_filter", kind: "message", T: TradesFilter },
    { no: 4, name: "derivative_trades_filter", kind: "message", T: TradesFilter },
    { no: 5, name: "spot_orders_filter", kind: "message", T: OrdersFilter },
    { no: 6, name: "derivative_orders_filter", kind: "message", T: OrdersFilter },
    { no: 7, name: "spot_orderbooks_filter", kind: "message", T: OrderbookFilter },
    { no: 8, name: "derivative_orderbooks_filter", kind: "message", T: OrderbookFilter },
    { no: 9, name: "positions_filter", kind: "message", T: PositionsFilter },
    { no: 10, name: "oracle_price_filter", kind: "message", T: OraclePriceFilter },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamRequest {
    return new StreamRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamRequest {
    return new StreamRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamRequest {
    return new StreamRequest().fromJsonString(jsonString, options);
  }

  static equals(a: StreamRequest | PlainMessage<StreamRequest> | undefined, b: StreamRequest | PlainMessage<StreamRequest> | undefined): boolean {
    return proto3.util.equals(StreamRequest, a, b);
  }
}

/**
 * @generated from message injective.stream.v1beta1.StreamResponse
 */
export class StreamResponse extends Message<StreamResponse> {
  /**
   * @generated from field: uint64 block_height = 1;
   */
  blockHeight = protoInt64.zero;

  /**
   * @generated from field: int64 block_time = 2;
   */
  blockTime = protoInt64.zero;

  /**
   * @generated from field: repeated injective.stream.v1beta1.BankBalance bank_balances = 3;
   */
  bankBalances: BankBalance[] = [];

  /**
   * @generated from field: repeated injective.stream.v1beta1.SubaccountDeposits subaccount_deposits = 4;
   */
  subaccountDeposits: SubaccountDeposits[] = [];

  /**
   * @generated from field: repeated injective.stream.v1beta1.SpotTrade spot_trades = 5;
   */
  spotTrades: SpotTrade[] = [];

  /**
   * @generated from field: repeated injective.stream.v1beta1.DerivativeTrade derivative_trades = 6;
   */
  derivativeTrades: DerivativeTrade[] = [];

  /**
   * @generated from field: repeated injective.stream.v1beta1.SpotOrderUpdate spot_orders = 7;
   */
  spotOrders: SpotOrderUpdate[] = [];

  /**
   * @generated from field: repeated injective.stream.v1beta1.DerivativeOrderUpdate derivative_orders = 8;
   */
  derivativeOrders: DerivativeOrderUpdate[] = [];

  /**
   * @generated from field: repeated injective.stream.v1beta1.OrderbookUpdate spot_orderbook_updates = 9;
   */
  spotOrderbookUpdates: OrderbookUpdate[] = [];

  /**
   * @generated from field: repeated injective.stream.v1beta1.OrderbookUpdate derivative_orderbook_updates = 10;
   */
  derivativeOrderbookUpdates: OrderbookUpdate[] = [];

  /**
   * @generated from field: repeated injective.stream.v1beta1.Position positions = 11;
   */
  positions: Position[] = [];

  /**
   * @generated from field: repeated injective.stream.v1beta1.OraclePrice oracle_prices = 12;
   */
  oraclePrices: OraclePrice[] = [];

  constructor(data?: PartialMessage<StreamResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.stream.v1beta1.StreamResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "block_height", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "block_time", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "bank_balances", kind: "message", T: BankBalance, repeated: true },
    { no: 4, name: "subaccount_deposits", kind: "message", T: SubaccountDeposits, repeated: true },
    { no: 5, name: "spot_trades", kind: "message", T: SpotTrade, repeated: true },
    { no: 6, name: "derivative_trades", kind: "message", T: DerivativeTrade, repeated: true },
    { no: 7, name: "spot_orders", kind: "message", T: SpotOrderUpdate, repeated: true },
    { no: 8, name: "derivative_orders", kind: "message", T: DerivativeOrderUpdate, repeated: true },
    { no: 9, name: "spot_orderbook_updates", kind: "message", T: OrderbookUpdate, repeated: true },
    { no: 10, name: "derivative_orderbook_updates", kind: "message", T: OrderbookUpdate, repeated: true },
    { no: 11, name: "positions", kind: "message", T: Position, repeated: true },
    { no: 12, name: "oracle_prices", kind: "message", T: OraclePrice, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamResponse {
    return new StreamResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamResponse {
    return new StreamResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamResponse {
    return new StreamResponse().fromJsonString(jsonString, options);
  }

  static equals(a: StreamResponse | PlainMessage<StreamResponse> | undefined, b: StreamResponse | PlainMessage<StreamResponse> | undefined): boolean {
    return proto3.util.equals(StreamResponse, a, b);
  }
}

/**
 * @generated from message injective.stream.v1beta1.OrderbookUpdate
 */
export class OrderbookUpdate extends Message<OrderbookUpdate> {
  /**
   * @generated from field: uint64 seq = 1;
   */
  seq = protoInt64.zero;

  /**
   * @generated from field: injective.stream.v1beta1.Orderbook orderbook = 2;
   */
  orderbook?: Orderbook;

  constructor(data?: PartialMessage<OrderbookUpdate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.stream.v1beta1.OrderbookUpdate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "seq", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "orderbook", kind: "message", T: Orderbook },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OrderbookUpdate {
    return new OrderbookUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OrderbookUpdate {
    return new OrderbookUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OrderbookUpdate {
    return new OrderbookUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: OrderbookUpdate | PlainMessage<OrderbookUpdate> | undefined, b: OrderbookUpdate | PlainMessage<OrderbookUpdate> | undefined): boolean {
    return proto3.util.equals(OrderbookUpdate, a, b);
  }
}

/**
 * @generated from message injective.stream.v1beta1.Orderbook
 */
export class Orderbook extends Message<Orderbook> {
  /**
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  /**
   * @generated from field: repeated injective.exchange.v1beta1.Level buy_levels = 2;
   */
  buyLevels: Level[] = [];

  /**
   * @generated from field: repeated injective.exchange.v1beta1.Level sell_levels = 3;
   */
  sellLevels: Level[] = [];

  constructor(data?: PartialMessage<Orderbook>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.stream.v1beta1.Orderbook";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "buy_levels", kind: "message", T: Level, repeated: true },
    { no: 3, name: "sell_levels", kind: "message", T: Level, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Orderbook {
    return new Orderbook().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Orderbook {
    return new Orderbook().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Orderbook {
    return new Orderbook().fromJsonString(jsonString, options);
  }

  static equals(a: Orderbook | PlainMessage<Orderbook> | undefined, b: Orderbook | PlainMessage<Orderbook> | undefined): boolean {
    return proto3.util.equals(Orderbook, a, b);
  }
}

/**
 * @generated from message injective.stream.v1beta1.BankBalance
 */
export class BankBalance extends Message<BankBalance> {
  /**
   * @generated from field: string account = 1;
   */
  account = "";

  /**
   * @generated from field: repeated cosmos.base.v1beta1.Coin balances = 2;
   */
  balances: Coin[] = [];

  constructor(data?: PartialMessage<BankBalance>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.stream.v1beta1.BankBalance";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "account", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "balances", kind: "message", T: Coin, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BankBalance {
    return new BankBalance().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BankBalance {
    return new BankBalance().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BankBalance {
    return new BankBalance().fromJsonString(jsonString, options);
  }

  static equals(a: BankBalance | PlainMessage<BankBalance> | undefined, b: BankBalance | PlainMessage<BankBalance> | undefined): boolean {
    return proto3.util.equals(BankBalance, a, b);
  }
}

/**
 * @generated from message injective.stream.v1beta1.SubaccountDeposits
 */
export class SubaccountDeposits extends Message<SubaccountDeposits> {
  /**
   * @generated from field: string subaccount_id = 1;
   */
  subaccountId = "";

  /**
   * @generated from field: repeated injective.stream.v1beta1.SubaccountDeposit deposits = 2;
   */
  deposits: SubaccountDeposit[] = [];

  constructor(data?: PartialMessage<SubaccountDeposits>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.stream.v1beta1.SubaccountDeposits";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "deposits", kind: "message", T: SubaccountDeposit, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubaccountDeposits {
    return new SubaccountDeposits().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubaccountDeposits {
    return new SubaccountDeposits().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubaccountDeposits {
    return new SubaccountDeposits().fromJsonString(jsonString, options);
  }

  static equals(a: SubaccountDeposits | PlainMessage<SubaccountDeposits> | undefined, b: SubaccountDeposits | PlainMessage<SubaccountDeposits> | undefined): boolean {
    return proto3.util.equals(SubaccountDeposits, a, b);
  }
}

/**
 * @generated from message injective.stream.v1beta1.SubaccountDeposit
 */
export class SubaccountDeposit extends Message<SubaccountDeposit> {
  /**
   * @generated from field: string denom = 1;
   */
  denom = "";

  /**
   * @generated from field: injective.exchange.v1beta1.Deposit deposit = 2;
   */
  deposit?: Deposit;

  constructor(data?: PartialMessage<SubaccountDeposit>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.stream.v1beta1.SubaccountDeposit";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "deposit", kind: "message", T: Deposit },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubaccountDeposit {
    return new SubaccountDeposit().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubaccountDeposit {
    return new SubaccountDeposit().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubaccountDeposit {
    return new SubaccountDeposit().fromJsonString(jsonString, options);
  }

  static equals(a: SubaccountDeposit | PlainMessage<SubaccountDeposit> | undefined, b: SubaccountDeposit | PlainMessage<SubaccountDeposit> | undefined): boolean {
    return proto3.util.equals(SubaccountDeposit, a, b);
  }
}

/**
 * @generated from message injective.stream.v1beta1.SpotOrderUpdate
 */
export class SpotOrderUpdate extends Message<SpotOrderUpdate> {
  /**
   * @generated from field: injective.stream.v1beta1.OrderUpdateStatus status = 1;
   */
  status = OrderUpdateStatus.Unspecified;

  /**
   * @generated from field: bytes order_hash = 2;
   */
  orderHash = new Uint8Array(0);

  /**
   * @generated from field: string cid = 3;
   */
  cid = "";

  /**
   * @generated from field: injective.stream.v1beta1.SpotOrder order = 4;
   */
  order?: SpotOrder;

  constructor(data?: PartialMessage<SpotOrderUpdate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.stream.v1beta1.SpotOrderUpdate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "status", kind: "enum", T: proto3.getEnumType(OrderUpdateStatus) },
    { no: 2, name: "order_hash", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "cid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "order", kind: "message", T: SpotOrder },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SpotOrderUpdate {
    return new SpotOrderUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SpotOrderUpdate {
    return new SpotOrderUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SpotOrderUpdate {
    return new SpotOrderUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: SpotOrderUpdate | PlainMessage<SpotOrderUpdate> | undefined, b: SpotOrderUpdate | PlainMessage<SpotOrderUpdate> | undefined): boolean {
    return proto3.util.equals(SpotOrderUpdate, a, b);
  }
}

/**
 * @generated from message injective.stream.v1beta1.SpotOrder
 */
export class SpotOrder extends Message<SpotOrder> {
  /**
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  /**
   * @generated from field: injective.exchange.v1beta1.SpotLimitOrder order = 2;
   */
  order?: SpotLimitOrder;

  constructor(data?: PartialMessage<SpotOrder>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.stream.v1beta1.SpotOrder";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "order", kind: "message", T: SpotLimitOrder },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SpotOrder {
    return new SpotOrder().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SpotOrder {
    return new SpotOrder().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SpotOrder {
    return new SpotOrder().fromJsonString(jsonString, options);
  }

  static equals(a: SpotOrder | PlainMessage<SpotOrder> | undefined, b: SpotOrder | PlainMessage<SpotOrder> | undefined): boolean {
    return proto3.util.equals(SpotOrder, a, b);
  }
}

/**
 * @generated from message injective.stream.v1beta1.DerivativeOrderUpdate
 */
export class DerivativeOrderUpdate extends Message<DerivativeOrderUpdate> {
  /**
   * @generated from field: injective.stream.v1beta1.OrderUpdateStatus status = 1;
   */
  status = OrderUpdateStatus.Unspecified;

  /**
   * @generated from field: bytes order_hash = 2;
   */
  orderHash = new Uint8Array(0);

  /**
   * @generated from field: string cid = 3;
   */
  cid = "";

  /**
   * @generated from field: injective.stream.v1beta1.DerivativeOrder order = 4;
   */
  order?: DerivativeOrder;

  constructor(data?: PartialMessage<DerivativeOrderUpdate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.stream.v1beta1.DerivativeOrderUpdate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "status", kind: "enum", T: proto3.getEnumType(OrderUpdateStatus) },
    { no: 2, name: "order_hash", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "cid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "order", kind: "message", T: DerivativeOrder },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DerivativeOrderUpdate {
    return new DerivativeOrderUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DerivativeOrderUpdate {
    return new DerivativeOrderUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DerivativeOrderUpdate {
    return new DerivativeOrderUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: DerivativeOrderUpdate | PlainMessage<DerivativeOrderUpdate> | undefined, b: DerivativeOrderUpdate | PlainMessage<DerivativeOrderUpdate> | undefined): boolean {
    return proto3.util.equals(DerivativeOrderUpdate, a, b);
  }
}

/**
 * @generated from message injective.stream.v1beta1.DerivativeOrder
 */
export class DerivativeOrder extends Message<DerivativeOrder> {
  /**
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  /**
   * @generated from field: injective.exchange.v1beta1.DerivativeLimitOrder order = 2;
   */
  order?: DerivativeLimitOrder;

  /**
   * @generated from field: bool is_market = 3;
   */
  isMarket = false;

  constructor(data?: PartialMessage<DerivativeOrder>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.stream.v1beta1.DerivativeOrder";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "order", kind: "message", T: DerivativeLimitOrder },
    { no: 3, name: "is_market", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DerivativeOrder {
    return new DerivativeOrder().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DerivativeOrder {
    return new DerivativeOrder().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DerivativeOrder {
    return new DerivativeOrder().fromJsonString(jsonString, options);
  }

  static equals(a: DerivativeOrder | PlainMessage<DerivativeOrder> | undefined, b: DerivativeOrder | PlainMessage<DerivativeOrder> | undefined): boolean {
    return proto3.util.equals(DerivativeOrder, a, b);
  }
}

/**
 * @generated from message injective.stream.v1beta1.Position
 */
export class Position extends Message<Position> {
  /**
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  /**
   * @generated from field: string subaccount_id = 2;
   */
  subaccountId = "";

  /**
   * @generated from field: bool isLong = 3;
   */
  isLong = false;

  /**
   * @generated from field: string quantity = 4;
   */
  quantity = "";

  /**
   * @generated from field: string entry_price = 5;
   */
  entryPrice = "";

  /**
   * @generated from field: string margin = 6;
   */
  margin = "";

  /**
   * @generated from field: string cumulative_funding_entry = 7;
   */
  cumulativeFundingEntry = "";

  constructor(data?: PartialMessage<Position>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.stream.v1beta1.Position";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "subaccount_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "isLong", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "quantity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "entry_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "margin", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "cumulative_funding_entry", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Position {
    return new Position().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Position {
    return new Position().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Position {
    return new Position().fromJsonString(jsonString, options);
  }

  static equals(a: Position | PlainMessage<Position> | undefined, b: Position | PlainMessage<Position> | undefined): boolean {
    return proto3.util.equals(Position, a, b);
  }
}

/**
 * @generated from message injective.stream.v1beta1.OraclePrice
 */
export class OraclePrice extends Message<OraclePrice> {
  /**
   * @generated from field: string symbol = 1;
   */
  symbol = "";

  /**
   * @generated from field: string price = 2;
   */
  price = "";

  /**
   * @generated from field: string type = 3;
   */
  type = "";

  constructor(data?: PartialMessage<OraclePrice>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.stream.v1beta1.OraclePrice";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "symbol", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OraclePrice {
    return new OraclePrice().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OraclePrice {
    return new OraclePrice().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OraclePrice {
    return new OraclePrice().fromJsonString(jsonString, options);
  }

  static equals(a: OraclePrice | PlainMessage<OraclePrice> | undefined, b: OraclePrice | PlainMessage<OraclePrice> | undefined): boolean {
    return proto3.util.equals(OraclePrice, a, b);
  }
}

/**
 * @generated from message injective.stream.v1beta1.SpotTrade
 */
export class SpotTrade extends Message<SpotTrade> {
  /**
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  /**
   * @generated from field: bool is_buy = 2;
   */
  isBuy = false;

  /**
   * @generated from field: string executionType = 3;
   */
  executionType = "";

  /**
   * @generated from field: string quantity = 4;
   */
  quantity = "";

  /**
   * @generated from field: string price = 5;
   */
  price = "";

  /**
   * bytes32 subaccount ID that executed the trade
   *
   * @generated from field: string subaccount_id = 6;
   */
  subaccountId = "";

  /**
   * @generated from field: string fee = 7;
   */
  fee = "";

  /**
   * @generated from field: bytes order_hash = 8;
   */
  orderHash = new Uint8Array(0);

  /**
   * @generated from field: string fee_recipient_address = 9;
   */
  feeRecipientAddress = "";

  /**
   * @generated from field: string cid = 10;
   */
  cid = "";

  /**
   * @generated from field: string trade_id = 11;
   */
  tradeId = "";

  constructor(data?: PartialMessage<SpotTrade>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.stream.v1beta1.SpotTrade";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "is_buy", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "executionType", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "quantity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "subaccount_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "fee", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "order_hash", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 9, name: "fee_recipient_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "cid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "trade_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SpotTrade {
    return new SpotTrade().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SpotTrade {
    return new SpotTrade().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SpotTrade {
    return new SpotTrade().fromJsonString(jsonString, options);
  }

  static equals(a: SpotTrade | PlainMessage<SpotTrade> | undefined, b: SpotTrade | PlainMessage<SpotTrade> | undefined): boolean {
    return proto3.util.equals(SpotTrade, a, b);
  }
}

/**
 * @generated from message injective.stream.v1beta1.DerivativeTrade
 */
export class DerivativeTrade extends Message<DerivativeTrade> {
  /**
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  /**
   * @generated from field: bool is_buy = 2;
   */
  isBuy = false;

  /**
   * @generated from field: string executionType = 3;
   */
  executionType = "";

  /**
   * @generated from field: string subaccount_id = 4;
   */
  subaccountId = "";

  /**
   * @generated from field: injective.exchange.v1beta1.PositionDelta position_delta = 5;
   */
  positionDelta?: PositionDelta;

  /**
   * @generated from field: string payout = 6;
   */
  payout = "";

  /**
   * @generated from field: string fee = 7;
   */
  fee = "";

  /**
   * @generated from field: string order_hash = 8;
   */
  orderHash = "";

  /**
   * @generated from field: string fee_recipient_address = 9;
   */
  feeRecipientAddress = "";

  /**
   * @generated from field: string cid = 10;
   */
  cid = "";

  /**
   * @generated from field: string trade_id = 11;
   */
  tradeId = "";

  constructor(data?: PartialMessage<DerivativeTrade>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.stream.v1beta1.DerivativeTrade";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "is_buy", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "executionType", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "subaccount_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "position_delta", kind: "message", T: PositionDelta },
    { no: 6, name: "payout", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "fee", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "order_hash", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "fee_recipient_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "cid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "trade_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DerivativeTrade {
    return new DerivativeTrade().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DerivativeTrade {
    return new DerivativeTrade().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DerivativeTrade {
    return new DerivativeTrade().fromJsonString(jsonString, options);
  }

  static equals(a: DerivativeTrade | PlainMessage<DerivativeTrade> | undefined, b: DerivativeTrade | PlainMessage<DerivativeTrade> | undefined): boolean {
    return proto3.util.equals(DerivativeTrade, a, b);
  }
}

/**
 * @generated from message injective.stream.v1beta1.TradesFilter
 */
export class TradesFilter extends Message<TradesFilter> {
  /**
   * @generated from field: repeated string subaccount_ids = 1;
   */
  subaccountIds: string[] = [];

  /**
   * @generated from field: repeated string market_ids = 2;
   */
  marketIds: string[] = [];

  constructor(data?: PartialMessage<TradesFilter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.stream.v1beta1.TradesFilter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "subaccount_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "market_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TradesFilter {
    return new TradesFilter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TradesFilter {
    return new TradesFilter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TradesFilter {
    return new TradesFilter().fromJsonString(jsonString, options);
  }

  static equals(a: TradesFilter | PlainMessage<TradesFilter> | undefined, b: TradesFilter | PlainMessage<TradesFilter> | undefined): boolean {
    return proto3.util.equals(TradesFilter, a, b);
  }
}

/**
 * @generated from message injective.stream.v1beta1.PositionsFilter
 */
export class PositionsFilter extends Message<PositionsFilter> {
  /**
   * @generated from field: repeated string subaccount_ids = 1;
   */
  subaccountIds: string[] = [];

  /**
   * @generated from field: repeated string market_ids = 2;
   */
  marketIds: string[] = [];

  constructor(data?: PartialMessage<PositionsFilter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.stream.v1beta1.PositionsFilter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "subaccount_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "market_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PositionsFilter {
    return new PositionsFilter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PositionsFilter {
    return new PositionsFilter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PositionsFilter {
    return new PositionsFilter().fromJsonString(jsonString, options);
  }

  static equals(a: PositionsFilter | PlainMessage<PositionsFilter> | undefined, b: PositionsFilter | PlainMessage<PositionsFilter> | undefined): boolean {
    return proto3.util.equals(PositionsFilter, a, b);
  }
}

/**
 * @generated from message injective.stream.v1beta1.OrdersFilter
 */
export class OrdersFilter extends Message<OrdersFilter> {
  /**
   * @generated from field: repeated string subaccount_ids = 1;
   */
  subaccountIds: string[] = [];

  /**
   * @generated from field: repeated string market_ids = 2;
   */
  marketIds: string[] = [];

  constructor(data?: PartialMessage<OrdersFilter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.stream.v1beta1.OrdersFilter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "subaccount_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "market_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OrdersFilter {
    return new OrdersFilter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OrdersFilter {
    return new OrdersFilter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OrdersFilter {
    return new OrdersFilter().fromJsonString(jsonString, options);
  }

  static equals(a: OrdersFilter | PlainMessage<OrdersFilter> | undefined, b: OrdersFilter | PlainMessage<OrdersFilter> | undefined): boolean {
    return proto3.util.equals(OrdersFilter, a, b);
  }
}

/**
 * @generated from message injective.stream.v1beta1.OrderbookFilter
 */
export class OrderbookFilter extends Message<OrderbookFilter> {
  /**
   * @generated from field: repeated string market_ids = 1;
   */
  marketIds: string[] = [];

  constructor(data?: PartialMessage<OrderbookFilter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.stream.v1beta1.OrderbookFilter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OrderbookFilter {
    return new OrderbookFilter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OrderbookFilter {
    return new OrderbookFilter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OrderbookFilter {
    return new OrderbookFilter().fromJsonString(jsonString, options);
  }

  static equals(a: OrderbookFilter | PlainMessage<OrderbookFilter> | undefined, b: OrderbookFilter | PlainMessage<OrderbookFilter> | undefined): boolean {
    return proto3.util.equals(OrderbookFilter, a, b);
  }
}

/**
 * @generated from message injective.stream.v1beta1.BankBalancesFilter
 */
export class BankBalancesFilter extends Message<BankBalancesFilter> {
  /**
   * @generated from field: repeated string accounts = 1;
   */
  accounts: string[] = [];

  constructor(data?: PartialMessage<BankBalancesFilter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.stream.v1beta1.BankBalancesFilter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "accounts", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BankBalancesFilter {
    return new BankBalancesFilter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BankBalancesFilter {
    return new BankBalancesFilter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BankBalancesFilter {
    return new BankBalancesFilter().fromJsonString(jsonString, options);
  }

  static equals(a: BankBalancesFilter | PlainMessage<BankBalancesFilter> | undefined, b: BankBalancesFilter | PlainMessage<BankBalancesFilter> | undefined): boolean {
    return proto3.util.equals(BankBalancesFilter, a, b);
  }
}

/**
 * @generated from message injective.stream.v1beta1.SubaccountDepositsFilter
 */
export class SubaccountDepositsFilter extends Message<SubaccountDepositsFilter> {
  /**
   * @generated from field: repeated string subaccount_ids = 1;
   */
  subaccountIds: string[] = [];

  constructor(data?: PartialMessage<SubaccountDepositsFilter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.stream.v1beta1.SubaccountDepositsFilter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "subaccount_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubaccountDepositsFilter {
    return new SubaccountDepositsFilter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubaccountDepositsFilter {
    return new SubaccountDepositsFilter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubaccountDepositsFilter {
    return new SubaccountDepositsFilter().fromJsonString(jsonString, options);
  }

  static equals(a: SubaccountDepositsFilter | PlainMessage<SubaccountDepositsFilter> | undefined, b: SubaccountDepositsFilter | PlainMessage<SubaccountDepositsFilter> | undefined): boolean {
    return proto3.util.equals(SubaccountDepositsFilter, a, b);
  }
}

/**
 * @generated from message injective.stream.v1beta1.OraclePriceFilter
 */
export class OraclePriceFilter extends Message<OraclePriceFilter> {
  /**
   * @generated from field: repeated string symbol = 1;
   */
  symbol: string[] = [];

  constructor(data?: PartialMessage<OraclePriceFilter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.stream.v1beta1.OraclePriceFilter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "symbol", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OraclePriceFilter {
    return new OraclePriceFilter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OraclePriceFilter {
    return new OraclePriceFilter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OraclePriceFilter {
    return new OraclePriceFilter().fromJsonString(jsonString, options);
  }

  static equals(a: OraclePriceFilter | PlainMessage<OraclePriceFilter> | undefined, b: OraclePriceFilter | PlainMessage<OraclePriceFilter> | undefined): boolean {
    return proto3.util.equals(OraclePriceFilter, a, b);
  }
}

