// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file kava/earn/v1beta1/vault.proto (package kava.earn.v1beta1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { StrategyType } from "./strategy_pb.js";

/**
 * AllowedVault is a vault that is allowed to be created. These can be
 * modified via parameter governance.
 *
 * @generated from message kava.earn.v1beta1.AllowedVault
 */
export class AllowedVault extends Message<AllowedVault> {
  /**
   * Denom is the only supported denomination of the vault for deposits and withdrawals.
   *
   * @generated from field: string denom = 1;
   */
  denom = "";

  /**
   * VaultStrategy is the strategy used for this vault.
   *
   * @generated from field: repeated kava.earn.v1beta1.StrategyType strategies = 2;
   */
  strategies: StrategyType[] = [];

  /**
   * IsPrivateVault is true if the vault only allows depositors contained in
   * AllowedDepositors.
   *
   * @generated from field: bool is_private_vault = 3;
   */
  isPrivateVault = false;

  /**
   * AllowedDepositors is a list of addresses that are allowed to deposit to
   * this vault if IsPrivateVault is true. Addresses not contained in this list
   * are not allowed to deposit into this vault. If IsPrivateVault is false,
   * this should be empty and ignored.
   *
   * @generated from field: repeated bytes allowed_depositors = 4;
   */
  allowedDepositors: Uint8Array[] = [];

  constructor(data?: PartialMessage<AllowedVault>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "kava.earn.v1beta1.AllowedVault";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "strategies", kind: "enum", T: proto3.getEnumType(StrategyType), repeated: true },
    { no: 3, name: "is_private_vault", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "allowed_depositors", kind: "scalar", T: 12 /* ScalarType.BYTES */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AllowedVault {
    return new AllowedVault().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AllowedVault {
    return new AllowedVault().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AllowedVault {
    return new AllowedVault().fromJsonString(jsonString, options);
  }

  static equals(a: AllowedVault | PlainMessage<AllowedVault> | undefined, b: AllowedVault | PlainMessage<AllowedVault> | undefined): boolean {
    return proto3.util.equals(AllowedVault, a, b);
  }
}

/**
 * VaultRecord is the state of a vault.
 *
 * @generated from message kava.earn.v1beta1.VaultRecord
 */
export class VaultRecord extends Message<VaultRecord> {
  /**
   * TotalShares is the total distributed number of shares in the vault.
   *
   * @generated from field: kava.earn.v1beta1.VaultShare total_shares = 1;
   */
  totalShares?: VaultShare;

  constructor(data?: PartialMessage<VaultRecord>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "kava.earn.v1beta1.VaultRecord";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "total_shares", kind: "message", T: VaultShare },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VaultRecord {
    return new VaultRecord().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VaultRecord {
    return new VaultRecord().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VaultRecord {
    return new VaultRecord().fromJsonString(jsonString, options);
  }

  static equals(a: VaultRecord | PlainMessage<VaultRecord> | undefined, b: VaultRecord | PlainMessage<VaultRecord> | undefined): boolean {
    return proto3.util.equals(VaultRecord, a, b);
  }
}

/**
 * VaultShareRecord defines the vault shares owned by a depositor.
 *
 * @generated from message kava.earn.v1beta1.VaultShareRecord
 */
export class VaultShareRecord extends Message<VaultShareRecord> {
  /**
   * Depositor represents the owner of the shares
   *
   * @generated from field: bytes depositor = 1;
   */
  depositor = new Uint8Array(0);

  /**
   * Shares represent the vault shares owned by the depositor.
   *
   * @generated from field: repeated kava.earn.v1beta1.VaultShare shares = 2;
   */
  shares: VaultShare[] = [];

  constructor(data?: PartialMessage<VaultShareRecord>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "kava.earn.v1beta1.VaultShareRecord";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "depositor", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "shares", kind: "message", T: VaultShare, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VaultShareRecord {
    return new VaultShareRecord().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VaultShareRecord {
    return new VaultShareRecord().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VaultShareRecord {
    return new VaultShareRecord().fromJsonString(jsonString, options);
  }

  static equals(a: VaultShareRecord | PlainMessage<VaultShareRecord> | undefined, b: VaultShareRecord | PlainMessage<VaultShareRecord> | undefined): boolean {
    return proto3.util.equals(VaultShareRecord, a, b);
  }
}

/**
 * VaultShare defines shares of a vault owned by a depositor.
 *
 * @generated from message kava.earn.v1beta1.VaultShare
 */
export class VaultShare extends Message<VaultShare> {
  /**
   * @generated from field: string denom = 1;
   */
  denom = "";

  /**
   * @generated from field: string amount = 2;
   */
  amount = "";

  constructor(data?: PartialMessage<VaultShare>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "kava.earn.v1beta1.VaultShare";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VaultShare {
    return new VaultShare().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VaultShare {
    return new VaultShare().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VaultShare {
    return new VaultShare().fromJsonString(jsonString, options);
  }

  static equals(a: VaultShare | PlainMessage<VaultShare> | undefined, b: VaultShare | PlainMessage<VaultShare> | undefined): boolean {
    return proto3.util.equals(VaultShare, a, b);
  }
}

