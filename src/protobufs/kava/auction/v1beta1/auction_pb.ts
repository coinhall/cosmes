// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file kava/auction/v1beta1/auction.proto (package kava.auction.v1beta1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64, Timestamp } from "@bufbuild/protobuf";
import { Coin } from "../../../cosmos/base/v1beta1/coin_pb.js";

/**
 * BaseAuction defines common attributes of all auctions
 *
 * @generated from message kava.auction.v1beta1.BaseAuction
 */
export class BaseAuction extends Message<BaseAuction> {
  /**
   * @generated from field: uint64 id = 1;
   */
  id = protoInt64.zero;

  /**
   * @generated from field: string initiator = 2;
   */
  initiator = "";

  /**
   * @generated from field: cosmos.base.v1beta1.Coin lot = 3;
   */
  lot?: Coin;

  /**
   * @generated from field: bytes bidder = 4;
   */
  bidder = new Uint8Array(0);

  /**
   * @generated from field: cosmos.base.v1beta1.Coin bid = 5;
   */
  bid?: Coin;

  /**
   * @generated from field: bool has_received_bids = 6;
   */
  hasReceivedBids = false;

  /**
   * @generated from field: google.protobuf.Timestamp end_time = 7;
   */
  endTime?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp max_end_time = 8;
   */
  maxEndTime?: Timestamp;

  constructor(data?: PartialMessage<BaseAuction>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "kava.auction.v1beta1.BaseAuction";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "initiator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "lot", kind: "message", T: Coin },
    { no: 4, name: "bidder", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 5, name: "bid", kind: "message", T: Coin },
    { no: 6, name: "has_received_bids", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "end_time", kind: "message", T: Timestamp },
    { no: 8, name: "max_end_time", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BaseAuction {
    return new BaseAuction().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BaseAuction {
    return new BaseAuction().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BaseAuction {
    return new BaseAuction().fromJsonString(jsonString, options);
  }

  static equals(a: BaseAuction | PlainMessage<BaseAuction> | undefined, b: BaseAuction | PlainMessage<BaseAuction> | undefined): boolean {
    return proto3.util.equals(BaseAuction, a, b);
  }
}

/**
 * SurplusAuction is a forward auction that burns what it receives from bids.
 * It is normally used to sell off excess pegged asset acquired by the CDP system.
 *
 * @generated from message kava.auction.v1beta1.SurplusAuction
 */
export class SurplusAuction extends Message<SurplusAuction> {
  /**
   * @generated from field: kava.auction.v1beta1.BaseAuction base_auction = 1;
   */
  baseAuction?: BaseAuction;

  constructor(data?: PartialMessage<SurplusAuction>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "kava.auction.v1beta1.SurplusAuction";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "base_auction", kind: "message", T: BaseAuction },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SurplusAuction {
    return new SurplusAuction().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SurplusAuction {
    return new SurplusAuction().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SurplusAuction {
    return new SurplusAuction().fromJsonString(jsonString, options);
  }

  static equals(a: SurplusAuction | PlainMessage<SurplusAuction> | undefined, b: SurplusAuction | PlainMessage<SurplusAuction> | undefined): boolean {
    return proto3.util.equals(SurplusAuction, a, b);
  }
}

/**
 * DebtAuction is a reverse auction that mints what it pays out.
 * It is normally used to acquire pegged asset to cover the CDP system's debts that were not covered by selling
 * collateral.
 *
 * @generated from message kava.auction.v1beta1.DebtAuction
 */
export class DebtAuction extends Message<DebtAuction> {
  /**
   * @generated from field: kava.auction.v1beta1.BaseAuction base_auction = 1;
   */
  baseAuction?: BaseAuction;

  /**
   * @generated from field: cosmos.base.v1beta1.Coin corresponding_debt = 2;
   */
  correspondingDebt?: Coin;

  constructor(data?: PartialMessage<DebtAuction>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "kava.auction.v1beta1.DebtAuction";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "base_auction", kind: "message", T: BaseAuction },
    { no: 2, name: "corresponding_debt", kind: "message", T: Coin },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DebtAuction {
    return new DebtAuction().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DebtAuction {
    return new DebtAuction().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DebtAuction {
    return new DebtAuction().fromJsonString(jsonString, options);
  }

  static equals(a: DebtAuction | PlainMessage<DebtAuction> | undefined, b: DebtAuction | PlainMessage<DebtAuction> | undefined): boolean {
    return proto3.util.equals(DebtAuction, a, b);
  }
}

/**
 * CollateralAuction is a two phase auction.
 * Initially, in forward auction phase, bids can be placed up to a max bid.
 * Then it switches to a reverse auction phase, where the initial amount up for auction is bid down.
 * Unsold Lot is sent to LotReturns, being divided among the addresses by weight.
 * Collateral auctions are normally used to sell off collateral seized from CDPs.
 *
 * @generated from message kava.auction.v1beta1.CollateralAuction
 */
export class CollateralAuction extends Message<CollateralAuction> {
  /**
   * @generated from field: kava.auction.v1beta1.BaseAuction base_auction = 1;
   */
  baseAuction?: BaseAuction;

  /**
   * @generated from field: cosmos.base.v1beta1.Coin corresponding_debt = 2;
   */
  correspondingDebt?: Coin;

  /**
   * @generated from field: cosmos.base.v1beta1.Coin max_bid = 3;
   */
  maxBid?: Coin;

  /**
   * @generated from field: kava.auction.v1beta1.WeightedAddresses lot_returns = 4;
   */
  lotReturns?: WeightedAddresses;

  constructor(data?: PartialMessage<CollateralAuction>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "kava.auction.v1beta1.CollateralAuction";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "base_auction", kind: "message", T: BaseAuction },
    { no: 2, name: "corresponding_debt", kind: "message", T: Coin },
    { no: 3, name: "max_bid", kind: "message", T: Coin },
    { no: 4, name: "lot_returns", kind: "message", T: WeightedAddresses },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CollateralAuction {
    return new CollateralAuction().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CollateralAuction {
    return new CollateralAuction().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CollateralAuction {
    return new CollateralAuction().fromJsonString(jsonString, options);
  }

  static equals(a: CollateralAuction | PlainMessage<CollateralAuction> | undefined, b: CollateralAuction | PlainMessage<CollateralAuction> | undefined): boolean {
    return proto3.util.equals(CollateralAuction, a, b);
  }
}

/**
 * WeightedAddresses is a type for storing some addresses and associated weights.
 *
 * @generated from message kava.auction.v1beta1.WeightedAddresses
 */
export class WeightedAddresses extends Message<WeightedAddresses> {
  /**
   * @generated from field: repeated bytes addresses = 1;
   */
  addresses: Uint8Array[] = [];

  /**
   * @generated from field: repeated bytes weights = 2;
   */
  weights: Uint8Array[] = [];

  constructor(data?: PartialMessage<WeightedAddresses>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "kava.auction.v1beta1.WeightedAddresses";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "addresses", kind: "scalar", T: 12 /* ScalarType.BYTES */, repeated: true },
    { no: 2, name: "weights", kind: "scalar", T: 12 /* ScalarType.BYTES */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WeightedAddresses {
    return new WeightedAddresses().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WeightedAddresses {
    return new WeightedAddresses().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WeightedAddresses {
    return new WeightedAddresses().fromJsonString(jsonString, options);
  }

  static equals(a: WeightedAddresses | PlainMessage<WeightedAddresses> | undefined, b: WeightedAddresses | PlainMessage<WeightedAddresses> | undefined): boolean {
    return proto3.util.equals(WeightedAddresses, a, b);
  }
}

