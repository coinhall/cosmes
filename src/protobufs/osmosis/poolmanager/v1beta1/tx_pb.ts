// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file osmosis/poolmanager/v1beta1/tx.proto (package osmosis.poolmanager.v1beta1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { SwapAmountInRoute, SwapAmountInSplitRoute, SwapAmountOutRoute, SwapAmountOutSplitRoute } from "./swap_route_pb.js";
import { Coin } from "../../../cosmos/base/v1beta1/coin_pb.js";

/**
 * ===================== MsgSwapExactAmountIn
 *
 * @generated from message osmosis.poolmanager.v1beta1.MsgSwapExactAmountIn
 */
export class MsgSwapExactAmountIn extends Message<MsgSwapExactAmountIn> {
  /**
   * @generated from field: string sender = 1;
   */
  sender = "";

  /**
   * @generated from field: repeated osmosis.poolmanager.v1beta1.SwapAmountInRoute routes = 2;
   */
  routes: SwapAmountInRoute[] = [];

  /**
   * @generated from field: cosmos.base.v1beta1.Coin token_in = 3;
   */
  tokenIn?: Coin;

  /**
   * @generated from field: string token_out_min_amount = 4;
   */
  tokenOutMinAmount = "";

  constructor(data?: PartialMessage<MsgSwapExactAmountIn>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "osmosis.poolmanager.v1beta1.MsgSwapExactAmountIn";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sender", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "routes", kind: "message", T: SwapAmountInRoute, repeated: true },
    { no: 3, name: "token_in", kind: "message", T: Coin },
    { no: 4, name: "token_out_min_amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSwapExactAmountIn {
    return new MsgSwapExactAmountIn().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSwapExactAmountIn {
    return new MsgSwapExactAmountIn().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSwapExactAmountIn {
    return new MsgSwapExactAmountIn().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSwapExactAmountIn | PlainMessage<MsgSwapExactAmountIn> | undefined, b: MsgSwapExactAmountIn | PlainMessage<MsgSwapExactAmountIn> | undefined): boolean {
    return proto3.util.equals(MsgSwapExactAmountIn, a, b);
  }
}

/**
 * @generated from message osmosis.poolmanager.v1beta1.MsgSwapExactAmountInResponse
 */
export class MsgSwapExactAmountInResponse extends Message<MsgSwapExactAmountInResponse> {
  /**
   * @generated from field: string token_out_amount = 1;
   */
  tokenOutAmount = "";

  constructor(data?: PartialMessage<MsgSwapExactAmountInResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "osmosis.poolmanager.v1beta1.MsgSwapExactAmountInResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "token_out_amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSwapExactAmountInResponse {
    return new MsgSwapExactAmountInResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSwapExactAmountInResponse {
    return new MsgSwapExactAmountInResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSwapExactAmountInResponse {
    return new MsgSwapExactAmountInResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSwapExactAmountInResponse | PlainMessage<MsgSwapExactAmountInResponse> | undefined, b: MsgSwapExactAmountInResponse | PlainMessage<MsgSwapExactAmountInResponse> | undefined): boolean {
    return proto3.util.equals(MsgSwapExactAmountInResponse, a, b);
  }
}

/**
 * ===================== MsgSplitRouteSwapExactAmountIn
 *
 * @generated from message osmosis.poolmanager.v1beta1.MsgSplitRouteSwapExactAmountIn
 */
export class MsgSplitRouteSwapExactAmountIn extends Message<MsgSplitRouteSwapExactAmountIn> {
  /**
   * @generated from field: string sender = 1;
   */
  sender = "";

  /**
   * @generated from field: repeated osmosis.poolmanager.v1beta1.SwapAmountInSplitRoute routes = 2;
   */
  routes: SwapAmountInSplitRoute[] = [];

  /**
   * @generated from field: string token_in_denom = 3;
   */
  tokenInDenom = "";

  /**
   * @generated from field: string token_out_min_amount = 4;
   */
  tokenOutMinAmount = "";

  constructor(data?: PartialMessage<MsgSplitRouteSwapExactAmountIn>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "osmosis.poolmanager.v1beta1.MsgSplitRouteSwapExactAmountIn";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sender", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "routes", kind: "message", T: SwapAmountInSplitRoute, repeated: true },
    { no: 3, name: "token_in_denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "token_out_min_amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSplitRouteSwapExactAmountIn {
    return new MsgSplitRouteSwapExactAmountIn().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSplitRouteSwapExactAmountIn {
    return new MsgSplitRouteSwapExactAmountIn().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSplitRouteSwapExactAmountIn {
    return new MsgSplitRouteSwapExactAmountIn().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSplitRouteSwapExactAmountIn | PlainMessage<MsgSplitRouteSwapExactAmountIn> | undefined, b: MsgSplitRouteSwapExactAmountIn | PlainMessage<MsgSplitRouteSwapExactAmountIn> | undefined): boolean {
    return proto3.util.equals(MsgSplitRouteSwapExactAmountIn, a, b);
  }
}

/**
 * @generated from message osmosis.poolmanager.v1beta1.MsgSplitRouteSwapExactAmountInResponse
 */
export class MsgSplitRouteSwapExactAmountInResponse extends Message<MsgSplitRouteSwapExactAmountInResponse> {
  /**
   * @generated from field: string token_out_amount = 1;
   */
  tokenOutAmount = "";

  constructor(data?: PartialMessage<MsgSplitRouteSwapExactAmountInResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "osmosis.poolmanager.v1beta1.MsgSplitRouteSwapExactAmountInResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "token_out_amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSplitRouteSwapExactAmountInResponse {
    return new MsgSplitRouteSwapExactAmountInResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSplitRouteSwapExactAmountInResponse {
    return new MsgSplitRouteSwapExactAmountInResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSplitRouteSwapExactAmountInResponse {
    return new MsgSplitRouteSwapExactAmountInResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSplitRouteSwapExactAmountInResponse | PlainMessage<MsgSplitRouteSwapExactAmountInResponse> | undefined, b: MsgSplitRouteSwapExactAmountInResponse | PlainMessage<MsgSplitRouteSwapExactAmountInResponse> | undefined): boolean {
    return proto3.util.equals(MsgSplitRouteSwapExactAmountInResponse, a, b);
  }
}

/**
 * ===================== MsgSwapExactAmountOut
 *
 * @generated from message osmosis.poolmanager.v1beta1.MsgSwapExactAmountOut
 */
export class MsgSwapExactAmountOut extends Message<MsgSwapExactAmountOut> {
  /**
   * @generated from field: string sender = 1;
   */
  sender = "";

  /**
   * @generated from field: repeated osmosis.poolmanager.v1beta1.SwapAmountOutRoute routes = 2;
   */
  routes: SwapAmountOutRoute[] = [];

  /**
   * @generated from field: string token_in_max_amount = 3;
   */
  tokenInMaxAmount = "";

  /**
   * @generated from field: cosmos.base.v1beta1.Coin token_out = 4;
   */
  tokenOut?: Coin;

  constructor(data?: PartialMessage<MsgSwapExactAmountOut>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "osmosis.poolmanager.v1beta1.MsgSwapExactAmountOut";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sender", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "routes", kind: "message", T: SwapAmountOutRoute, repeated: true },
    { no: 3, name: "token_in_max_amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "token_out", kind: "message", T: Coin },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSwapExactAmountOut {
    return new MsgSwapExactAmountOut().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSwapExactAmountOut {
    return new MsgSwapExactAmountOut().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSwapExactAmountOut {
    return new MsgSwapExactAmountOut().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSwapExactAmountOut | PlainMessage<MsgSwapExactAmountOut> | undefined, b: MsgSwapExactAmountOut | PlainMessage<MsgSwapExactAmountOut> | undefined): boolean {
    return proto3.util.equals(MsgSwapExactAmountOut, a, b);
  }
}

/**
 * @generated from message osmosis.poolmanager.v1beta1.MsgSwapExactAmountOutResponse
 */
export class MsgSwapExactAmountOutResponse extends Message<MsgSwapExactAmountOutResponse> {
  /**
   * @generated from field: string token_in_amount = 1;
   */
  tokenInAmount = "";

  constructor(data?: PartialMessage<MsgSwapExactAmountOutResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "osmosis.poolmanager.v1beta1.MsgSwapExactAmountOutResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "token_in_amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSwapExactAmountOutResponse {
    return new MsgSwapExactAmountOutResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSwapExactAmountOutResponse {
    return new MsgSwapExactAmountOutResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSwapExactAmountOutResponse {
    return new MsgSwapExactAmountOutResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSwapExactAmountOutResponse | PlainMessage<MsgSwapExactAmountOutResponse> | undefined, b: MsgSwapExactAmountOutResponse | PlainMessage<MsgSwapExactAmountOutResponse> | undefined): boolean {
    return proto3.util.equals(MsgSwapExactAmountOutResponse, a, b);
  }
}

/**
 * ===================== MsgSplitRouteSwapExactAmountOut
 *
 * @generated from message osmosis.poolmanager.v1beta1.MsgSplitRouteSwapExactAmountOut
 */
export class MsgSplitRouteSwapExactAmountOut extends Message<MsgSplitRouteSwapExactAmountOut> {
  /**
   * @generated from field: string sender = 1;
   */
  sender = "";

  /**
   * @generated from field: repeated osmosis.poolmanager.v1beta1.SwapAmountOutSplitRoute routes = 2;
   */
  routes: SwapAmountOutSplitRoute[] = [];

  /**
   * @generated from field: string token_out_denom = 3;
   */
  tokenOutDenom = "";

  /**
   * @generated from field: string token_in_max_amount = 4;
   */
  tokenInMaxAmount = "";

  constructor(data?: PartialMessage<MsgSplitRouteSwapExactAmountOut>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "osmosis.poolmanager.v1beta1.MsgSplitRouteSwapExactAmountOut";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sender", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "routes", kind: "message", T: SwapAmountOutSplitRoute, repeated: true },
    { no: 3, name: "token_out_denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "token_in_max_amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSplitRouteSwapExactAmountOut {
    return new MsgSplitRouteSwapExactAmountOut().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSplitRouteSwapExactAmountOut {
    return new MsgSplitRouteSwapExactAmountOut().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSplitRouteSwapExactAmountOut {
    return new MsgSplitRouteSwapExactAmountOut().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSplitRouteSwapExactAmountOut | PlainMessage<MsgSplitRouteSwapExactAmountOut> | undefined, b: MsgSplitRouteSwapExactAmountOut | PlainMessage<MsgSplitRouteSwapExactAmountOut> | undefined): boolean {
    return proto3.util.equals(MsgSplitRouteSwapExactAmountOut, a, b);
  }
}

/**
 * @generated from message osmosis.poolmanager.v1beta1.MsgSplitRouteSwapExactAmountOutResponse
 */
export class MsgSplitRouteSwapExactAmountOutResponse extends Message<MsgSplitRouteSwapExactAmountOutResponse> {
  /**
   * @generated from field: string token_in_amount = 1;
   */
  tokenInAmount = "";

  constructor(data?: PartialMessage<MsgSplitRouteSwapExactAmountOutResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "osmosis.poolmanager.v1beta1.MsgSplitRouteSwapExactAmountOutResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "token_in_amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSplitRouteSwapExactAmountOutResponse {
    return new MsgSplitRouteSwapExactAmountOutResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSplitRouteSwapExactAmountOutResponse {
    return new MsgSplitRouteSwapExactAmountOutResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSplitRouteSwapExactAmountOutResponse {
    return new MsgSplitRouteSwapExactAmountOutResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSplitRouteSwapExactAmountOutResponse | PlainMessage<MsgSplitRouteSwapExactAmountOutResponse> | undefined, b: MsgSplitRouteSwapExactAmountOutResponse | PlainMessage<MsgSplitRouteSwapExactAmountOutResponse> | undefined): boolean {
    return proto3.util.equals(MsgSplitRouteSwapExactAmountOutResponse, a, b);
  }
}

/**
 * ===================== MsgSetDenomPairTakerFee
 *
 * @generated from message osmosis.poolmanager.v1beta1.MsgSetDenomPairTakerFee
 */
export class MsgSetDenomPairTakerFee extends Message<MsgSetDenomPairTakerFee> {
  /**
   * @generated from field: string sender = 1;
   */
  sender = "";

  /**
   * @generated from field: repeated osmosis.poolmanager.v1beta1.DenomPairTakerFee denom_pair_taker_fee = 2;
   */
  denomPairTakerFee: DenomPairTakerFee[] = [];

  constructor(data?: PartialMessage<MsgSetDenomPairTakerFee>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "osmosis.poolmanager.v1beta1.MsgSetDenomPairTakerFee";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sender", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "denom_pair_taker_fee", kind: "message", T: DenomPairTakerFee, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSetDenomPairTakerFee {
    return new MsgSetDenomPairTakerFee().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSetDenomPairTakerFee {
    return new MsgSetDenomPairTakerFee().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSetDenomPairTakerFee {
    return new MsgSetDenomPairTakerFee().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSetDenomPairTakerFee | PlainMessage<MsgSetDenomPairTakerFee> | undefined, b: MsgSetDenomPairTakerFee | PlainMessage<MsgSetDenomPairTakerFee> | undefined): boolean {
    return proto3.util.equals(MsgSetDenomPairTakerFee, a, b);
  }
}

/**
 * @generated from message osmosis.poolmanager.v1beta1.MsgSetDenomPairTakerFeeResponse
 */
export class MsgSetDenomPairTakerFeeResponse extends Message<MsgSetDenomPairTakerFeeResponse> {
  /**
   * @generated from field: bool success = 1;
   */
  success = false;

  constructor(data?: PartialMessage<MsgSetDenomPairTakerFeeResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "osmosis.poolmanager.v1beta1.MsgSetDenomPairTakerFeeResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "success", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSetDenomPairTakerFeeResponse {
    return new MsgSetDenomPairTakerFeeResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSetDenomPairTakerFeeResponse {
    return new MsgSetDenomPairTakerFeeResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSetDenomPairTakerFeeResponse {
    return new MsgSetDenomPairTakerFeeResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSetDenomPairTakerFeeResponse | PlainMessage<MsgSetDenomPairTakerFeeResponse> | undefined, b: MsgSetDenomPairTakerFeeResponse | PlainMessage<MsgSetDenomPairTakerFeeResponse> | undefined): boolean {
    return proto3.util.equals(MsgSetDenomPairTakerFeeResponse, a, b);
  }
}

/**
 * @generated from message osmosis.poolmanager.v1beta1.DenomPairTakerFee
 */
export class DenomPairTakerFee extends Message<DenomPairTakerFee> {
  /**
   * denom0 and denom1 get automatically lexigographically sorted
   * when being stored, so the order of input here does not matter.
   *
   * @generated from field: string denom0 = 1;
   */
  denom0 = "";

  /**
   * @generated from field: string denom1 = 2;
   */
  denom1 = "";

  /**
   * @generated from field: string taker_fee = 3;
   */
  takerFee = "";

  constructor(data?: PartialMessage<DenomPairTakerFee>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "osmosis.poolmanager.v1beta1.DenomPairTakerFee";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "denom0", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "denom1", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "taker_fee", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DenomPairTakerFee {
    return new DenomPairTakerFee().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DenomPairTakerFee {
    return new DenomPairTakerFee().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DenomPairTakerFee {
    return new DenomPairTakerFee().fromJsonString(jsonString, options);
  }

  static equals(a: DenomPairTakerFee | PlainMessage<DenomPairTakerFee> | undefined, b: DenomPairTakerFee | PlainMessage<DenomPairTakerFee> | undefined): boolean {
    return proto3.util.equals(DenomPairTakerFee, a, b);
  }
}

