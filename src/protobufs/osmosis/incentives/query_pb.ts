// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file osmosis/incentives/query.proto (package osmosis.incentives, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Duration, Message, proto3, protoInt64 } from "@bufbuild/protobuf";
import { Coin } from "../../cosmos/base/v1beta1/coin_pb.js";
import { Gauge } from "./gauge_pb.js";
import { PageRequest, PageResponse } from "../../cosmos/base/query/v1beta1/pagination_pb.js";
import { Group, GroupsWithGauge } from "./group_pb.js";

/**
 * @generated from message osmosis.incentives.ModuleToDistributeCoinsRequest
 */
export class ModuleToDistributeCoinsRequest extends Message<ModuleToDistributeCoinsRequest> {
  constructor(data?: PartialMessage<ModuleToDistributeCoinsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "osmosis.incentives.ModuleToDistributeCoinsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ModuleToDistributeCoinsRequest {
    return new ModuleToDistributeCoinsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ModuleToDistributeCoinsRequest {
    return new ModuleToDistributeCoinsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ModuleToDistributeCoinsRequest {
    return new ModuleToDistributeCoinsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ModuleToDistributeCoinsRequest | PlainMessage<ModuleToDistributeCoinsRequest> | undefined, b: ModuleToDistributeCoinsRequest | PlainMessage<ModuleToDistributeCoinsRequest> | undefined): boolean {
    return proto3.util.equals(ModuleToDistributeCoinsRequest, a, b);
  }
}

/**
 * @generated from message osmosis.incentives.ModuleToDistributeCoinsResponse
 */
export class ModuleToDistributeCoinsResponse extends Message<ModuleToDistributeCoinsResponse> {
  /**
   * Coins that have yet to be distributed
   *
   * @generated from field: repeated cosmos.base.v1beta1.Coin coins = 1;
   */
  coins: Coin[] = [];

  constructor(data?: PartialMessage<ModuleToDistributeCoinsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "osmosis.incentives.ModuleToDistributeCoinsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "coins", kind: "message", T: Coin, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ModuleToDistributeCoinsResponse {
    return new ModuleToDistributeCoinsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ModuleToDistributeCoinsResponse {
    return new ModuleToDistributeCoinsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ModuleToDistributeCoinsResponse {
    return new ModuleToDistributeCoinsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ModuleToDistributeCoinsResponse | PlainMessage<ModuleToDistributeCoinsResponse> | undefined, b: ModuleToDistributeCoinsResponse | PlainMessage<ModuleToDistributeCoinsResponse> | undefined): boolean {
    return proto3.util.equals(ModuleToDistributeCoinsResponse, a, b);
  }
}

/**
 * @generated from message osmosis.incentives.GaugeByIDRequest
 */
export class GaugeByIDRequest extends Message<GaugeByIDRequest> {
  /**
   * Gauge ID being queried
   *
   * @generated from field: uint64 id = 1;
   */
  id = protoInt64.zero;

  constructor(data?: PartialMessage<GaugeByIDRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "osmosis.incentives.GaugeByIDRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GaugeByIDRequest {
    return new GaugeByIDRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GaugeByIDRequest {
    return new GaugeByIDRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GaugeByIDRequest {
    return new GaugeByIDRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GaugeByIDRequest | PlainMessage<GaugeByIDRequest> | undefined, b: GaugeByIDRequest | PlainMessage<GaugeByIDRequest> | undefined): boolean {
    return proto3.util.equals(GaugeByIDRequest, a, b);
  }
}

/**
 * @generated from message osmosis.incentives.GaugeByIDResponse
 */
export class GaugeByIDResponse extends Message<GaugeByIDResponse> {
  /**
   * Gauge that corresponds to provided gauge ID
   *
   * @generated from field: osmosis.incentives.Gauge gauge = 1;
   */
  gauge?: Gauge;

  constructor(data?: PartialMessage<GaugeByIDResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "osmosis.incentives.GaugeByIDResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "gauge", kind: "message", T: Gauge },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GaugeByIDResponse {
    return new GaugeByIDResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GaugeByIDResponse {
    return new GaugeByIDResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GaugeByIDResponse {
    return new GaugeByIDResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GaugeByIDResponse | PlainMessage<GaugeByIDResponse> | undefined, b: GaugeByIDResponse | PlainMessage<GaugeByIDResponse> | undefined): boolean {
    return proto3.util.equals(GaugeByIDResponse, a, b);
  }
}

/**
 * @generated from message osmosis.incentives.GaugesRequest
 */
export class GaugesRequest extends Message<GaugesRequest> {
  /**
   * Pagination defines pagination for the request
   *
   * @generated from field: cosmos.base.query.v1beta1.PageRequest pagination = 1;
   */
  pagination?: PageRequest;

  constructor(data?: PartialMessage<GaugesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "osmosis.incentives.GaugesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "pagination", kind: "message", T: PageRequest },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GaugesRequest {
    return new GaugesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GaugesRequest {
    return new GaugesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GaugesRequest {
    return new GaugesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GaugesRequest | PlainMessage<GaugesRequest> | undefined, b: GaugesRequest | PlainMessage<GaugesRequest> | undefined): boolean {
    return proto3.util.equals(GaugesRequest, a, b);
  }
}

/**
 * @generated from message osmosis.incentives.GaugesResponse
 */
export class GaugesResponse extends Message<GaugesResponse> {
  /**
   * Upcoming and active gauges
   *
   * @generated from field: repeated osmosis.incentives.Gauge data = 1;
   */
  data: Gauge[] = [];

  /**
   * Pagination defines pagination for the response
   *
   * @generated from field: cosmos.base.query.v1beta1.PageResponse pagination = 2;
   */
  pagination?: PageResponse;

  constructor(data?: PartialMessage<GaugesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "osmosis.incentives.GaugesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "data", kind: "message", T: Gauge, repeated: true },
    { no: 2, name: "pagination", kind: "message", T: PageResponse },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GaugesResponse {
    return new GaugesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GaugesResponse {
    return new GaugesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GaugesResponse {
    return new GaugesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GaugesResponse | PlainMessage<GaugesResponse> | undefined, b: GaugesResponse | PlainMessage<GaugesResponse> | undefined): boolean {
    return proto3.util.equals(GaugesResponse, a, b);
  }
}

/**
 * @generated from message osmosis.incentives.ActiveGaugesRequest
 */
export class ActiveGaugesRequest extends Message<ActiveGaugesRequest> {
  /**
   * Pagination defines pagination for the request
   *
   * @generated from field: cosmos.base.query.v1beta1.PageRequest pagination = 1;
   */
  pagination?: PageRequest;

  constructor(data?: PartialMessage<ActiveGaugesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "osmosis.incentives.ActiveGaugesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "pagination", kind: "message", T: PageRequest },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ActiveGaugesRequest {
    return new ActiveGaugesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ActiveGaugesRequest {
    return new ActiveGaugesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ActiveGaugesRequest {
    return new ActiveGaugesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ActiveGaugesRequest | PlainMessage<ActiveGaugesRequest> | undefined, b: ActiveGaugesRequest | PlainMessage<ActiveGaugesRequest> | undefined): boolean {
    return proto3.util.equals(ActiveGaugesRequest, a, b);
  }
}

/**
 * @generated from message osmosis.incentives.ActiveGaugesResponse
 */
export class ActiveGaugesResponse extends Message<ActiveGaugesResponse> {
  /**
   * Active gauges only
   *
   * @generated from field: repeated osmosis.incentives.Gauge data = 1;
   */
  data: Gauge[] = [];

  /**
   * Pagination defines pagination for the response
   *
   * @generated from field: cosmos.base.query.v1beta1.PageResponse pagination = 2;
   */
  pagination?: PageResponse;

  constructor(data?: PartialMessage<ActiveGaugesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "osmosis.incentives.ActiveGaugesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "data", kind: "message", T: Gauge, repeated: true },
    { no: 2, name: "pagination", kind: "message", T: PageResponse },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ActiveGaugesResponse {
    return new ActiveGaugesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ActiveGaugesResponse {
    return new ActiveGaugesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ActiveGaugesResponse {
    return new ActiveGaugesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ActiveGaugesResponse | PlainMessage<ActiveGaugesResponse> | undefined, b: ActiveGaugesResponse | PlainMessage<ActiveGaugesResponse> | undefined): boolean {
    return proto3.util.equals(ActiveGaugesResponse, a, b);
  }
}

/**
 * @generated from message osmosis.incentives.ActiveGaugesPerDenomRequest
 */
export class ActiveGaugesPerDenomRequest extends Message<ActiveGaugesPerDenomRequest> {
  /**
   * Desired denom when querying active gauges
   *
   * @generated from field: string denom = 1;
   */
  denom = "";

  /**
   * Pagination defines pagination for the request
   *
   * @generated from field: cosmos.base.query.v1beta1.PageRequest pagination = 2;
   */
  pagination?: PageRequest;

  constructor(data?: PartialMessage<ActiveGaugesPerDenomRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "osmosis.incentives.ActiveGaugesPerDenomRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "pagination", kind: "message", T: PageRequest },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ActiveGaugesPerDenomRequest {
    return new ActiveGaugesPerDenomRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ActiveGaugesPerDenomRequest {
    return new ActiveGaugesPerDenomRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ActiveGaugesPerDenomRequest {
    return new ActiveGaugesPerDenomRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ActiveGaugesPerDenomRequest | PlainMessage<ActiveGaugesPerDenomRequest> | undefined, b: ActiveGaugesPerDenomRequest | PlainMessage<ActiveGaugesPerDenomRequest> | undefined): boolean {
    return proto3.util.equals(ActiveGaugesPerDenomRequest, a, b);
  }
}

/**
 * @generated from message osmosis.incentives.ActiveGaugesPerDenomResponse
 */
export class ActiveGaugesPerDenomResponse extends Message<ActiveGaugesPerDenomResponse> {
  /**
   * Active gauges that match denom in query
   *
   * @generated from field: repeated osmosis.incentives.Gauge data = 1;
   */
  data: Gauge[] = [];

  /**
   * Pagination defines pagination for the response
   *
   * @generated from field: cosmos.base.query.v1beta1.PageResponse pagination = 2;
   */
  pagination?: PageResponse;

  constructor(data?: PartialMessage<ActiveGaugesPerDenomResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "osmosis.incentives.ActiveGaugesPerDenomResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "data", kind: "message", T: Gauge, repeated: true },
    { no: 2, name: "pagination", kind: "message", T: PageResponse },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ActiveGaugesPerDenomResponse {
    return new ActiveGaugesPerDenomResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ActiveGaugesPerDenomResponse {
    return new ActiveGaugesPerDenomResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ActiveGaugesPerDenomResponse {
    return new ActiveGaugesPerDenomResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ActiveGaugesPerDenomResponse | PlainMessage<ActiveGaugesPerDenomResponse> | undefined, b: ActiveGaugesPerDenomResponse | PlainMessage<ActiveGaugesPerDenomResponse> | undefined): boolean {
    return proto3.util.equals(ActiveGaugesPerDenomResponse, a, b);
  }
}

/**
 * @generated from message osmosis.incentives.UpcomingGaugesRequest
 */
export class UpcomingGaugesRequest extends Message<UpcomingGaugesRequest> {
  /**
   * Pagination defines pagination for the request
   *
   * @generated from field: cosmos.base.query.v1beta1.PageRequest pagination = 1;
   */
  pagination?: PageRequest;

  constructor(data?: PartialMessage<UpcomingGaugesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "osmosis.incentives.UpcomingGaugesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "pagination", kind: "message", T: PageRequest },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpcomingGaugesRequest {
    return new UpcomingGaugesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpcomingGaugesRequest {
    return new UpcomingGaugesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpcomingGaugesRequest {
    return new UpcomingGaugesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpcomingGaugesRequest | PlainMessage<UpcomingGaugesRequest> | undefined, b: UpcomingGaugesRequest | PlainMessage<UpcomingGaugesRequest> | undefined): boolean {
    return proto3.util.equals(UpcomingGaugesRequest, a, b);
  }
}

/**
 * @generated from message osmosis.incentives.UpcomingGaugesResponse
 */
export class UpcomingGaugesResponse extends Message<UpcomingGaugesResponse> {
  /**
   * Gauges whose distribution is upcoming
   *
   * @generated from field: repeated osmosis.incentives.Gauge data = 1;
   */
  data: Gauge[] = [];

  /**
   * Pagination defines pagination for the response
   *
   * @generated from field: cosmos.base.query.v1beta1.PageResponse pagination = 2;
   */
  pagination?: PageResponse;

  constructor(data?: PartialMessage<UpcomingGaugesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "osmosis.incentives.UpcomingGaugesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "data", kind: "message", T: Gauge, repeated: true },
    { no: 2, name: "pagination", kind: "message", T: PageResponse },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpcomingGaugesResponse {
    return new UpcomingGaugesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpcomingGaugesResponse {
    return new UpcomingGaugesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpcomingGaugesResponse {
    return new UpcomingGaugesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: UpcomingGaugesResponse | PlainMessage<UpcomingGaugesResponse> | undefined, b: UpcomingGaugesResponse | PlainMessage<UpcomingGaugesResponse> | undefined): boolean {
    return proto3.util.equals(UpcomingGaugesResponse, a, b);
  }
}

/**
 * @generated from message osmosis.incentives.UpcomingGaugesPerDenomRequest
 */
export class UpcomingGaugesPerDenomRequest extends Message<UpcomingGaugesPerDenomRequest> {
  /**
   * Filter for upcoming gauges that match specific denom
   *
   * @generated from field: string denom = 1;
   */
  denom = "";

  /**
   * Pagination defines pagination for the request
   *
   * @generated from field: cosmos.base.query.v1beta1.PageRequest pagination = 2;
   */
  pagination?: PageRequest;

  constructor(data?: PartialMessage<UpcomingGaugesPerDenomRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "osmosis.incentives.UpcomingGaugesPerDenomRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "pagination", kind: "message", T: PageRequest },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpcomingGaugesPerDenomRequest {
    return new UpcomingGaugesPerDenomRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpcomingGaugesPerDenomRequest {
    return new UpcomingGaugesPerDenomRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpcomingGaugesPerDenomRequest {
    return new UpcomingGaugesPerDenomRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpcomingGaugesPerDenomRequest | PlainMessage<UpcomingGaugesPerDenomRequest> | undefined, b: UpcomingGaugesPerDenomRequest | PlainMessage<UpcomingGaugesPerDenomRequest> | undefined): boolean {
    return proto3.util.equals(UpcomingGaugesPerDenomRequest, a, b);
  }
}

/**
 * @generated from message osmosis.incentives.UpcomingGaugesPerDenomResponse
 */
export class UpcomingGaugesPerDenomResponse extends Message<UpcomingGaugesPerDenomResponse> {
  /**
   * Upcoming gauges that match denom in query
   *
   * @generated from field: repeated osmosis.incentives.Gauge upcoming_gauges = 1;
   */
  upcomingGauges: Gauge[] = [];

  /**
   * Pagination defines pagination for the response
   *
   * @generated from field: cosmos.base.query.v1beta1.PageResponse pagination = 2;
   */
  pagination?: PageResponse;

  constructor(data?: PartialMessage<UpcomingGaugesPerDenomResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "osmosis.incentives.UpcomingGaugesPerDenomResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "upcoming_gauges", kind: "message", T: Gauge, repeated: true },
    { no: 2, name: "pagination", kind: "message", T: PageResponse },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpcomingGaugesPerDenomResponse {
    return new UpcomingGaugesPerDenomResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpcomingGaugesPerDenomResponse {
    return new UpcomingGaugesPerDenomResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpcomingGaugesPerDenomResponse {
    return new UpcomingGaugesPerDenomResponse().fromJsonString(jsonString, options);
  }

  static equals(a: UpcomingGaugesPerDenomResponse | PlainMessage<UpcomingGaugesPerDenomResponse> | undefined, b: UpcomingGaugesPerDenomResponse | PlainMessage<UpcomingGaugesPerDenomResponse> | undefined): boolean {
    return proto3.util.equals(UpcomingGaugesPerDenomResponse, a, b);
  }
}

/**
 * @generated from message osmosis.incentives.RewardsEstRequest
 */
export class RewardsEstRequest extends Message<RewardsEstRequest> {
  /**
   * Address that is being queried for future estimated rewards
   *
   * @generated from field: string owner = 1;
   */
  owner = "";

  /**
   * Lock IDs included in future reward estimation
   *
   * @generated from field: repeated uint64 lock_ids = 2;
   */
  lockIds: bigint[] = [];

  /**
   * Upper time limit of reward estimation
   * Lower limit is current epoch
   *
   * @generated from field: int64 end_epoch = 3;
   */
  endEpoch = protoInt64.zero;

  constructor(data?: PartialMessage<RewardsEstRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "osmosis.incentives.RewardsEstRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "owner", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "lock_ids", kind: "scalar", T: 4 /* ScalarType.UINT64 */, repeated: true },
    { no: 3, name: "end_epoch", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RewardsEstRequest {
    return new RewardsEstRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RewardsEstRequest {
    return new RewardsEstRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RewardsEstRequest {
    return new RewardsEstRequest().fromJsonString(jsonString, options);
  }

  static equals(a: RewardsEstRequest | PlainMessage<RewardsEstRequest> | undefined, b: RewardsEstRequest | PlainMessage<RewardsEstRequest> | undefined): boolean {
    return proto3.util.equals(RewardsEstRequest, a, b);
  }
}

/**
 * @generated from message osmosis.incentives.RewardsEstResponse
 */
export class RewardsEstResponse extends Message<RewardsEstResponse> {
  /**
   * Estimated coin rewards that will be received at provided address
   * from specified locks between current time and end epoch
   *
   * @generated from field: repeated cosmos.base.v1beta1.Coin coins = 1;
   */
  coins: Coin[] = [];

  constructor(data?: PartialMessage<RewardsEstResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "osmosis.incentives.RewardsEstResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "coins", kind: "message", T: Coin, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RewardsEstResponse {
    return new RewardsEstResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RewardsEstResponse {
    return new RewardsEstResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RewardsEstResponse {
    return new RewardsEstResponse().fromJsonString(jsonString, options);
  }

  static equals(a: RewardsEstResponse | PlainMessage<RewardsEstResponse> | undefined, b: RewardsEstResponse | PlainMessage<RewardsEstResponse> | undefined): boolean {
    return proto3.util.equals(RewardsEstResponse, a, b);
  }
}

/**
 * @generated from message osmosis.incentives.QueryLockableDurationsRequest
 */
export class QueryLockableDurationsRequest extends Message<QueryLockableDurationsRequest> {
  constructor(data?: PartialMessage<QueryLockableDurationsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "osmosis.incentives.QueryLockableDurationsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryLockableDurationsRequest {
    return new QueryLockableDurationsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryLockableDurationsRequest {
    return new QueryLockableDurationsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryLockableDurationsRequest {
    return new QueryLockableDurationsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryLockableDurationsRequest | PlainMessage<QueryLockableDurationsRequest> | undefined, b: QueryLockableDurationsRequest | PlainMessage<QueryLockableDurationsRequest> | undefined): boolean {
    return proto3.util.equals(QueryLockableDurationsRequest, a, b);
  }
}

/**
 * @generated from message osmosis.incentives.QueryLockableDurationsResponse
 */
export class QueryLockableDurationsResponse extends Message<QueryLockableDurationsResponse> {
  /**
   * Time durations that users can lock coins for in order to receive rewards
   *
   * @generated from field: repeated google.protobuf.Duration lockable_durations = 1;
   */
  lockableDurations: Duration[] = [];

  constructor(data?: PartialMessage<QueryLockableDurationsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "osmosis.incentives.QueryLockableDurationsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "lockable_durations", kind: "message", T: Duration, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryLockableDurationsResponse {
    return new QueryLockableDurationsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryLockableDurationsResponse {
    return new QueryLockableDurationsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryLockableDurationsResponse {
    return new QueryLockableDurationsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryLockableDurationsResponse | PlainMessage<QueryLockableDurationsResponse> | undefined, b: QueryLockableDurationsResponse | PlainMessage<QueryLockableDurationsResponse> | undefined): boolean {
    return proto3.util.equals(QueryLockableDurationsResponse, a, b);
  }
}

/**
 * @generated from message osmosis.incentives.QueryAllGroupsRequest
 */
export class QueryAllGroupsRequest extends Message<QueryAllGroupsRequest> {
  constructor(data?: PartialMessage<QueryAllGroupsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "osmosis.incentives.QueryAllGroupsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryAllGroupsRequest {
    return new QueryAllGroupsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryAllGroupsRequest {
    return new QueryAllGroupsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryAllGroupsRequest {
    return new QueryAllGroupsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryAllGroupsRequest | PlainMessage<QueryAllGroupsRequest> | undefined, b: QueryAllGroupsRequest | PlainMessage<QueryAllGroupsRequest> | undefined): boolean {
    return proto3.util.equals(QueryAllGroupsRequest, a, b);
  }
}

/**
 * @generated from message osmosis.incentives.QueryAllGroupsResponse
 */
export class QueryAllGroupsResponse extends Message<QueryAllGroupsResponse> {
  /**
   * @generated from field: repeated osmosis.incentives.Group groups = 1;
   */
  groups: Group[] = [];

  constructor(data?: PartialMessage<QueryAllGroupsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "osmosis.incentives.QueryAllGroupsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "groups", kind: "message", T: Group, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryAllGroupsResponse {
    return new QueryAllGroupsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryAllGroupsResponse {
    return new QueryAllGroupsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryAllGroupsResponse {
    return new QueryAllGroupsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryAllGroupsResponse | PlainMessage<QueryAllGroupsResponse> | undefined, b: QueryAllGroupsResponse | PlainMessage<QueryAllGroupsResponse> | undefined): boolean {
    return proto3.util.equals(QueryAllGroupsResponse, a, b);
  }
}

/**
 * @generated from message osmosis.incentives.QueryAllGroupsGaugesRequest
 */
export class QueryAllGroupsGaugesRequest extends Message<QueryAllGroupsGaugesRequest> {
  constructor(data?: PartialMessage<QueryAllGroupsGaugesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "osmosis.incentives.QueryAllGroupsGaugesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryAllGroupsGaugesRequest {
    return new QueryAllGroupsGaugesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryAllGroupsGaugesRequest {
    return new QueryAllGroupsGaugesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryAllGroupsGaugesRequest {
    return new QueryAllGroupsGaugesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryAllGroupsGaugesRequest | PlainMessage<QueryAllGroupsGaugesRequest> | undefined, b: QueryAllGroupsGaugesRequest | PlainMessage<QueryAllGroupsGaugesRequest> | undefined): boolean {
    return proto3.util.equals(QueryAllGroupsGaugesRequest, a, b);
  }
}

/**
 * @generated from message osmosis.incentives.QueryAllGroupsGaugesResponse
 */
export class QueryAllGroupsGaugesResponse extends Message<QueryAllGroupsGaugesResponse> {
  /**
   * @generated from field: repeated osmosis.incentives.Gauge gauges = 1;
   */
  gauges: Gauge[] = [];

  constructor(data?: PartialMessage<QueryAllGroupsGaugesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "osmosis.incentives.QueryAllGroupsGaugesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "gauges", kind: "message", T: Gauge, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryAllGroupsGaugesResponse {
    return new QueryAllGroupsGaugesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryAllGroupsGaugesResponse {
    return new QueryAllGroupsGaugesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryAllGroupsGaugesResponse {
    return new QueryAllGroupsGaugesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryAllGroupsGaugesResponse | PlainMessage<QueryAllGroupsGaugesResponse> | undefined, b: QueryAllGroupsGaugesResponse | PlainMessage<QueryAllGroupsGaugesResponse> | undefined): boolean {
    return proto3.util.equals(QueryAllGroupsGaugesResponse, a, b);
  }
}

/**
 * @generated from message osmosis.incentives.QueryAllGroupsWithGaugeRequest
 */
export class QueryAllGroupsWithGaugeRequest extends Message<QueryAllGroupsWithGaugeRequest> {
  constructor(data?: PartialMessage<QueryAllGroupsWithGaugeRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "osmosis.incentives.QueryAllGroupsWithGaugeRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryAllGroupsWithGaugeRequest {
    return new QueryAllGroupsWithGaugeRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryAllGroupsWithGaugeRequest {
    return new QueryAllGroupsWithGaugeRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryAllGroupsWithGaugeRequest {
    return new QueryAllGroupsWithGaugeRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryAllGroupsWithGaugeRequest | PlainMessage<QueryAllGroupsWithGaugeRequest> | undefined, b: QueryAllGroupsWithGaugeRequest | PlainMessage<QueryAllGroupsWithGaugeRequest> | undefined): boolean {
    return proto3.util.equals(QueryAllGroupsWithGaugeRequest, a, b);
  }
}

/**
 * @generated from message osmosis.incentives.QueryAllGroupsWithGaugeResponse
 */
export class QueryAllGroupsWithGaugeResponse extends Message<QueryAllGroupsWithGaugeResponse> {
  /**
   * @generated from field: repeated osmosis.incentives.GroupsWithGauge groups_with_gauge = 1;
   */
  groupsWithGauge: GroupsWithGauge[] = [];

  constructor(data?: PartialMessage<QueryAllGroupsWithGaugeResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "osmosis.incentives.QueryAllGroupsWithGaugeResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "groups_with_gauge", kind: "message", T: GroupsWithGauge, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryAllGroupsWithGaugeResponse {
    return new QueryAllGroupsWithGaugeResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryAllGroupsWithGaugeResponse {
    return new QueryAllGroupsWithGaugeResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryAllGroupsWithGaugeResponse {
    return new QueryAllGroupsWithGaugeResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryAllGroupsWithGaugeResponse | PlainMessage<QueryAllGroupsWithGaugeResponse> | undefined, b: QueryAllGroupsWithGaugeResponse | PlainMessage<QueryAllGroupsWithGaugeResponse> | undefined): boolean {
    return proto3.util.equals(QueryAllGroupsWithGaugeResponse, a, b);
  }
}

/**
 * @generated from message osmosis.incentives.QueryGroupByGroupGaugeIDRequest
 */
export class QueryGroupByGroupGaugeIDRequest extends Message<QueryGroupByGroupGaugeIDRequest> {
  /**
   * @generated from field: uint64 id = 1;
   */
  id = protoInt64.zero;

  constructor(data?: PartialMessage<QueryGroupByGroupGaugeIDRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "osmosis.incentives.QueryGroupByGroupGaugeIDRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryGroupByGroupGaugeIDRequest {
    return new QueryGroupByGroupGaugeIDRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryGroupByGroupGaugeIDRequest {
    return new QueryGroupByGroupGaugeIDRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryGroupByGroupGaugeIDRequest {
    return new QueryGroupByGroupGaugeIDRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryGroupByGroupGaugeIDRequest | PlainMessage<QueryGroupByGroupGaugeIDRequest> | undefined, b: QueryGroupByGroupGaugeIDRequest | PlainMessage<QueryGroupByGroupGaugeIDRequest> | undefined): boolean {
    return proto3.util.equals(QueryGroupByGroupGaugeIDRequest, a, b);
  }
}

/**
 * @generated from message osmosis.incentives.QueryGroupByGroupGaugeIDResponse
 */
export class QueryGroupByGroupGaugeIDResponse extends Message<QueryGroupByGroupGaugeIDResponse> {
  /**
   * @generated from field: osmosis.incentives.Group group = 1;
   */
  group?: Group;

  constructor(data?: PartialMessage<QueryGroupByGroupGaugeIDResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "osmosis.incentives.QueryGroupByGroupGaugeIDResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "group", kind: "message", T: Group },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryGroupByGroupGaugeIDResponse {
    return new QueryGroupByGroupGaugeIDResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryGroupByGroupGaugeIDResponse {
    return new QueryGroupByGroupGaugeIDResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryGroupByGroupGaugeIDResponse {
    return new QueryGroupByGroupGaugeIDResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryGroupByGroupGaugeIDResponse | PlainMessage<QueryGroupByGroupGaugeIDResponse> | undefined, b: QueryGroupByGroupGaugeIDResponse | PlainMessage<QueryGroupByGroupGaugeIDResponse> | undefined): boolean {
    return proto3.util.equals(QueryGroupByGroupGaugeIDResponse, a, b);
  }
}

/**
 * @generated from message osmosis.incentives.QueryCurrentWeightByGroupGaugeIDRequest
 */
export class QueryCurrentWeightByGroupGaugeIDRequest extends Message<QueryCurrentWeightByGroupGaugeIDRequest> {
  /**
   * @generated from field: uint64 group_gauge_id = 1;
   */
  groupGaugeId = protoInt64.zero;

  constructor(data?: PartialMessage<QueryCurrentWeightByGroupGaugeIDRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "osmosis.incentives.QueryCurrentWeightByGroupGaugeIDRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "group_gauge_id", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryCurrentWeightByGroupGaugeIDRequest {
    return new QueryCurrentWeightByGroupGaugeIDRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryCurrentWeightByGroupGaugeIDRequest {
    return new QueryCurrentWeightByGroupGaugeIDRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryCurrentWeightByGroupGaugeIDRequest {
    return new QueryCurrentWeightByGroupGaugeIDRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryCurrentWeightByGroupGaugeIDRequest | PlainMessage<QueryCurrentWeightByGroupGaugeIDRequest> | undefined, b: QueryCurrentWeightByGroupGaugeIDRequest | PlainMessage<QueryCurrentWeightByGroupGaugeIDRequest> | undefined): boolean {
    return proto3.util.equals(QueryCurrentWeightByGroupGaugeIDRequest, a, b);
  }
}

/**
 * @generated from message osmosis.incentives.QueryCurrentWeightByGroupGaugeIDResponse
 */
export class QueryCurrentWeightByGroupGaugeIDResponse extends Message<QueryCurrentWeightByGroupGaugeIDResponse> {
  /**
   * @generated from field: repeated osmosis.incentives.GaugeWeight gauge_weight = 1;
   */
  gaugeWeight: GaugeWeight[] = [];

  constructor(data?: PartialMessage<QueryCurrentWeightByGroupGaugeIDResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "osmosis.incentives.QueryCurrentWeightByGroupGaugeIDResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "gauge_weight", kind: "message", T: GaugeWeight, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryCurrentWeightByGroupGaugeIDResponse {
    return new QueryCurrentWeightByGroupGaugeIDResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryCurrentWeightByGroupGaugeIDResponse {
    return new QueryCurrentWeightByGroupGaugeIDResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryCurrentWeightByGroupGaugeIDResponse {
    return new QueryCurrentWeightByGroupGaugeIDResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryCurrentWeightByGroupGaugeIDResponse | PlainMessage<QueryCurrentWeightByGroupGaugeIDResponse> | undefined, b: QueryCurrentWeightByGroupGaugeIDResponse | PlainMessage<QueryCurrentWeightByGroupGaugeIDResponse> | undefined): boolean {
    return proto3.util.equals(QueryCurrentWeightByGroupGaugeIDResponse, a, b);
  }
}

/**
 * @generated from message osmosis.incentives.GaugeWeight
 */
export class GaugeWeight extends Message<GaugeWeight> {
  /**
   * @generated from field: uint64 gauge_id = 1;
   */
  gaugeId = protoInt64.zero;

  /**
   * @generated from field: string weight_ratio = 2;
   */
  weightRatio = "";

  constructor(data?: PartialMessage<GaugeWeight>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "osmosis.incentives.GaugeWeight";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "gauge_id", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "weight_ratio", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GaugeWeight {
    return new GaugeWeight().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GaugeWeight {
    return new GaugeWeight().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GaugeWeight {
    return new GaugeWeight().fromJsonString(jsonString, options);
  }

  static equals(a: GaugeWeight | PlainMessage<GaugeWeight> | undefined, b: GaugeWeight | PlainMessage<GaugeWeight> | undefined): boolean {
    return proto3.util.equals(GaugeWeight, a, b);
  }
}

